var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Calysto;
(function (Calysto) {
    var Tasks;
    (function (Tasks) {
        /**
         *  Promise implementation for IE <= 11 where Promise is not implemented
         *  Complete implementation compatible with window.Promise
         */
        class CPromise {
            constructor(executor) {
                this.executor = executor;
                if (this.executor) {
                    try {
                        this.executor(value => this.notifyResolved(value), value => this.notifyRejected(value));
                    }
                    catch (ex) {
                        this.notifyRejected(ex);
                    }
                }
            }
            notifyResolved(value) {
                this._isResolved = true;
                this._resolveValue = value;
                this.notifyNext();
            }
            notifyRejected(value) {
                this._isRejected = true;
                this._rejectValue = value;
                this.notifyNext();
            }
            notifyNext() {
                if (this._nextPromise && !this._isNextNotified) {
                    if (this._isRejected && this._nextPromise._onPreviousFailed) {
                        this._isNextNotified = true;
                        this._nextPromise._onPreviousFailed(this._rejectValue);
                        this._nextPromise.notifyNext();
                    }
                    else if (this._isResolved && this._nextPromise._onPreviousSuccess) {
                        this._isNextNotified = true;
                        this._nextPromise._onPreviousSuccess(this._resolveValue);
                        this._nextPromise.notifyNext();
                    }
                }
            }
            then(onResolved, onRejected) {
                let next = new CPromise();
                next._onPreviousSuccess = (previousValue) => {
                    try {
                        // if Promise ctor executor returns Promise
                        if (previousValue && previousValue.then) {
                            let p1 = previousValue;
                            p1.then(v1 => next._onPreviousSuccess(v1), e1 => next._onPreviousFailed(e1));
                            return;
                        }
                        if (!onResolved)
                            onResolved = x => x;
                        // if onResolved returns Promise
                        let currValue = onResolved(previousValue);
                        if (currValue && currValue.then) {
                            let currPromise = currValue;
                            currPromise.then(value => {
                                next.notifyResolved(value);
                            }, err => {
                                next.notifyRejected(err);
                            });
                        }
                        else {
                            next.notifyResolved(currValue);
                        }
                    }
                    catch (e1) {
                        next.notifyRejected(e1);
                    }
                };
                next._onPreviousFailed = (previsousError) => {
                    try {
                        if (!onRejected)
                            onRejected = x => { throw x; };
                        let currErr = onRejected(previsousError);
                        if (currErr && currErr.then) {
                            let currPromise = currErr;
                            currPromise.then(value => {
                                next.notifyResolved(value);
                            }, err => {
                                next.notifyRejected(err);
                            });
                        }
                        else {
                            next.notifyResolved(currErr);
                        }
                    }
                    catch (e1) {
                        next.notifyRejected(e1);
                    }
                };
                this._nextPromise = next;
                this.notifyNext();
                return next;
            }
            catch(fn) {
                return this.then(v => v, fn || (x => x));
            }
            finally(fn) {
                return this.then(fn ? x => { fn(); return x; /*return*/ } : x => x, fn ? x => { fn(); throw x; /*throw*/ } : x => x);
            }
            static resolve(value) {
                return new CPromise((resolve, reject) => {
                    resolve(value);
                });
            }
            static reject(value) {
                return new CPromise((resolve, reject) => {
                    reject(value);
                });
            }
        }
        Tasks.CPromise = CPromise;
        // IE <= 11 has no Pomise
        if (!window.Promise)
            window.Promise = CPromise;
    })(Tasks = Calysto.Tasks || (Calysto.Tasks = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Tasks;
    (function (Tasks) {
        class TaskState {
            get IsCancelled() { return this._isCancelled; }
            /**
             * Start timer which will invoke OnError when time elapsed.
             * Timer is aborted when Cancel() is invoked or NotifyError() or NotifySuccess()
             * @param timeoutMs
             */
            Watchdog(timeoutMs) {
                this._timer = setTimeout(() => {
                    this.Cancel();
                    if (this._onError)
                        this._onError("Timeout");
                }, timeoutMs);
            }
            Cancel() {
                clearTimeout(this._timer);
                this._isCancelled = true;
            }
            OnError(fn) {
                this._onError = fn;
            }
            NotifyError(err) {
                this.Cancel();
                if (this._onError)
                    this._onError(err);
            }
            OnSuccess(fn) {
                this._onSuccess = fn;
            }
            NotifySuccess(value) {
                this.Cancel();
                if (this._onSuccess)
                    this._onSuccess(value);
            }
        }
        Tasks.TaskState = TaskState;
    })(Tasks = Calysto.Tasks || (Calysto.Tasks = {}));
})(Calysto || (Calysto = {}));
/// <reference path="taskstate.ts" />
var Calysto;
(function (Calysto) {
    var Tasks;
    (function (Tasks) {
        var TaskUtility;
        (function (TaskUtility) {
            function SleepAsync(durationMs) {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((resolve, reject) => {
                        setTimeout(() => resolve(true), durationMs);
                    });
                });
            }
            TaskUtility.SleepAsync = SleepAsync;
            function RunAsync(executor) {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((resolve, reject) => {
                        let state = new Tasks.TaskState();
                        state.OnError(err => reject(err));
                        state.OnSuccess(value => resolve(value));
                        executor(state);
                    });
                });
            }
            TaskUtility.RunAsync = RunAsync;
        })(TaskUtility = Tasks.TaskUtility || (Tasks.TaskUtility = {}));
    })(Tasks = Calysto.Tasks || (Calysto.Tasks = {}));
})(Calysto || (Calysto = {}));
/// <reference path="CPromise.ts" />
/// <reference path="TaskUtility.ts" />
var Calysto;
(function (Calysto) {
    var Resources;
    (function (Resources) {
        var Images;
        (function (Images) {
            Images.Arrows_ArrowBlackDown = "~/Images/Arrows/ArrowBlackDown.png";
            Images.Arrows_ArrowBlackUp = "~/Images/Arrows/ArrowBlackUp.png";
            Images.Arrows_ArrowWhiteDown = "~/Images/Arrows/ArrowWhiteDown.png";
            Images.Arrows_ArrowWhiteUp = "~/Images/Arrows/ArrowWhiteUp.png";
            Images.Pictures_facebook_icon = "~/Images/Pictures/facebook-icon.png";
            Images.Pictures_Google_Plus_icon = "~/Images/Pictures/Google-Plus-icon.png";
            Images.Pictures_NoPhoto100 = "~/Images/Pictures/NoPhoto100.gif";
            Images.Pictures_NoPhoto200 = "~/Images/Pictures/NoPhoto200.gif";
            Images.Pictures_NoPhoto300 = "~/Images/Pictures/NoPhoto300.gif";
            Images.Pictures_NoPhoto50 = "~/Images/Pictures/NoPhoto50.gif";
            Images.WindowButtons_btnClose = "~/Images/WindowButtons/btnClose.gif";
            Images.WindowButtons_btnCloseHover = "~/Images/WindowButtons/btnCloseHover.gif";
            Images.WindowButtons_btnCloseInactive = "~/Images/WindowButtons/btnCloseInactive.gif";
            Images.WindowButtons_btnMaximized = "~/Images/WindowButtons/btnMaximized.gif";
            Images.WindowButtons_btnMaximizedHover = "~/Images/WindowButtons/btnMaximizedHover.gif";
            Images.WindowButtons_btnMaximizedInactive = "~/Images/WindowButtons/btnMaximizedInactive.gif";
            Images.WindowButtons_btnMinimize = "~/Images/WindowButtons/btnMinimize.gif";
            Images.WindowButtons_btnMinimizeHover = "~/Images/WindowButtons/btnMinimizeHover.gif";
            Images.WindowButtons_btnMinimizeInactive = "~/Images/WindowButtons/btnMinimizeInactive.gif";
            Images.WindowButtons_btnResize = "~/Images/WindowButtons/btnResize.gif";
            Images.WindowButtons_btnResizeHover = "~/Images/WindowButtons/btnResizeHover.gif";
            Images.WindowButtons_btnResizeInactive = "~/Images/WindowButtons/btnResizeInactive.gif";
            Images.WindowButtons_btnToolClose = "~/Images/WindowButtons/btnToolClose.gif";
            Images.WindowButtons_btnToolCloseHover = "~/Images/WindowButtons/btnToolCloseHover.gif";
            Images.Horoscope_Icons_aquarius_128 = "~/Images/Horoscope/Icons/aquarius_128.png";
            Images.Horoscope_Icons_aries_128 = "~/Images/Horoscope/Icons/aries_128.png";
            Images.Horoscope_Icons_cancer_128 = "~/Images/Horoscope/Icons/cancer_128.png";
            Images.Horoscope_Icons_capricorn_128 = "~/Images/Horoscope/Icons/capricorn_128.png";
            Images.Horoscope_Icons_gemini_128 = "~/Images/Horoscope/Icons/gemini_128.png";
            Images.Horoscope_Icons_leo_128 = "~/Images/Horoscope/Icons/leo_128.png";
            Images.Horoscope_Icons_libra_128 = "~/Images/Horoscope/Icons/libra_128.png";
            Images.Horoscope_Icons_pisces_128 = "~/Images/Horoscope/Icons/pisces_128.png";
            Images.Horoscope_Icons_sagittarius_128 = "~/Images/Horoscope/Icons/sagittarius_128.png";
            Images.Horoscope_Icons_scorpio_128 = "~/Images/Horoscope/Icons/scorpio_128.png";
            Images.Horoscope_Icons_taurus_128 = "~/Images/Horoscope/Icons/taurus_128.png";
            Images.Horoscope_Icons_virgo_128 = "~/Images/Horoscope/Icons/virgo_128.png";
            Images.Horoscope_Signs_aquarius_zodiac_sign = "~/Images/Horoscope/Signs/aquarius_zodiac_sign.png";
            Images.Horoscope_Signs_aries_zodiac_sign = "~/Images/Horoscope/Signs/aries_zodiac_sign.png";
            Images.Horoscope_Signs_cancer_zodiac_sign = "~/Images/Horoscope/Signs/cancer_zodiac_sign.png";
            Images.Horoscope_Signs_capricorn_zodiac_sign = "~/Images/Horoscope/Signs/capricorn_zodiac_sign.png";
            Images.Horoscope_Signs_gemini_zodiac_sign = "~/Images/Horoscope/Signs/gemini_zodiac_sign.png";
            Images.Horoscope_Signs_leo_zodiac_sign = "~/Images/Horoscope/Signs/leo_zodiac_sign.png";
            Images.Horoscope_Signs_libra_zodiac_sign = "~/Images/Horoscope/Signs/libra_zodiac_sign.png";
            Images.Horoscope_Signs_pisces_zodiac_sign = "~/Images/Horoscope/Signs/pisces_zodiac_sign.png";
            Images.Horoscope_Signs_sagittarius_zodiac_sign = "~/Images/Horoscope/Signs/sagittarius_zodiac_sign.png";
            Images.Horoscope_Signs_scorpio_zodiac_sign = "~/Images/Horoscope/Signs/scorpio_zodiac_sign.png";
            Images.Horoscope_Signs_taurus_zodiac_sign = "~/Images/Horoscope/Signs/taurus_zodiac_sign.png";
            Images.Horoscope_Signs_virgo_zodiac_sign = "~/Images/Horoscope/Signs/virgo_zodiac_sign.png";
            Images.Icons_Ajax2Preloader_Ajax12TrailBlack = "~/Images/Icons/Ajax2Preloader/Ajax12TrailBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax14FlowerBlack = "~/Images/Icons/Ajax2Preloader/Ajax14FlowerBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax14TrailBlack = "~/Images/Icons/Ajax2Preloader/Ajax14TrailBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax16ArcBlack = "~/Images/Icons/Ajax2Preloader/Ajax16ArcBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax16ArrowsBlack = "~/Images/Icons/Ajax2Preloader/Ajax16ArrowsBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax16DotBlack = "~/Images/Icons/Ajax2Preloader/Ajax16DotBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax24DotBlack = "~/Images/Icons/Ajax2Preloader/Ajax24DotBlack.gif";
            Images.Icons_Ajax2Preloader_Ajax24DotBlue = "~/Images/Icons/Ajax2Preloader/Ajax24DotBlue.gif";
            Images.Icons_Ajax2Preloader_Ajax24DotRed = "~/Images/Icons/Ajax2Preloader/Ajax24DotRed.gif";
            Images.Icons_Ajax2Preloader_Ajax32SandClock = "~/Images/Icons/Ajax2Preloader/Ajax32SandClock.png";
            Images.Icons_Ajax2Preloader_FB_black_small = "~/Images/Icons/Ajax2Preloader/FB_black_small.gif";
            Images.Icons_Ajax2Preloader_skype_black2white = "~/Images/Icons/Ajax2Preloader/skype_black2white.GIF";
            Images.Icons_Ajax2Preloader_skype_blue2white = "~/Images/Icons/Ajax2Preloader/skype_blue2white.GIF";
            Images.Icons_Ajax2Preloader_skype_green2white = "~/Images/Icons/Ajax2Preloader/skype_green2white.GIF";
            Images.Icons_Ajax2Preloader_skype_red2white = "~/Images/Icons/Ajax2Preloader/skype_red2white.GIF";
            Images.Icons_Ajax2Preloader_skype_white2black = "~/Images/Icons/Ajax2Preloader/skype_white2black.GIF";
            Images.Icons_Smiley_angry = "~/Images/Icons/Smiley/angry.gif";
            Images.Icons_Smiley_applause = "~/Images/Icons/Smiley/applause.gif";
            Images.Icons_Smiley_bigGrin = "~/Images/Icons/Smiley/bigGrin.gif";
            Images.Icons_Smiley_bigHug = "~/Images/Icons/Smiley/bigHug.gif";
            Images.Icons_Smiley_confused = "~/Images/Icons/Smiley/confused.gif";
            Images.Icons_Smiley_cool = "~/Images/Icons/Smiley/cool.gif";
            Images.Icons_Smiley_crying = "~/Images/Icons/Smiley/crying.gif";
            Images.Icons_Smiley_dancing = "~/Images/Icons/Smiley/dancing.gif";
            Images.Icons_Smiley_devil = "~/Images/Icons/Smiley/devil.gif";
            Images.Icons_Smiley_dontTellAnyone = "~/Images/Icons/Smiley/dontTellAnyone.gif";
            Images.Icons_Smiley_happy = "~/Images/Icons/Smiley/happy.gif";
            Images.Icons_Smiley_hurryUp = "~/Images/Icons/Smiley/hurryUp.gif";
            Images.Icons_Smiley_kiss = "~/Images/Icons/Smiley/kiss.gif";
            Images.Icons_Smiley_laughing = "~/Images/Icons/Smiley/laughing.gif";
            Images.Icons_Smiley_notWorthy = "~/Images/Icons/Smiley/notWorthy.gif";
            Images.Icons_Smiley_party = "~/Images/Icons/Smiley/party.gif";
            Images.Icons_Smiley_rockOn = "~/Images/Icons/Smiley/rockOn.gif";
            Images.Icons_Smiley_rollingOnTheFloor = "~/Images/Icons/Smiley/rollingOnTheFloor.gif";
            Images.Icons_Smiley_sad = "~/Images/Icons/Smiley/sad.gif";
            Images.Icons_Smiley_surprise = "~/Images/Icons/Smiley/surprise.gif";
            Images.Icons_Smiley_thinking = "~/Images/Icons/Smiley/thinking.gif";
            Images.Icons_Smiley_thumbsDown = "~/Images/Icons/Smiley/thumbsDown.gif";
            Images.Icons_Smiley_tongue = "~/Images/Icons/Smiley/tongue.gif";
            Images.Icons_Smiley_winking = "~/Images/Icons/Smiley/winking.gif";
            Images.WindowButtons_Original_PNG_btnClose = "~/Images/WindowButtons/Original_PNG/btnClose.png";
            Images.WindowButtons_Original_PNG_btnCloseHover = "~/Images/WindowButtons/Original_PNG/btnCloseHover.png";
            Images.WindowButtons_Original_PNG_btnCloseInactive = "~/Images/WindowButtons/Original_PNG/btnCloseInactive.png";
            Images.WindowButtons_Original_PNG_btnMaximized = "~/Images/WindowButtons/Original_PNG/btnMaximized.png";
            Images.WindowButtons_Original_PNG_btnMaximizedHover = "~/Images/WindowButtons/Original_PNG/btnMaximizedHover.png";
            Images.WindowButtons_Original_PNG_btnMaximizedInactive = "~/Images/WindowButtons/Original_PNG/btnMaximizedInactive.png";
            Images.WindowButtons_Original_PNG_btnMinimize = "~/Images/WindowButtons/Original_PNG/btnMinimize.png";
            Images.WindowButtons_Original_PNG_btnMinimizeHover = "~/Images/WindowButtons/Original_PNG/btnMinimizeHover.png";
            Images.WindowButtons_Original_PNG_btnMinimizeInactive = "~/Images/WindowButtons/Original_PNG/btnMinimizeInactive.png";
            Images.WindowButtons_Original_PNG_btnResize = "~/Images/WindowButtons/Original_PNG/btnResize.png";
            Images.WindowButtons_Original_PNG_btnResizeHover = "~/Images/WindowButtons/Original_PNG/btnResizeHover.png";
            Images.WindowButtons_Original_PNG_btnResizeInactive = "~/Images/WindowButtons/Original_PNG/btnResizeInactive.png";
            Images.WindowButtons_Original_PNG_btnToolClose = "~/Images/WindowButtons/Original_PNG/btnToolClose.png";
            Images.WindowButtons_Original_PNG_btnToolCloseHover = "~/Images/WindowButtons/Original_PNG/btnToolCloseHover.png";
            Images.Icons_s32_aha_Apply = "~/Images/Icons/s32/aha/Apply.png";
            Images.Icons_s32_aha_Back = "~/Images/Icons/s32/aha/Back.png";
            Images.Icons_s32_aha_Cancel = "~/Images/Icons/s32/aha/Cancel.png";
            Images.Icons_s32_aha_Close = "~/Images/Icons/s32/aha/Close.png";
            Images.Icons_s32_aha_Danger = "~/Images/Icons/s32/aha/Danger.png";
            Images.Icons_s32_aha_Delete = "~/Images/Icons/s32/aha/Delete.png";
            Images.Icons_s32_aha_EditPage = "~/Images/Icons/s32/aha/EditPage.png";
            Images.Icons_s32_aha_Error = "~/Images/Icons/s32/aha/Error.png";
            Images.Icons_s32_aha_Forward = "~/Images/Icons/s32/aha/Forward.png";
            Images.Icons_s32_aha_GoDown = "~/Images/Icons/s32/aha/GoDown.png";
            Images.Icons_s32_aha_GoUp = "~/Images/Icons/s32/aha/GoUp.png";
            Images.Icons_s32_aha_Help = "~/Images/Icons/s32/aha/Help.png";
            Images.Icons_s32_aha_Info = "~/Images/Icons/s32/aha/Info.png";
            Images.Icons_s32_aha_No = "~/Images/Icons/s32/aha/No.png";
            Images.Icons_s32_aha_Ok = "~/Images/Icons/s32/aha/Ok.png";
            Images.Icons_s32_aha_Pencil = "~/Images/Icons/s32/aha/Pencil.png";
            Images.Icons_s32_aha_Picture = "~/Images/Icons/s32/aha/Picture.png";
            Images.Icons_s32_aha_Play = "~/Images/Icons/s32/aha/Play.png";
            Images.Icons_s32_aha_Refresh = "~/Images/Icons/s32/aha/Refresh.png";
            Images.Icons_s32_aha_Settings = "~/Images/Icons/s32/aha/Settings.png";
            Images.Icons_s32_aha_Show = "~/Images/Icons/s32/aha/Show.png";
            Images.Icons_s32_aha_Stop = "~/Images/Icons/s32/aha/Stop.png";
            Images.Icons_s32_aha_StopPlaying = "~/Images/Icons/s32/aha/StopPlaying.png";
            Images.Icons_s32_aha_Warning = "~/Images/Icons/s32/aha/Warning.png";
            Images.Icons_s32_aha_Wrong = "~/Images/Icons/s32/aha/Wrong.png";
            Images.Icons_s32_fatcow_film = "~/Images/Icons/s32/fatcow/film.png";
            Images.Icons_s16_silk_icons_accept = "~/Images/Icons/s16/silk/icons/accept.png";
            Images.Icons_s16_silk_icons_add = "~/Images/Icons/s16/silk/icons/add.png";
            Images.Icons_s16_silk_icons_anchor = "~/Images/Icons/s16/silk/icons/anchor.png";
            Images.Icons_s16_silk_icons_application = "~/Images/Icons/s16/silk/icons/application.png";
            Images.Icons_s16_silk_icons_application_edit = "~/Images/Icons/s16/silk/icons/application_edit.png";
            Images.Icons_s16_silk_icons_brick_edit = "~/Images/Icons/s16/silk/icons/brick_edit.png";
            Images.Icons_s16_silk_icons_cancel = "~/Images/Icons/s16/silk/icons/cancel.png";
            Images.Icons_s16_silk_icons_cross = "~/Images/Icons/s16/silk/icons/cross.png";
            Images.Icons_s16_silk_icons_date = "~/Images/Icons/s16/silk/icons/date.png";
            Images.Icons_s16_silk_icons_delete = "~/Images/Icons/s16/silk/icons/delete.png";
            Images.Icons_s16_silk_icons_disconnect = "~/Images/Icons/s16/silk/icons/disconnect.png";
            Images.Icons_s16_silk_icons_disk = "~/Images/Icons/s16/silk/icons/disk.png";
            Images.Icons_s16_silk_icons_error = "~/Images/Icons/s16/silk/icons/error.png";
            Images.Icons_s16_silk_icons_exclamation = "~/Images/Icons/s16/silk/icons/exclamation.png";
            Images.Icons_s16_silk_icons_eye = "~/Images/Icons/s16/silk/icons/eye.png";
            Images.Icons_s16_silk_icons_feed = "~/Images/Icons/s16/silk/icons/feed.png";
            Images.Icons_s16_silk_icons_help = "~/Images/Icons/s16/silk/icons/help.png";
            Images.Icons_s16_silk_icons_hourglass = "~/Images/Icons/s16/silk/icons/hourglass.png";
            Images.Icons_s16_silk_icons_lock_break = "~/Images/Icons/s16/silk/icons/lock_break.png";
            Images.Icons_s16_silk_icons_magifier_zoom_out = "~/Images/Icons/s16/silk/icons/magifier_zoom_out.png";
            Images.Icons_s16_silk_icons_magnifier = "~/Images/Icons/s16/silk/icons/magnifier.png";
            Images.Icons_s16_silk_icons_magnifier_zoom_in = "~/Images/Icons/s16/silk/icons/magnifier_zoom_in.png";
            Images.Icons_s16_silk_icons_male = "~/Images/Icons/s16/silk/icons/male.png";
            Images.Icons_s16_silk_icons_map = "~/Images/Icons/s16/silk/icons/map.png";
            Images.Icons_s16_silk_icons_page_add = "~/Images/Icons/s16/silk/icons/page_add.png";
            Images.Icons_s16_silk_icons_page_edit = "~/Images/Icons/s16/silk/icons/page_edit.png";
            Images.Icons_s16_silk_icons_page_white = "~/Images/Icons/s16/silk/icons/page_white.png";
            Images.Icons_s16_silk_icons_picture = "~/Images/Icons/s16/silk/icons/picture.png";
            Images.Icons_s16_silk_icons_pictures = "~/Images/Icons/s16/silk/icons/pictures.png";
            Images.Icons_s16_silk_icons_picture_add = "~/Images/Icons/s16/silk/icons/picture_add.png";
            Images.Icons_s16_silk_icons_plugin = "~/Images/Icons/s16/silk/icons/plugin.png";
            Images.Icons_s16_silk_icons_plugin_edit = "~/Images/Icons/s16/silk/icons/plugin_edit.png";
            Images.Icons_s16_silk_icons_stop = "~/Images/Icons/s16/silk/icons/stop.png";
            Images.Icons_s16_silk_icons_thumb_down = "~/Images/Icons/s16/silk/icons/thumb_down.png";
            Images.Icons_s16_silk_icons_thumb_up = "~/Images/Icons/s16/silk/icons/thumb_up.png";
            Images.Icons_s16_silk_icons_tick = "~/Images/Icons/s16/silk/icons/tick.png";
            Images.Icons_s16_silk_icons_time = "~/Images/Icons/s16/silk/icons/time.png";
            Images.Icons_s16_silk_icons_user = "~/Images/Icons/s16/silk/icons/user.png";
            Images.Icons_s16_silk_icons_zoom = "~/Images/Icons/s16/silk/icons/zoom.png";
            Images.Icons_s16_silk_icons_zoom_in = "~/Images/Icons/s16/silk/icons/zoom_in.png";
            Images.Icons_s16_silk_icons_zoom_out = "~/Images/Icons/s16/silk/icons/zoom_out.png";
        })(Images = Resources.Images || (Resources.Images = {}));
    })(Resources = Calysto.Resources || (Calysto.Resources = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        Constants.AppConstants = {
            "EmailRegexPattern": "^[\\w\\.\\+\\-_\u0027]+[@][\\w\\+\\-_\u0027]+?[\\.][\\w\\.\\+\\-_\u0027]+$",
            "BroadcastMethodName": "$broadcast-message$"
        };
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        var WsjsHeaderConstants;
        (function (WsjsHeaderConstants) {
            WsjsHeaderConstants.XAjaxHeaderKey = `calysto-x-ajax`;
            WsjsHeaderConstants.XAjaxHeaderValue = `calysto-ajax`;
            WsjsHeaderConstants.XExceptionHeaderValue = `calysto-exception`;
            WsjsHeaderConstants.XTypeHeaderKey = `calysto-x-type`;
            WsjsHeaderConstants.XTypeHeaderBinaryFrameValue = `calysto-binary-frame`;
            WsjsHeaderConstants.XCalystoAjaxFormKey = `calysto-x-ajax-form`;
            WsjsHeaderConstants.XCalystoAjaxFormValue = `calysto-yes`;
            WsjsHeaderConstants.XCalystoAjaxLoadKey = `calysto-x-ajax-load`;
            WsjsHeaderConstants.XCalystoAjaxLoadValue = `calysto-yes`;
            WsjsHeaderConstants.XCalystoResponseContainerKey = `calysto-x-container`;
            WsjsHeaderConstants.XCalystoResponseContainerValue = `calysto-yes`;
        })(WsjsHeaderConstants = Constants.WsjsHeaderConstants || (Constants.WsjsHeaderConstants = {}));
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        Constants.PredefinedCultures = {
            "en-US": {
                "Name": "en-US",
                "NativeName": "English (United States)",
                "DisplayName": "English (United States)",
                "EnglishName": "English (United States)",
                "ThreeLetterISOLanguageName": "eng",
                "ThreeLetterWindowsLanguageName": "ENU",
                "TwoLetterISOLanguageName": "en",
                "DateTimeFormat": {
                    "ShortestDayNames": [
                        "Su",
                        "Mo",
                        "Tu",
                        "We",
                        "Th",
                        "Fr",
                        "Sa"
                    ],
                    "AbbreviatedDayNames": [
                        "Sun",
                        "Mon",
                        "Tue",
                        "Wed",
                        "Thu",
                        "Fri",
                        "Sat"
                    ],
                    "DayNames": [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday"
                    ],
                    "AbbreviatedMonthNames": [
                        "Jan",
                        "Feb",
                        "Mar",
                        "Apr",
                        "May",
                        "Jun",
                        "Jul",
                        "Aug",
                        "Sep",
                        "Oct",
                        "Nov",
                        "Dec",
                        ""
                    ],
                    "MonthNames": [
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December",
                        ""
                    ],
                    "FirstDayOfWeek": 0,
                    "LongDatePattern": "dddd, MMMM d, yyyy",
                    "LongTimePattern": "h:mm:ss tt",
                    "MonthDayPattern": "MMMM d",
                    "ShortDatePattern": "M/d/yyyy",
                    "ShortTimePattern": "h:mm tt",
                    "GeneralLongTimePattern": "M/d/yyyy h:mm:ss tt",
                    "GeneralShortTimePattern": "M/d/yyyy h:mm tt"
                },
                "NumberFormat": {
                    "CurrencySymbol": "$",
                    "NumberDecimalSeparator": ".",
                    "NumberGroupSeparator": ",",
                    "PerMilleSymbol": "‰",
                    "PercentSymbol": "%",
                    "CurrencyPositivePattern": 0,
                    "CurrencyPositivePatternString": "{CurrencySymbol}{Value}"
                },
                "Region": {
                    "CurrencyEnglishName": "US Dollar",
                    "CurrencyNativeName": "US Dollar",
                    "CurrencySymbol": "$",
                    "DisplayName": "United States",
                    "EnglishName": "United States",
                    "IsMetric": false,
                    "ISOCurrencySymbol": "USD",
                    "Name": "US",
                    "NativeName": "United States",
                    "ThreeLetterISORegionName": "USA",
                    "ThreeLetterWindowsRegionName": "USA",
                    "TwoLetterISORegionName": "US"
                }
            },
            "hr-HR": {
                "Name": "hr-HR",
                "NativeName": "hrvatski (Hrvatska)",
                "DisplayName": "Croatian (Croatia)",
                "EnglishName": "Croatian (Croatia)",
                "ThreeLetterISOLanguageName": "hrv",
                "ThreeLetterWindowsLanguageName": "HRV",
                "TwoLetterISOLanguageName": "hr",
                "DateTimeFormat": {
                    "ShortestDayNames": [
                        "ne",
                        "po",
                        "ut",
                        "sr",
                        "če",
                        "pe",
                        "su"
                    ],
                    "AbbreviatedDayNames": [
                        "ned",
                        "pon",
                        "uto",
                        "sri",
                        "čet",
                        "pet",
                        "sub"
                    ],
                    "DayNames": [
                        "nedjelja",
                        "ponedjeljak",
                        "utorak",
                        "srijeda",
                        "četvrtak",
                        "petak",
                        "subota"
                    ],
                    "AbbreviatedMonthNames": [
                        "sij",
                        "vlj",
                        "ožu",
                        "tra",
                        "svi",
                        "lip",
                        "srp",
                        "kol",
                        "ruj",
                        "lis",
                        "stu",
                        "pro",
                        ""
                    ],
                    "MonthNames": [
                        "siječanj",
                        "veljača",
                        "ožujak",
                        "travanj",
                        "svibanj",
                        "lipanj",
                        "srpanj",
                        "kolovoz",
                        "rujan",
                        "listopad",
                        "studeni",
                        "prosinac",
                        ""
                    ],
                    "FirstDayOfWeek": 1,
                    "LongDatePattern": "d. MMMM yyyy.",
                    "LongTimePattern": "H:mm:ss",
                    "MonthDayPattern": "d. MMMM",
                    "ShortDatePattern": "d.M.yyyy.",
                    "ShortTimePattern": "H:mm",
                    "GeneralLongTimePattern": "d.M.yyyy. H:mm:ss",
                    "GeneralShortTimePattern": "d.M.yyyy. H:mm"
                },
                "NumberFormat": {
                    "CurrencySymbol": "kn",
                    "NumberDecimalSeparator": ",",
                    "NumberGroupSeparator": ".",
                    "PerMilleSymbol": "‰",
                    "PercentSymbol": "%",
                    "CurrencyPositivePattern": 3,
                    "CurrencyPositivePatternString": "{Value} {CurrencySymbol}"
                },
                "Region": {
                    "CurrencyEnglishName": "Croatian Kuna",
                    "CurrencyNativeName": "hrvatska kuna",
                    "CurrencySymbol": "kn",
                    "DisplayName": "Croatia",
                    "EnglishName": "Croatia",
                    "IsMetric": true,
                    "ISOCurrencySymbol": "HRK",
                    "Name": "HR",
                    "NativeName": "Hrvatska",
                    "ThreeLetterISORegionName": "HRV",
                    "ThreeLetterWindowsRegionName": "HRV",
                    "TwoLetterISORegionName": "HR"
                }
            }
        };
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        var CalystoDomAttributes;
        (function (CalystoDomAttributes) {
            CalystoDomAttributes.CalystoId = `calysto-id`;
            CalystoDomAttributes.CalystoValidatorMsgFor = `calysto-validator-msg-for`;
            CalystoDomAttributes.CalystoSummaryMsgFor = `calysto-summary-msg-for`;
            CalystoDomAttributes.CalystoErrorMsgFor = `calysto-error-msg-for`;
            CalystoDomAttributes.CalystoType = `calysto-type`;
            CalystoDomAttributes.CalystoGetter = `calysto-getter`;
            CalystoDomAttributes.CalystoSetter = `calysto-setter`;
            CalystoDomAttributes.CalystoFormat = `calysto-format`;
            CalystoDomAttributes.CalystoValidationFn = `calysto-validation-fn`;
            CalystoDomAttributes.CalystoBind = `calysto-bind`;
            CalystoDomAttributes.CalystoBindEvents = `calysto-bind-events`;
            CalystoDomAttributes.CalystoListen = `calysto-listen`;
            CalystoDomAttributes.CalystoUid = `calysto-uid`;
            CalystoDomAttributes.CalystoIsRepeater = `calysto-isrepeater`;
            CalystoDomAttributes.CalystoIsGroup = `calysto-isgroup`;
            CalystoDomAttributes.CalystoGetConvert = `calysto-getconvert`;
            CalystoDomAttributes.CalystoSetConvert = `calysto-setconvert`;
            CalystoDomAttributes.CalystoFormTarget = `calysto-form-target`;
            CalystoDomAttributes.CalystoFormHandler = `calysto-form-handler`;
            CalystoDomAttributes.CalystoFormMode = `calysto-form-mode`;
            CalystoDomAttributes.CalystoFormDestination = `calysto-form-dest`;
            CalystoDomAttributes.CalystoAppendVersion = `calysto-append-version`;
            CalystoDomAttributes.CalystoSpinnerDelay = `calysto-spinner-delay`;
            CalystoDomAttributes.CalystoTimeout = `calysto-timeout`;
            CalystoDomAttributes.CalystoControllerAction = `calysto-controller-action`;
            CalystoDomAttributes.CalystoScriptRun = `calysto-script-run`;
        })(CalystoDomAttributes = Constants.CalystoDomAttributes || (Constants.CalystoDomAttributes = {}));
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        var CalystoAjaxHandlerConstants;
        (function (CalystoAjaxHandlerConstants) {
            CalystoAjaxHandlerConstants.HandlerPath = `calysto-hndlaxd`;
            CalystoAjaxHandlerConstants.ScriptResourceRequest = `calysto-sclisx`;
            CalystoAjaxHandlerConstants.ElmahRequest = `calysto-exiaqn`;
            CalystoAjaxHandlerConstants.TypeServiceRequest = `calysto-tmoynd`;
            CalystoAjaxHandlerConstants.AjaxGetParamName = `calysto-ghqiu`;
        })(CalystoAjaxHandlerConstants = Constants.CalystoAjaxHandlerConstants || (Constants.CalystoAjaxHandlerConstants = {}));
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Constants;
    (function (Constants) {
        var BaseXCharsTable;
        (function (BaseXCharsTable) {
            BaseXCharsTable.RandomRFCTable64 = `csIYaqGWdtJZ6mCS2iyO7nDT0gwM-1hxNeuK_brHX9pFV3jzP8oEUfvL!5lBR4kAQ`;
            BaseXCharsTable.StandardBase64RFC = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=`;
            BaseXCharsTable.JavaScriptRFCTable64 = `0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_!-`;
            BaseXCharsTable.Table36JavaScriptRFC = `0123456789abcdefghijklmnopqrstuvwxyz`;
        })(BaseXCharsTable = Constants.BaseXCharsTable || (Constants.BaseXCharsTable = {}));
    })(Constants = Calysto.Constants || (Calysto.Constants = {}));
})(Calysto || (Calysto = {}));
/**
 * This is start file. It has no other references.
 * Next files should be resx files where this file has to be referenced at top.
 */
var Calysto;
(function (Calysto) {
    var Globalization;
    (function (Globalization) {
        class ResxExcelProvider {
            /// <summary>
            /// {Key: propertyName, Value: string[]}
            /// </summary>
            get DataRows() { var _a; return (_a = this._dataRows) !== null && _a !== void 0 ? _a : (this._dataRows = this.Table.Rows.AsEnumerable().ToDictionary(o => o[0])); }
            GetDefaultSearchColumns() {
                return null;
            }
            GetSearchColumns(searchColumnsOrder) {
                if (typeof searchColumnsOrder == "string") {
                    // use exact column, but convert to []
                    return [searchColumnsOrder];
                }
                else if (searchColumnsOrder) {
                    // it is enumerable
                    return searchColumnsOrder;
                }
                if (this.GetDefaultSearchColumns) {
                    let defaultCols = this.GetDefaultSearchColumns();
                    if (defaultCols)
                        return defaultCols;
                }
                // use current culture, if value doesn't exists, than select from first column, it is default value.
                let curr1 = Calysto.Globalization.CultureInfo.CurrentCulture.Name;
                searchColumnsOrder = [this.Table.Columns[1]]; // take column at 1, 0 is property name
                // test if curr1 column exists, this way we prevent reporting and exception if current culture name doesn't exist as column
                // and move to default column
                // will take first non-empty cell value, searching columns in specified order
                if (this.Table.Columns.Contains(curr1))
                    searchColumnsOrder.unshift(curr1);
                return searchColumnsOrder;
            }
            static FromJson(json) {
                let provider = new ResxExcelProvider();
                provider.Table = json;
                return provider;
            }
            GetString(propertyName, searchColumnsOrder) {
                let item1 = this.DataRows.GetValueOrDefault(propertyName);
                let cols1 = this.GetSearchColumns(searchColumnsOrder);
                if (item1 && cols1) {
                    for (let col1 of cols1) {
                        let index1 = this.Table.Columns.indexOf(col1);
                        if (index1 < 0)
                            throw Error(`Resx column ${col1} doesn't exist.`);
                        let item2 = item1[index1];
                        if (!!item2) // if not empty value
                            return item2;
                    }
                    throw Error(`Resx property ${propertyName} with cell ${(cols1.join(" | "))} not found.`);
                }
                throw Error(`Resx property ${propertyName} not found.`);
            }
        }
        Globalization.ResxExcelProvider = ResxExcelProvider;
    })(Globalization = Calysto.Globalization || (Calysto.Globalization = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Resources;
    (function (Resources) {
        const _columns = ["property", "en-US", "hr-HR"];
        const _json = { "__calystotype": "Calysto_DataTable", "TotalCount": null, "TableName": "", "Columns": ["property", "en-US", "hr-HR"], "Rows": [["Cancel", "Cancel", "Otkaži"], ["Close", "Close", "Zatvori"], ["Day", "Day", "Dan"], ["Error", "Error", "Greška"], ["Information", "Information", "Informacija"], ["JavascriptEngineIsOutdatedInformation", "Javascript engine is outdated.\r\nClick:\r\n    - Reload to reload page and new engine\r\n    - Cancel to keep the current page", "Pronađena je novija verzija stranice.\nKliknite:\n    - Osvježi za osvježavanje i dohvat nove verzije\n    - Otkaži za zadržavanje na trenutnoj verziji"], ["Message", "Message", "Poruka"], ["Month", "Month", "Mjesec"], ["NewVersionFoundPageIsReloading", "New version found, page is reloading...", "Pronađena je novija verzija, stranica se osvježava..."], ["No", "No", "Ne"], ["OK", "OK", "U redu"], ["Open", "Open", "Otvori"], ["PageIsReloadingPleaseWait", "Please wait, page is reloading...", "Molimo pričekajte, stranica se osvježava..."], ["PleaseConfirm", "Please confirm", "Molimo potvrdite"], ["Question", "Question", "Pitanje"], ["Reload", "Reload", "Osvježi"], ["Save", "Save", "Spremi"], ["Success", "Success", "Uspješno"], ["Today", "Today", "Danas"], ["Warning", "Warning", "Upozorenje"], ["Week", "Week", "Tjedan"], ["Year", "Year", "Godina"], ["Yes", "Yes", "Da"], ["MethodInvocationFobidden", "Invocation forbidden", "Nemate dozvolu za ovu akciju"]] };
        class CalystoLang {
            /** Cancel */
            static get Cancel() { return CalystoLang.ResourceProvider.GetString("Cancel"); }
            /** Close */
            static get Close() { return CalystoLang.ResourceProvider.GetString("Close"); }
            /** Day */
            static get Day() { return CalystoLang.ResourceProvider.GetString("Day"); }
            /** Error */
            static get Error() { return CalystoLang.ResourceProvider.GetString("Error"); }
            /** Information */
            static get Information() { return CalystoLang.ResourceProvider.GetString("Information"); }
            /** Javascript engine is outdated.
    Click:
    - Reload to reload page and new engine
    - Cancel to keep the current page */
            static get JavascriptEngineIsOutdatedInformation() { return CalystoLang.ResourceProvider.GetString("JavascriptEngineIsOutdatedInformation"); }
            /** Message */
            static get Message() { return CalystoLang.ResourceProvider.GetString("Message"); }
            /** Invocation forbidden */
            static get MethodInvocationFobidden() { return CalystoLang.ResourceProvider.GetString("MethodInvocationFobidden"); }
            /** Month */
            static get Month() { return CalystoLang.ResourceProvider.GetString("Month"); }
            /** New version found, page is reloading... */
            static get NewVersionFoundPageIsReloading() { return CalystoLang.ResourceProvider.GetString("NewVersionFoundPageIsReloading"); }
            /** No */
            static get No() { return CalystoLang.ResourceProvider.GetString("No"); }
            /** OK */
            static get OK() { return CalystoLang.ResourceProvider.GetString("OK"); }
            /** Open */
            static get Open() { return CalystoLang.ResourceProvider.GetString("Open"); }
            /** Please wait, page is reloading... */
            static get PageIsReloadingPleaseWait() { return CalystoLang.ResourceProvider.GetString("PageIsReloadingPleaseWait"); }
            /** Please confirm */
            static get PleaseConfirm() { return CalystoLang.ResourceProvider.GetString("PleaseConfirm"); }
            /** Question */
            static get Question() { return CalystoLang.ResourceProvider.GetString("Question"); }
            /** Reload */
            static get Reload() { return CalystoLang.ResourceProvider.GetString("Reload"); }
            /** Save */
            static get Save() { return CalystoLang.ResourceProvider.GetString("Save"); }
            /** Success */
            static get Success() { return CalystoLang.ResourceProvider.GetString("Success"); }
            /** Today */
            static get Today() { return CalystoLang.ResourceProvider.GetString("Today"); }
            /** Warning */
            static get Warning() { return CalystoLang.ResourceProvider.GetString("Warning"); }
            /** Week */
            static get Week() { return CalystoLang.ResourceProvider.GetString("Week"); }
            /** Year */
            static get Year() { return CalystoLang.ResourceProvider.GetString("Year"); }
            /** Yes */
            static get Yes() { return CalystoLang.ResourceProvider.GetString("Yes"); }
        }
        CalystoLang.ResourceProvider = Calysto.Globalization.ResxExcelProvider.FromJson(_json);
        Resources.CalystoLang = CalystoLang;
    })(Resources = Calysto.Resources || (Calysto.Resources = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    let DataBinder;
    (function (DataBinder) {
        var reNum = new RegExp("^[\\d]+$");
        var reRoot = new RegExp("^[\\@]+[\\.]*"); // @.prop1.prop2 or @prop1.prop2
        var RecursionLimit = 100;
        function RemoveRoot(prop) {
            return (prop || "").replace(reRoot, "");
        }
        function SplitToParts(prop) {
            return RemoveRoot(prop + "").Split(['.', '[', ']']);
        }
        function TryGetValue(dataObj, dataProperty, refOut) {
            /// <summary>
            /// Try to get value from dataObj. Returns true if property exist and it's value is pushed into refOutArray. Any other case, returns false and empty refOutArray.
            /// </summary>
            /// <param name="dataObj">object with properties or array</param>
            /// <param name="dataProperty" type="String|Integer">case sensitive full path property name, eg. style.color, or index if object is array, eg. style.color.3.name, where number 3 is index in array</param>
            /// <param name="refOutArray" type="Array"></param>
            if (!dataObj || !refOut || arguments.length != 3) {
                // dataProperty may be "", it is used in Calysto.Observable, eg. calysto-bind="repeater:DataItem", TryGetValue has to return dataObj itself
                throw new Error("Calysto.DataBinder.TryGetValue() requires 3 arguments");
                //return false;
            }
            var cnt = 0;
            var arr = SplitToParts(dataProperty);
            var val = dataObj;
            var prop;
            while (arr.length > 0 && (prop = arr.shift())) // will ignore empty prop, eg. Player.Playing. when splited, last value is "", and has to be ignored
             {
                if (cnt++ > RecursionLimit) {
                    throw new Error("Calysto.DataBinder.TryGetValue() recursion limit");
                    //return false;
                }
                let isIndex = false;
                if (reNum.test(prop)) {
                    prop = parseInt(prop, 10); // if it is number, use index as property
                    isIndex = true;
                }
                // just to speed up
                if (val == null || val == undefined) {
                    return false;
                }
                try {
                    if (isIndex && Calysto.Collections.HasInnerArray(val)) {
                        val = Calysto.Collections.GetInnerArray(val)[prop];
                    }
                    else if (!(prop in val)) {
                        return false;
                    }
                    else {
                        val = val[prop];
                    }
                }
                catch (e) {
                    return false;
                }
            }
            refOut.SetValue(val);
            return true;
        }
        DataBinder.TryGetValue = TryGetValue;
        ;
        function GetValue(dataObj, dataProperty) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="dataObj">object with properties or array</param>
            /// <param name="dataProperty" type="String|Integer">case sensitive full path property name, eg. style.color, or index if object is array, eg. style.color.3.name, where number 3 is index in array</param>
            if (arguments.length < 2) {
                throw new Error("Calysto.DataBinder.GetValue() requires 2 arguments");
            }
            var refOut = new Calysto.BoxValue();
            TryGetValue(dataObj, dataProperty, refOut);
            return refOut.GetValue();
        }
        DataBinder.GetValue = GetValue;
        ;
        function SetValue(dataObj, dataProperty, value) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="dataObj"></param>
            /// <param name="dataProperty" type="String|Integer">case sensitive full path property name, eg. style.color.3.name, where number 3 is index in array style.color</param>
            /// <param name="value">new value</param>
            if (!dataObj || !dataProperty || arguments.length < 3) {
                throw new Error("Calysto.DataBinder.SetValue() requires 3 arguments");
            }
            var cnt = 0;
            var arr = SplitToParts(dataProperty);
            var prop;
            var obj = dataObj;
            var tmp = obj;
            while (arr.length > 0 && (prop = arr.shift())) // will ignore empty prop
             {
                if (cnt++ > RecursionLimit) {
                    throw new Error("Calysto.DataBinder.SetValue() recursion limit");
                }
                let isIndex = false;
                if (reNum.test(prop)) {
                    prop = parseInt(prop, 10); // if it is number, use index as property
                    isIndex = true;
                }
                if (arr.length > 0) {
                    if (isIndex && Calysto.Collections.HasInnerArray(obj)) {
                        tmp = Calysto.Collections.GetInnerArray(obj)[prop];
                    }
                    else {
                        tmp = obj[prop];
                    }
                    if (!tmp) {
                        // not last property, but datacontext has no object, create new object {}
                        // this feature is used at imagine player
                        obj = obj[prop] = {};
                    }
                    else {
                        obj = tmp;
                    }
                }
                else if (isIndex && Calysto.Collections.HasInnerArray(obj)) {
                    Calysto.Collections.GetInnerArray(obj)[prop] = value;
                }
                else {
                    // last property, assing value
                    obj[prop] = value;
                }
            }
        }
        DataBinder.SetValue = SetValue;
        ;
    })(DataBinder = Calysto.DataBinder || (Calysto.DataBinder = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Globalization;
    (function (Globalization) {
        class DateTimeFormat {
            constructor() {
                this.ShortestDayNames = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
                this.AbbreviatedDayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                this.DayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                this.AbbreviatedMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""];
                this.MonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""];
                this.LongDatePattern = "dddd, MMMM d, yyyy";
                this.LongTimePattern = "h:mm:ss tt";
                this.MonthDayPattern = "MMMM d";
                this.ShortDatePattern = "M/d/yyyy";
                this.ShortTimePattern = "h:mm tt";
                this.GeneralLongTimePattern = "M/d/yyyy h:mm:ss tt";
                this.GeneralShortTimePattern = "M/d/yyyy h:mm tt";
            }
        }
        class NumberFormat {
            constructor() {
                this.CurrencySymbol = "$";
                this.NumberDecimalSeparator = ".";
                this.NumberGroupSeparator = ",";
                this.PerMilleSymbol = "‰";
                this.PercentSymbol = "%";
                this.CurrencyPositivePattern = 0;
                this.CurrencyPositivePatternString = "{CurrencySymbol}{Value}";
            }
        }
        class Region {
            constructor() {
                this.CurrencyEnglishName = "US Dollar";
                this.CurrencyNativeName = "US Dollar";
                this.CurrencySymbol = "$";
                this.DisplayName = "United States";
                this.EnglishName = "United States";
                this.IsMetric = false;
                this.ISOCurrencySymbol = "USD";
                this.Name = "en-US";
                this.NativeName = "United States";
                this.ThreeLetterISORegionName = "USA";
                this.ThreeLetterWindowsRegionName = "USA";
                this.TwoLetterISORegionName = "US";
            }
        }
        let _currentCulture;
        function GetPredefinedCultures() {
            return Calysto.Constants.PredefinedCultures;
        }
        class CultureInfo {
            constructor() {
                this.Name = "en-US";
                this.NativeName = "English (United States)";
                this.DisplayName = "English (United States)";
                this.EnglishName = "English (United States)";
                this.ThreeLetterISOLanguageName = "eng";
                this.ThreeLetterWindowsLanguageName = "ENU";
                this.TwoLetterISOLanguageName = "en";
                this.DateTimeFormat = new DateTimeFormat();
                this.NumberFormat = new NumberFormat();
                this.Region = new Region();
            }
            static get Cultures() { return GetPredefinedCultures(); }
            static get USCulture() { return GetPredefinedCultures()["en-US"]; }
            static get HRCulture() { return GetPredefinedCultures()["hr-HR"]; }
            /** get current culture */
            static get CurrentCulture() {
                return _currentCulture || Calysto.Core.Constants.CurrentCulture || CultureInfo.USCulture;
            }
            /** set new current culture */
            static set CurrentCulture(culture) {
                if (culture && culture.Name && (CultureInfo === null || CultureInfo === void 0 ? void 0 : CultureInfo.Cultures[culture.Name]))
                    _currentCulture = culture;
                else
                    throw Error("Invalid culture provided.");
            }
        }
        Globalization.CultureInfo = CultureInfo;
    })(Globalization = Calysto.Globalization || (Calysto.Globalization = {}));
})(Calysto || (Calysto = {}));
/// <reference path="../Globalization/Globalization.ts" />
/// <reference path="calystointerfaces.d.ts" />
/// <reference path="calystodeclarations.d.ts" />
/// <reference path="databinder.ts" />
/// <reference path="d.ts/iruntimeconstants.ts" />
var Calysto;
(function (Calysto) {
    class Core {
        static get Constants() { return __calystoeueinhywsx || {}; }
        static get IsDebugDefined() { return Calysto.Core.Constants.IsDebugDefined; }
        static get IsLocallyHosted() { return Calysto.Core.Constants.IsLocallyHosted; }
        static get IsTddSpecific() { return Calysto.Core.Constants.IsTddSpecific; }
        /**
         * Register namespace in window object.
         * @param path
         */
        static RegisterGlobalNs(path) {
            Calysto.DataBinder.SetValue(window, path, {});
        }
        /**
         * Register obj to window as window[path] = object;
         * If path not provided, and obj is function, will use obj[name] as path
         * @param obj
         * @param path If not set, will use function.name. If can not resolve name, will throw exception.
         * @param mayOverwrite If namespace already exists:
         *		if true, will overwrite existing object in namespace
         *		else, will throw exception
         */
        static ExportGlobal(obj, path, mayOverwrite) {
            if (!path && typeof obj == "function") {
                path = obj["name"];
                if (!path) {
                    // older browsers:
                    // lambda functions can't be resolved for older browsers
                    // standard functions converted to string gives function fnname(args){...}
                    let str1 = obj + ""; // gives: function fnname(){}
                    let match1 = str1.match("function[\\s]+([^\\(\\)]+)");
                    if (match1)
                        path = match1[1];
                }
            }
            if (!path)
                throw new Error("ExportGlobal error: path can not be empty.");
            if (!mayOverwrite && Calysto.DataBinder.GetValue(window, path))
                throw new Error("ExportGlobal error: path \"" + path + "\" aready exists in window.");
            else
                Calysto.DataBinder.SetValue(window, path, obj);
        }
    }
    Calysto.Core = Core;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    Calysto.AttrName = Calysto.Constants.CalystoDomAttributes;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class BoxValue {
        constructor() {
        }
        SetValue(value) {
            this._value = value;
            this._hasValue = true;
        }
        GetValue() {
            return this._value;
        }
        GetValueOrDefault(defaultValue) {
            return this.HasValue() ? this.GetValue() : defaultValue;
        }
        HasValue() {
            return !!this._hasValue;
        }
        RemoveValue() {
            this._value = undefined;
            this._hasValue = false;
        }
    }
    Calysto.BoxValue = BoxValue;
    class BoxValueObservable extends BoxValue {
        constructor() {
            super();
            /**
             * Promisle like. If value is already set, will invoke callback delegate immediately.
            */
            this.OnSetValue = new Calysto.MulticastDelegate().OnAdd(f => {
                if (this.HasValue())
                    f(this.GetValue()); // if value is already set, invoke callback now
            }).AsFunc(this);
        }
        /**
         * Set value, than invoke OnSetValue()
         * @param value
         */
        SetValue(value) {
            this._value = value;
            this._hasValue = true;
            this.OnSetValue.Invoke(f => f(value));
        }
    }
    Calysto.BoxValueObservable = BoxValueObservable;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Generators;
        (function (Generators) {
            const _smallLetters = "abcdefghijklmnopqrstuvwxyz";
            const _capitalLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const _nums = "0123456789";
            const _special = "!@#$%^&*()_+=-~/\][><.,?>:;'\}{";
            function GetRndCharsFromTable(table, finalLength) {
                if (!(finalLength > 0))
                    throw new Error("Invalid finalLength in Calysto.Utility.Generators.GetRndCharsFromTable(...)");
                let tlen = table.length;
                if (!(tlen > 0))
                    throw new Error("Invalid tlen in Calysto.Utility.Generators.GetRndCharsFromTable(...)");
                let arr = [];
                while (tlen > 0 && arr.length < finalLength) {
                    arr.push(table.charAt(Math.floor(Math.random() * tlen)));
                }
                return arr.join("");
            }
            function GetRndChars(finalLength, letterFirst = true, smallLetters = true, capitalLetters = true, numbers = true, specialChars = true) {
                let arr = [];
                let table = "";
                if (letterFirst)
                    arr.push(GetRndCharsFromTable(_smallLetters + _capitalLetters, 1));
                if (smallLetters)
                    table += _smallLetters;
                if (capitalLetters)
                    table += _capitalLetters;
                if (numbers)
                    table += _nums;
                if (specialChars)
                    table += _special;
                arr.push(GetRndCharsFromTable(table, finalLength));
                return arr.join("");
            }
            /**
            * Generate alpha-numeric password.
            * Always starts with letter.
            * Contains lowercased letters, uppercased letters, and digits, may be used as label of element name.
            * @param length
            */
            function GeneratePassword(length) {
                return GetRndChars(length, true, true, true, true, false);
            }
            Generators.GeneratePassword = GeneratePassword;
            /**
            * Generate new strong random password.
            * Contains lowercased letters, uppercased letters, digits and special chars.
            * @param length
            */
            function GenerateStrongPassword(length) {
                return GetRndChars(length, true, true, true, true, true);
            }
            Generators.GenerateStrongPassword = GenerateStrongPassword;
            /**
             * Generate new numeric password.
             * @param length
             */
            function GenerateNumericPassword(length) {
                return GetRndCharsFromTable(_nums, length);
            }
            Generators.GenerateNumericPassword = GenerateNumericPassword;
            /**
            * Generate alpha-numeric label.
            * Always starts with letter.
            * Contains lowercased letters, uppercased letters, and digits, may be used as label of element name.
            * @param length
            */
            function GenerateLabel(length) {
                return GetRndChars(length, true, true, true, true, false);
            }
            Generators.GenerateLabel = GenerateLabel;
        })(Generators = Utility.Generators || (Utility.Generators = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var ArraySorter;
    (function (ArraySorter) {
        let SortTypeEnum;
        (function (SortTypeEnum) {
            SortTypeEnum[SortTypeEnum["Undefined"] = 1] = "Undefined";
            SortTypeEnum[SortTypeEnum["Null"] = 2] = "Null";
            SortTypeEnum[SortTypeEnum["NaN"] = 3] = "NaN";
            SortTypeEnum[SortTypeEnum["Boolean"] = 4] = "Boolean";
            SortTypeEnum[SortTypeEnum["Number"] = 5] = "Number";
            SortTypeEnum[SortTypeEnum["Date"] = 6] = "Date";
            SortTypeEnum[SortTypeEnum["String"] = 7] = "String";
            SortTypeEnum[SortTypeEnum["Object"] = 8] = "Object";
        })(SortTypeEnum || (SortTypeEnum = {}));
        function GetKeyValue(item, keySelector) {
            if (!keySelector)
                return item;
            return keySelector(item);
        }
        function SortArray(arr, keySelector, descending) {
            var arr1 = arr
                .Select(item => ({
                item: item,
                sortKey: GetKeyValue(item, keySelector),
                typeNum: 0,
                typeStr: "notset"
            }))
                .Select(m => {
                let key = m.sortKey;
                var sortType;
                if (key === undefined)
                    sortType = SortTypeEnum.Undefined;
                else if (key === null)
                    sortType = SortTypeEnum.Null;
                else if (key["constructor"] == Date)
                    sortType = SortTypeEnum.Date;
                else {
                    switch (typeof (key)) {
                        case "string":
                            sortType = SortTypeEnum.String;
                            break;
                        case "number":
                            if (isNaN(key))
                                sortType = SortTypeEnum.NaN;
                            else
                                sortType = SortTypeEnum.Number;
                            break;
                        case "boolean":
                            sortType = SortTypeEnum.Boolean;
                            break;
                        default:
                            sortType = SortTypeEnum.Object;
                            break;
                    }
                }
                m.typeNum = sortType;
                m.typeStr = sortType + "";
                return m;
            });
            var groupsArr = [];
            var groupsDic = {};
            arr1.ForEach(m => {
                let group = groupsDic[m.typeStr];
                if (!group) {
                    groupsDic[m.typeStr] = group = [];
                    group.typeNum = m.typeNum;
                    groupsArr.push(group);
                }
                group.push(m);
            });
            // warning: sort function must work exactly like this:
            // return x < y ? -1 : x > y ? 1 : 0; // tested, this is especially important for Edge and IE
            // return x < y ? -1 : 1; // doesn't work well
            // first numeric sort groups by it's typeNum
            groupsArr.sort((a, b) => a.typeNum < b.typeNum ? -1 : a.typeNum > b.typeNum ? 1 : 0); // 1 means swap values
            // then sort inside each group
            groupsArr.ForEach(g => g.sort((a, b) => a.sortKey < b.sortKey ? -1 : a.sortKey > b.sortKey ? 1 : 0)); // 1 means swap values
            // expand results
            var final = [];
            groupsArr.ForEach(g => g.ForEach(m => final.push(m.item)));
            if (descending)
                final.reverse();
            return final;
        }
        ArraySorter.SortArray = SortArray;
    })(ArraySorter = Calysto.ArraySorter || (Calysto.ArraySorter = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Enum;
    (function (Enum) {
        /**
         * Get numeric value.
         * @param {TEnum} objEnum
         * @param {string} name
         * @returns
         */
        function GetValue(objEnum, name) {
            var val = objEnum[name];
            if (Calysto.Type.TypeInspector.IsNumber(val))
                return val;
            throw new Error("enum name not found: " + name);
        }
        Enum.GetValue = GetValue;
        /**
         * Get values as number[]
         * @param {TEnum} objEnum
         * @returns
         */
        function GetValues(objEnum) {
            var arr = [];
            Calysto.Collections.ForEachOwnProperties(objEnum, (name, value, index) => {
                if (typeof (value) == "number")
                    arr.push(value);
            });
            return arr;
        }
        Enum.GetValues = GetValues;
        /**
         * Test if numeric value exists in enum.
         * @param {TEnum} objEnum
         * @param {number} value
         * @returns
         */
        function HasValue(objEnum, value) {
            var val = objEnum[value];
            if (Calysto.Type.TypeInspector.IsString(val))
                return true;
            return false;
        }
        Enum.HasValue = HasValue;
        /**
         * Test if name exists in enum.
         * @param {TEnum} objEnum
         * @param {string} name
         * @returns
         */
        function HasName(objEnum, name) {
            var val = objEnum[name];
            if (Calysto.Type.TypeInspector.IsNumber(val))
                return true;
            return false;
        }
        Enum.HasName = HasName;
        /**
         * Get name as string from it's numeric value.
         * @param {TEnum} objEnum
         * @param {number} value
         * @returns
         */
        function GetName(objEnum, value) {
            var val = objEnum[value];
            if (Calysto.Type.TypeInspector.IsString(val))
                return val;
            throw new Error("enum value not found: " + value);
        }
        Enum.GetName = GetName;
        /**
         * Get names as string[].
         * @param {TEnum} objEnum
         * @returns
         */
        function GetNames(objEnum) {
            var arr = [];
            Calysto.Collections.ForEachOwnProperties(objEnum, (name, value, index) => {
                if (typeof (value) == "string")
                    arr.push(value);
            });
            return arr;
        }
        Enum.GetNames = GetNames;
    })(Enum = Calysto.Enum || (Calysto.Enum = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class CalystoEnumerable {
        constructor(getEnumerator) {
            if (typeof getEnumerator != "function")
                throw new Error("GetEnumerator is not function");
            this._getEnumerator = getEnumerator;
        }
        GetEnumerator() {
            if (this._getEnumerator)
                return this._getEnumerator();
            else
                throw new Error("GetEnumerator is not defined");
        }
        AsEnumerable() {
            return this;
        }
        AsIterableIterator() {
            let context1 = this;
            let box1 = new Calysto.BoxValue();
            let aa = function* () {
                let en1 = context1.GetEnumerator();
                while (en1.YieldNext(box1)) {
                    yield en1.Current;
                }
            };
            return aa();
        }
        ToArray() {
            var arr = [];
            var en1 = this.GetEnumerator();
            var refOut = new Calysto.BoxValue();
            while (en1.YieldNext(refOut) && refOut.HasValue()) {
                arr.push(refOut.GetValue());
                refOut.RemoveValue();
            }
            return arr;
        }
        /**
         * create new DOM enumerable query without converting to array first
         * @returns
         */
        AsDomQuery() {
            return new Calysto.DomQuery(() => this.GetEnumerator());
        }
        ToList() {
            return new Calysto.List(this.ToArray());
        }
        //public ToArrayList(): ArrayList<TItem>
        //{
        //	return new ArrayList(this.ToArray());
        //}
        Count() {
            return this.ToArray().length;
        }
        ToDictionary(keySelector, valueSelector) {
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            if (typeof valueSelector != "function")
                valueSelector = Calysto.Utility.Expressions.CompileLambdaExpression(valueSelector);
            var dic2 = new Calysto.Dictionary();
            this.ForEach((item, index) => dic2.Add(keySelector(item), valueSelector(item)));
            return dic2;
        }
        ToRawObject(keySelector, valueSelector) {
            /// <summary>
            /// Create {key: value, key1: value1}... If keys are not unique, will be overwriten.
            /// </summary>
            /// <param name="keySelector" type="Function|Lambda">function(item, index){....}</param>
            /// <param name="valueSelector" optional="true" type="Function|Lambda">function(item, index){...}</param>
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            if (typeof valueSelector != "function")
                valueSelector = Calysto.Utility.Expressions.CompileLambdaExpression(valueSelector);
            var dic = {};
            // key has to be string, e.g. for(var prop in {}), prop is string
            // dic[1] = "test"; dic[1] returns "test", but dic["1"] returns test too, which means than key is converted into string by the JS itselft
            this.ForEach((item, index) => dic[keySelector(item) + ""] = valueSelector(item));
            return dic;
        }
        ToStringJoined(separator) {
            var arr = this.ToArray();
            return arr.join(separator || "");
        }
        /**
         * Run foreach and return new enumerable
         * @param action
         */
        ForEach(action) {
            if (typeof (action) == "string")
                action = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(action);
            var arr = this.ToArray();
            for (var n = 0; n < arr.length; n++) {
                action(arr[n], n);
            }
            return CalystoEnumerable.From(arr);
        }
        Skip(count) {
            return CalystoEnumerable.From(() => function* (__this) {
                let currindex = -1;
                for (let item of __this.AsIterableIterator()) {
                    if (++currindex < count)
                        continue;
                    else
                        yield item;
                }
            }(this));
        }
        Take(count) {
            return CalystoEnumerable.From(() => function* (__this) {
                let currindex = -1;
                for (let item of __this.AsIterableIterator()) {
                    if (++currindex < count)
                        yield item;
                    else
                        break;
                }
            }(this));
        }
        Single() {
            var el = this.Take(2).ToArray();
            if (el.length == 1) {
                return el[0];
            }
            else if (el.length == 0) {
                throw new Error("Error in .Single(), sequence contains no elements");
            }
            else {
                throw new Error("Error in .Single(), sequence contains more than single element");
            }
        }
        ;
        Exact(count) {
            /// <summary>
            /// Take exact count. If there is more or less items in source, throw exception.
            /// </summary>
            /// <param name="count" type="Int"></param>
            if (!(count >= 0)) {
                throw new Error("Exact(count) requires count parameter >= 0");
            }
            var arr = this.ToArray();
            if (arr.length != count) {
                throw new Error("Error in .Exact(), sequence contains " + arr.length + " elements. Required is " + count + " elements.");
            }
            return CalystoEnumerable.From(arr);
        }
        Sum(selector) {
            /// <summary>
            /// Computes the sum of numeric values the sequence.
            /// </summary>
            /// <param name="selector" optional="true">lambda selector</param>
            /// <returns type="Number|Null"></returns>
            var val = null;
            this.Select(selector || ((o) => o)).ForEach((o, n) => {
                if (Calysto.Type.TypeInspector.IsNumber(o)) {
                    val = (val || 0) + o;
                }
            });
            return val;
        }
        ;
        Average(selector) {
            /// <summary>
            /// Computes average of non-null numeric values of the sequence: sum / count, count of numeric non-null values only.
            /// </summary>
            /// <param name="selector" optional="true">lambda selector</param>
            /// <returns type="Number|Null"></returns>
            var val = null;
            var count = 0;
            this.Select(selector || ((o) => o)).ForEach((o, n) => {
                if (Calysto.Type.TypeInspector.IsNumber(o)) {
                    val = (val || 0) + o;
                    count++;
                }
            });
            return count > 0 ? (val / count) : 0;
        }
        Min(selector) {
            /// <summary>Returns min value or null.</summary>
            /// <returns type="Object"></returns>
            var val = null;
            this.Select(selector || ((o) => o)).ForEach((o, n) => {
                if (Calysto.Type.TypeInspector.IsNumber(o) || Calysto.Type.TypeInspector.IsDate(o)) {
                    if (val == null || o < val) {
                        val = o;
                    }
                }
            });
            return val;
        }
        Max(selector) {
            /// <summary>Returns max value or null.</summary>
            /// <returns type="Object"></returns>
            var val = null;
            this.Select(selector || ((o) => o)).ForEach((o, n) => {
                if (Calysto.Type.TypeInspector.IsNumber(o) || Calysto.Type.TypeInspector.IsDate(o)) {
                    if (val == null || o > val) {
                        val = o;
                    }
                }
            });
            return val;
        }
        Concat(secondSource) {
            /// <summary>Concatenates two sequences. (Is actually Idendical to the Array.concat method.)</summary>
            /// <param name="soruce2">A Calysto.Linq or Array object that contains the elements to concatenate.</param>
            return CalystoEnumerable.From(() => function* (__this) {
                for (let item of __this.AsIterableIterator())
                    yield item;
                for (let item of secondSource.AsEnumerable().AsIterableIterator())
                    yield item;
            }(this));
        }
        /**
         * Include items from first where predicate(item1, item2){....} returns true
         * @param secondSource
         * @param predicate
         * @param excludeIntersection
         */
        Intersect(secondSource, predicate, excludeIntersection = false) {
            /// <summary>Include items from first where predicate(item1, item2){....} returns true. Returns items from first source if predicate returns true.</summary>
            /// <param name="secondSource">The second Calysto.Linq element or array sequence to perform the Intersect on.</param>
            /// <param name="predicate">comparison function, lambda expression or function (item1, item2)=>....</param>
            /// <param name="excludeIntersection" optional="true">default: false</param>
            if (!secondSource || !predicate) {
                throw new Error("Intersect(secondSource, predicate) requires secondSource and predicate parameters");
            }
            var secondArr = secondSource.ToArray();
            if (typeof predicate == "string")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            // include item1 where exist item1.key == item2.key
            return this.Where(item1 => (!excludeIntersection) == secondArr.Where(item2 => predicate(item1, item2)).Any());
        }
        /**
         * Exclude items from first where predicate(item1, item2){....} returns true
         * @param secondSource
         * @param predicate
         */
        Except(secondSource, predicate) {
            /// <summary>Exclude items from first sequence where predicate(item1, item2){....} returns true. Returns non excluded items from first source.</summary>
            /// <param name="secondSource">The second Calysto.Linq element or array sequence to perform the Intersect on.</param>
            /// <param name="predicate">comparison function, lambda expression or function (item1, item2)=>....</param>
            return this.Intersect(secondSource, predicate, true);
        }
        ;
        /**
         * Join two sequences
         * @param innerSource
         * @param outerKeySelector
         * @param innerKeySelector
         * @param resultSelector
         */
        Join(innerSource, outerKeySelector, innerKeySelector, resultSelector) {
            let innerDic = innerSource.AsEnumerable().ToDictionary(o => innerKeySelector(o));
            return this.Select(outer => {
                let res1 = new Calysto.BoxValue();
                let innerRef = new Calysto.BoxValue();
                if (innerDic.TryGetValue(outerKeySelector(outer), innerRef)) {
                    res1.SetValue(resultSelector(outer, innerRef.GetValue()));
                }
                return res1;
            }).Where(o => o.HasValue()).Select(o => o.GetValue());
        }
        /**
         * Returns elements from a sequence as long as predicate returns true
         * @param predicate
         */
        TakeWhile(predicate) {
            ///<summary>Returns elements from a sequence as long as predicate returns true</summary>
            /// <param name="predicate" type="String|Function">(item)=>... lambda expression or function predicate used to determine query matches.</param>
            if (!predicate)
                throw new Error("TakeWhile(predicate) requires predicate");
            if (typeof predicate != "function")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            return CalystoEnumerable.From(() => function* (__this) {
                let currindex = -1;
                for (let item of __this.AsIterableIterator()) {
                    if (!predicate(item, ++currindex))
                        break;
                    else
                        yield item;
                }
            }(this));
        }
        /**
         * skip elements from a sequence as long as predicate returns true, elements after that are selected
         * @param predicate
         */
        SkipWhile(predicate) {
            ///<summary>skip elements from a sequence as long as predicate returns true, elements after that are selected</summary>
            /// <param name="predicate" type="String|Function">(item)=>... lambda expression or function predicate used to determine query matches.</param>
            if (!predicate)
                throw new Error("SkipWhile(predicate) requires predicate");
            if (typeof predicate != "function")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            return CalystoEnumerable.From(() => function* (__this) {
                let takeRest = false;
                let currindex = -1;
                for (let item of __this.AsIterableIterator()) {
                    if (takeRest)
                        yield item;
                    else if (predicate(item, ++currindex))
                        continue;
                    else {
                        takeRest = true;
                        yield item;
                    }
                }
            }(this));
        }
        Reverse() {
            return new CalystoEnumerable(() => {
                var items = this.ToArray();
                items.reverse(); // in place reverse
                return Calysto.CalystoEnumerator.From(items);
            });
        }
        FirstOrDefault(defaultValue) {
            var arr = this.Take(1).ToArray();
            return arr.length == 1 ? arr.pop() : defaultValue;
        }
        First() {
            var el = this.Take(1).ToArray();
            if (el.length == 1) {
                return el[0];
            }
            else {
                throw new Error("Error in .First(), sequence contains no elements");
            }
        }
        LastOrDefault(defaultValue) {
            var el = this.ToArray();
            return el.length > 0 ? el[el.length - 1] : defaultValue;
        }
        Last() {
            var el = this.ToArray();
            if (el.length > 0) {
                return el[el.length - 1];
            }
            else {
                throw new Error("Error in .Last(), sequence contains no elements");
            }
        }
        Any(predicate) {
            if (typeof predicate != "function")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            predicate = predicate || ((o, n) => true);
            var arr = this.Where(predicate).Take(1).ToArray();
            return arr.length == 1;
        }
        /**
         * Test if predicate returns true for all items in collection.
         * @param predicate
         */
        All(predicate) {
            return !this.Where((o, index) => !predicate(o, index)).Any();
        }
        Where(predicate) {
            if (typeof predicate != "function")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            return CalystoEnumerable.From(() => function* (__this) {
                let index = -1;
                for (let item of __this.AsIterableIterator()) {
                    if (!predicate(item, ++index))
                        continue;
                    else
                        yield item;
                }
            }(this));
        }
        Select(selector) {
            if (typeof selector != "function")
                selector = Calysto.Utility.Expressions.CompileLambdaExpression(selector);
            return CalystoEnumerable.From(() => function* (__this) {
                let index = -1;
                for (let item of __this.AsIterableIterator())
                    yield selector(item, ++index);
            }(this));
        }
        Cast() {
            return this;
        }
        SelectMany(selector) {
            if (typeof selector != "function")
                selector = Calysto.Utility.Expressions.CompileLambdaExpression(selector);
            return CalystoEnumerable.From(() => function* (__this) {
                let sel1 = selector || (x => x);
                for (let item of __this.AsIterableIterator()) {
                    if (!item)
                        continue; // null, e.g. [[1,2,3], null, [3,4,5]]
                    let collection1 = sel1(item);
                    if (!collection1)
                        continue;
                    let enumerable2 = CalystoEnumerable.From(collection1); // item is inner source, e.g. [1,2,3]
                    for (let item2 of enumerable2.AsIterableIterator())
                        yield item2;
                }
            }(this));
        }
        Distinct(keySelector) {
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            return CalystoEnumerable.From(() => function* (__this) {
                let sel1 = keySelector || (x => x);
                let set = new Set();
                for (let item of __this.AsIterableIterator()) {
                    let key = sel1(item);
                    if (!set.has(key)) {
                        set.add(key);
                        yield item;
                    }
                }
            }(this));
        }
        Cycle(take) {
            /// <summary>
            ///  Cycle all elements in current collection to infinity. Must be used Take(x) to limit cycling.
            /// </summary>
            /// <param name="take" type="int" optional="true">OPTIONAL, if specified, takes max 'take' items</param>
            if (!take)
                throw new Error("Cycle requires take parameter");
            return CalystoEnumerable.From(() => function* (__this) {
                let servedItems = 0;
                let abort = false;
                do {
                    // if there is no items in collection, servedItems is 0 as exit condition for while
                    for (let item of __this.AsIterableIterator()) {
                        if (servedItems < take) {
                            yield item;
                            servedItems++;
                        }
                        else {
                            abort = true;
                            break;
                        }
                    }
                } while (!abort && servedItems > 0 && servedItems < take);
            }(this));
        }
        GroupBy(keySelector) {
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            let dic = new Calysto.Dictionary();
            let srcen = this.ToArray();
            for (let item of srcen) {
                let key = keySelector(item);
                let arr;
                if (!dic.ContainsKey(key))
                    dic.Add(key, arr = []);
                else
                    arr = dic.GetValue(key);
                arr.push(item);
            }
            return dic.GetItems().AsEnumerable().Select(o => new CalystoGroupingGroup(o.Key, () => o.Value.AsEnumerable().GetEnumerator()));
        }
        OrderBy(keySelector, descending = false) {
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            let groups = this.GroupBy(keySelector).ToArray();
            var sorted = groups.OrderBy((group) => group.Key, descending);
            return new CalystoOrderedEnumerable(() => sorted.AsEnumerable().GetEnumerator());
        }
        OrderByDescending(keySelector) {
            if (typeof keySelector != "function")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            return this.OrderBy(keySelector, true);
        }
        static From(source) {
            return new CalystoEnumerable(() => Calysto.CalystoEnumerator.From(source));
        }
        static Range(start, count) {
            return CalystoEnumerable.From(function* () {
                let taken = 0;
                while (taken < count) {
                    yield start;
                    start++;
                    taken++;
                }
            });
        }
        static Repeat(item, count) {
            return CalystoEnumerable.From(function* () {
                let taken = 0;
                while (taken < count) {
                    yield item;
                    taken++;
                }
            });
        }
    }
    Calysto.CalystoEnumerable = CalystoEnumerable;
    //#endregion
    //#region Grouping classes
    class CalystoGroupingGroup extends CalystoEnumerable {
        constructor(Key, getEnumerator) {
            super(getEnumerator);
            this.Key = Key;
        }
    }
    class CalystoOrderedEnumerable extends CalystoEnumerable {
        constructor(getGroupsEnumerator) {
            super(() => this.GetFlatEnumerable().GetEnumerator());
            this.getGroupsEnumerator = getGroupsEnumerator;
        }
        GetFlatEnumerable() {
            return this.GetGroupsEnumerable().SelectMany(group => group);
        }
        GetGroupsEnumerable() {
            return new CalystoEnumerable(this.getGroupsEnumerator);
        }
        ThenBy(keySelector, descending = false) {
            let miniGroups = new CalystoEnumerable(this.getGroupsEnumerator).SelectMany(group => {
                return group.OrderBy(keySelector, descending).GetGroupsEnumerable();
            });
            return new CalystoOrderedEnumerable(() => miniGroups.GetEnumerator());
        }
        ThenByDescending(keySelector) {
            return this.ThenBy(keySelector, true);
        }
    }
    //#endregion
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Collections;
    (function (Collections) {
        /**
         * Flattens any kind or argumens and any depth as long as they have length or GetEnumerator. Returns flattened array.
         * @param array
         */
        function SelectFlatten(array1, array2, array3, etc) {
            var arrRes = [];
            for (var n1 = 0; n1 < arguments.length; n1++) {
                var tmpObj = arguments[n1];
                if (tmpObj == undefined) {
                    continue;
                }
                else if (tmpObj["GetEnumerator"] && tmpObj["ToArray"]) {
                    var arr2 = tmpObj.ToArray();
                    for (var n2 = 0; n2 < arr2.length; n2++) {
                        var res2 = SelectFlatten(arr2[n2]);
                        arrRes.AddRange(res2);
                    }
                }
                else if ((tmpObj.tagName && tmpObj.nodeType) || tmpObj.nodeType == Calysto.Utility.Dom.NodeTypeEnum.TEXT_NODE) {
                    // it is form or select element, it is not array
                    arrRes.push(tmpObj);
                }
                else if (tmpObj["length"] >= 0) {
                    if (typeof tmpObj == "string") {
                        arrRes.push(tmpObj);
                    }
                    else // it must be array or dom array, iterate
                     {
                        for (var n2 = 0; n2 < tmpObj.length; n2++) {
                            var res2 = SelectFlatten(tmpObj[n2]);
                            arrRes.AddRange(res2);
                        }
                    }
                }
                else {
                    // not array and not string
                    arrRes.push(tmpObj);
                }
            }
            return arrRes;
        }
        Collections.SelectFlatten = SelectFlatten;
        function ForEach(array, delegate, context) {
            if (typeof (array) == "string")
                throw new Error("ForEach does not accept string");
            // must have support for DOM array and FileList which don't have push or pop
            if (array && array.length > 0) {
                // enumerate array, dom array or string
                for (var nn = 0; nn < array.length; nn++) {
                    delegate.call(context, array[nn], nn); // don't use if return === false because it will break execution in chrome (return is false by default)
                }
            }
        }
        Collections.ForEach = ForEach;
        function ForEachNodeList(array, delegate, context) {
            // must have support for DOM array and FileList which don't have push or pop
            if (array && array.length > 0) {
                // enumerate array, dom array or string
                for (var nn = 0; nn < array.length; nn++) {
                    delegate.call(context, array[nn], nn);
                }
            }
        }
        Collections.ForEachNodeList = ForEachNodeList;
        function ForEachChars(str, delegate, context) {
            if (typeof (str) != "string")
                throw new Error("ForEachChars requires string argument");
            // must have support for DOM array and FileList which don't have push or pop
            if (str && str.length > 0) {
                // enumerate array, dom array or string
                for (var nn = 0; nn < str.length; nn++) {
                    delegate.call(context, str.charAt(nn), nn);
                }
            }
        }
        Collections.ForEachChars = ForEachChars;
        function GetProperties(obj, ownPropertiesOnly) {
            /// <summary>
            /// returns Array
            /// </summary>
            /// <param name="obj" type="Object">object source</param>
            /// <param name="ownPropertiesOnly" type="Boolean" optional="true">default: false</param>
            var arr = [];
            if (obj) {
                // enumerate object's properties
                for (var prop in obj) {
                    if (!ownPropertiesOnly || obj.hasOwnProperty(prop)) {
                        arr.push(prop);
                    }
                }
            }
            return arr;
        }
        Collections.GetProperties = GetProperties;
        function GetOwnProperties(obj) {
            return GetProperties(obj, true);
        }
        Collections.GetOwnProperties = GetOwnProperties;
        /**
         * Foreach all properties, not just ownProperties.
         * @param {Object} obj
         * @param {Function} delegate function(propName, propValue, index){...}
         * @param {Object} context?
         * @returns
         */
        function ForEachProperties(obj, delegate, context) {
            if (obj) {
                // enumerate object's properties
                var index = 0;
                for (var prop in obj) {
                    delegate.call(context, prop, obj[prop], index++); // don't use if return === false because it will break execution in chrome (return is false by default)
                }
            }
        }
        Collections.ForEachProperties = ForEachProperties;
        /**
         * Foreach ownProperties only.
         * @param {Object} obj
         * @param {Function} delegate function(propName, propValue, index){...}
         * @param {Object} context
         * @returns
         */
        function ForEachOwnProperties(obj, delegate, context) {
            if (obj) {
                // enumerate object's properties
                var index = 0;
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        delegate.call(context, prop, obj[prop], index++); // don't use if return === false because it will break execution in chrome (return is false by default)
                    }
                }
            }
        }
        Collections.ForEachOwnProperties = ForEachOwnProperties;
        let _innerArray = "InnerArray";
        function HasInnerArray(obj) {
            return obj && _innerArray in obj;
        }
        Collections.HasInnerArray = HasInnerArray;
        function GetInnerArray(obj) {
            if (HasInnerArray(obj)) {
                return obj[_innerArray];
            }
            return undefined;
        }
        Collections.GetInnerArray = GetInnerArray;
    })(Collections = Calysto.Collections || (Calysto.Collections = {}));
})(Calysto || (Calysto = {}));
/// <reference path="../enumerable/enumerable.ts" />
/// <reference path="../enumerable/collections.ts" />
if (!Array.prototype.RemoveAt) {
    (function () {
        if (!Array.prototype.indexOf) {
            // for < IE9, used in Calysto.Enumerable.Distinct()
            Array.prototype.indexOf = function (item) {
                /// <summary>
                /// Calysto defined function. Returns index of item in this array.
                /// </summary>
                /// <param name="item" type="type"></param>
                /// <returns type=""></returns>
                for (var n = 0; n < this.length; n++) {
                    if (this[n] === item) {
                        return n;
                    }
                }
                return -1;
            };
        }
        Array.prototype.SkipTake = function (skip, take) {
            return this.slice(skip, skip + take);
        };
        Array.prototype.ForEach = function (action) {
            if (typeof action == "string")
                action = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(action);
            Calysto.Collections.ForEach(this, action);
            return this;
        };
        Array.prototype.Where = function (predicate, take) {
            if (typeof predicate == "string")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            var a1 = [];
            for (let n = 0; n < this.length; n++) {
                if (predicate(this[n], n)) {
                    a1.push(this[n]);
                    if (take && a1.length >= take) {
                        return a1;
                    }
                }
            }
            return a1;
        };
        Array.prototype.Select = function (selector) {
            if (typeof selector == "string")
                selector = Calysto.Utility.Expressions.CompileLambdaExpression(selector);
            var a1 = [];
            Calysto.Collections.ForEach(this, (item, index) => {
                a1.push(selector(item, index));
            });
            return a1;
        };
        Array.prototype.Reverse = function () {
            this.reverse(); // in place reverse
            return this;
        };
        Array.prototype.OrderBy = function (keySelector, descending) {
            /// <summary>
            /// sort and return new array with sorted values.
            /// </summary>
            /// <param name="keySelector" type="Function">function(item){return item.key;}</param>
            /// <param name="descending" type="Boolean"></param>
            if (typeof keySelector == "string")
                keySelector = Calysto.Utility.Expressions.CompileLambdaExpression(keySelector);
            return Calysto.ArraySorter.SortArray(this, keySelector, descending);
        };
        Array.prototype.RemoveAt = function (index) {
            /// <summary>
            /// Remove item at index position.
            /// </summary>
            /// <param name="index" type="Integer"></param>
            this.splice(index, 1);
            return this;
        };
        Array.prototype.Remove = function (item) {
            /// <summary>
            /// Remove item from array.
            /// </summary>
            /// <param name="item" type="type"></param>
            var index = this.indexOf(item);
            if (index == 0 || index > 0) {
                return this.RemoveAt(index);
            }
            return this;
        };
        Array.prototype.RemoveBy = function (predicate) {
            if (typeof predicate == "string")
                predicate = Calysto.Utility.Expressions.CompileLambdaExpression(predicate);
            for (let n1 = this.length - 1; n1 >= 0; n1--) {
                if (predicate(this[n1], n1)) {
                    this.splice(n1, 1);
                }
            }
            return this;
        };
        Array.prototype.Contains = function (value) {
            /// <summary>
            /// Calysto defined function. Search for value in this array, return true if value exists.
            /// </summary>
            /// <param name="value" type="type"></param>
            /// <returns type=""></returns>
            let index = this.indexOf(value);
            return index > 0 || index === 0;
        };
        Array.prototype.AsEnumerable = function () {
            return Calysto.CalystoEnumerable.From(this.slice(0));
        };
        Array.prototype.ToArray = function () {
            /// <summary>
            /// Creates new copied array (sliced copy).
            /// </summary>
            // Since GroupBy used to return enumerable, but now returns Array with Key property.
            // This way it is not exception if we invoke ToArray on such grouping group.
            return this.slice(0);
        };
        Array.prototype.Any = function () {
            /// <summary>
            /// Return true if there is any item in array.
            /// </summary>
            return this.length > 0;
        };
        Array.prototype.Add = function (item) {
            this.push(item);
            return this;
        };
        Array.prototype.AddRange = function (arr) {
            /// <summary>
            /// Calysto defined function. Uses foreach to iterate elements from arr and dd items from arr to this array. Return this array.
            /// </summary>
            /// <param name="value" type="Array|NodeList"></param>
            for (var n1 = 0; arr && n1 < arr.length; n1++) {
                this.push(arr[n1]);
            }
            return this;
        };
        Array.prototype.InsertRange = function (atIndex, arr) {
            /// <summary>
            /// Calysto defined function. Uses foreach to iterate elements from arr and insert at specified index. Return this array.
            /// </summary>
            /// <param name="value" type="Array|NodeList"></param>
            for (var n1 = arr.length; n1 > 0; n1--) {
                this.splice(atIndex, 0, arr[n1 - 1]);
            }
            return this;
        };
        Array.prototype.Clear = function () {
            /// <summary>
            /// Remove all items from array. Return this array.
            /// </summary>
            /// <returns type="Array"></returns>
            this.splice(0, this.length);
            return this;
        };
        Array.prototype.ToStringJoined = function (separator) {
            // join must have separator defined, if not defined, default is ", "
            return this.join(arguments.length > 0 ? separator : "");
        };
    })();
}
var Calysto;
(function (Calysto) {
    var _a, _b;
    // IE11, IE10, IE9 tested to work
    // required for generators function*(){}
    if (!window.Symbol) {
        let fn1 = function () { };
        fn1.iterator = {};
        window.Symbol = fn1;
    }
    class CalystoMapInternal {
        constructor() {
            this._kvArr = [];
        }
        get size() { return this._kvArr.length; }
        has(key) { return this._kvArr.Where(o => o.key === key, 1).Any(); }
        get(key) { return this._kvArr.Where(o => o.key === key, 1).Select(o => o.value).pop(); }
        set(key, value) {
            let kv = this._kvArr.Where(o => o.key === key, 1).pop();
            if (kv)
                kv.value = value;
            else
                this._kvArr.push({ key: key, value: value });
            return this;
        }
        // "window.Set" specific
        add(key, value) { return this.set(key, value || true); }
        delete(key) {
            let kv = this.get(key);
            this._kvArr.RemoveBy(o => o.key == key);
            return !!kv;
        }
        clear() { this._kvArr.Clear(); }
        *keys() {
            for (let item of this._kvArr)
                yield item.key;
        }
        *entries() {
            for (let item of this._kvArr)
                yield [item.key, item.value];
        }
    }
    // IE <= 10 doesn't have Map
    // IE <= 11 doesn't have entries and keys
    // IE11 has Map, but it has no entries, no keys and not iterable
    if (!((_b = (_a = window.Map) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.entries)) {
        window["Set"] = CalystoMapInternal;
        window["Map"] = CalystoMapInternal;
    }
})(Calysto || (Calysto = {}));
if (!Math["trunc"]) {
    Math["trunc"] = (x) => {
        // IE doesn't have trunc
        if (isFinite(x) && !isNaN(x)) {
            return parseInt((x + "").split(".")[0], 10);
        }
        else {
            return x;
        }
    };
}
if (typeof (Blob) != "undefined" && !Blob.prototype.SaveFileAs) {
    Blob.prototype.SaveFileAs = function (filename) {
        /// <summary>
        /// Save blob as filename.
        /// </summary>
        /// <param name="filename" type="string" optional="true">if not set, will use blob.filename</param>
        var blob = this;
        // IE 10+ (native saveAs)
        if (navigator && navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, filename || blob.filename);
        }
        else {
            var el = document.createElement("a");
            el.style.position = "absolute";
            el.style.opacity = "0";
            el.href = window.URL.createObjectURL(blob);
            el.download = filename || blob.filename;
            document.body.appendChild(el);
            el.click();
            if (el.parentNode) {
                el.parentNode.removeChild(el);
            }
        }
    };
}
if (!Boolean.prototype.ToStringFormated) {
    Boolean.prototype.ToStringFormated = function () {
        /// <summary>
        /// returns text "true" or "false"
        /// </summary>
        return this == true ? "true" : "false"; // use ==, DO NOT use === because on IE8 type is nt the same for: this === true
    };
}
if (!Date.FromLocalISOTString) {
    (function () {
        Date.now = function () {
            /// <summary>
            /// Calysto extension, added if desn't already exist Get ticks now.
            /// </summary>
            /// <returns type=""></returns>
            return new Date().getTime();
        };
        var fnPadLeft = function (n, places) {
            n += "";
            while (n.length < places) {
                n = "0" + n;
            }
            return n;
        };
        var fnPadRight = function (n, places) {
            n += "";
            while (n.length < places) {
                n = n + "0";
            }
            return n;
        };
        Date.ToLocalISOTString = (date) => {
            /// <summary>
            /// Serialize current datetime to ISO string, ignoring browser time zone. yyyy-MM-ddTHH:mm:ss.ffffff
            /// </summary>
            /// <returns type=""></returns>
            var str1 = fnPadLeft(date.getFullYear(), 4) + "-" +
                fnPadLeft(date.getMonth() + 1, 2) + "-" +
                fnPadLeft(date.getDate(), 2) + "T" +
                fnPadLeft(date.getHours(), 2) + ":" +
                fnPadLeft(date.getMinutes(), 2) + ":" +
                fnPadLeft(date.getSeconds(), 2) + "." +
                fnPadRight(date.getMilliseconds(), 3);
            return str1;
        };
        Date.FromLocalISOTString = function (dateStr) {
            /// <summary>
            /// Parse ISO string into Date, ignore browser time zone. yyyy-MM-ddTHH:mm:ss.ffffff
            /// </summary>
            /// <param name="dateStr" type="type"></param>
            /// <returns type=""></returns>
            // received from Calysto server: new Date("2015-04-25T11:37:32.323444"), convert to exact time, ignore time zone, this way we have the same time in brower as on server
            // this method parses ISO datetime with or without T and Z "2015-04-25T11:37:32.323444"
            var m = dateStr.match(new RegExp("[\\d]+", "g"));
            var date = new Date(0);
            if (m) {
                date.setFullYear(parseInt(m[0]));
                date.setMonth(parseInt(m[1]) - 1); // month: 0-11
                date.setDate(parseInt(m[2]));
                date.setHours(parseInt(m[3]));
                date.setMinutes(parseInt(m[4]));
                date.setSeconds(parseInt(m[5]));
                date.setMilliseconds(parseInt((fnPadRight(m[6] || "", 3)).substr(0, 3)) || 0); // limit to 3 digits since we don't want > 999 ms
            }
            return date;
        };
    })();
}
if (typeof (Error) != "undefined") {
    Error.prototype.AppendErrorDetails = function (additionalInfo, isServerError) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="additionalInfo" type="String|Object|Array" optional="true"></param>
        /// <param name="isServerError" type="Boolean" optional="true">if true exception received from server, will not create JS call stack and will not send to Elmah on server</param>
        var detailsArr = [];
        var htmlArr = [];
        if (additionalInfo) {
            try {
                if (typeof (additionalInfo) == "string") {
                    detailsArr.push(additionalInfo);
                }
                else if ("length" in additionalInfo) // moze i dom array
                 {
                    Calysto.Collections.ForEach(additionalInfo, (item, index) => detailsArr.push(item));
                }
                else {
                    Calysto.Collections.ForEachProperties(additionalInfo, (name, value, index) => {
                        if (name == "errorHtml") {
                            htmlArr.push(value);
                        }
                        else if (name == "errorDescription") {
                            detailsArr.push(value);
                        }
                        else {
                            detailsArr.push(name + ": " + value);
                        }
                    });
                }
            }
            catch (ex2) { }
        }
        this.CalystoException = {
            // string - short message
            Message: this.message,
            // string - detailed message used in debug mode
            Details: detailsArr.join("\r\n"),
            // string - details from server
            HtmlDetails: htmlArr.join("<br/>"),
            // bool - true if exception was thrown on server
            IsServerError: !!isServerError
        };
        return this;
    };
}
////if (!Function.prototype.EncapsulateArgs)
////{
////	Function.prototype.EncapsulateArgs = function (...args: any[]): Function
////	{
////		/// <summary>
////		/// Create outter function, bind current function with context and arguments. <br/>Return outter function which must be invoked without argumens.
////		/// </summary>
////		/// <param name="arg0" type="object">arg0</param>
////		/// <param name="arg1" type="object" optional="true"></param>
////		/// <param name="arg2" type="object" optional="true"></param>
////		/// <param name="arg3" type="object" optional="true"></param>
////		/// <param name="etc" type="object" optional="true"></param>
////		if (arguments.length < 1)
////		{
////			throw new Error("EncapsulateArgs(...) requires min 1 argument, current arguments: " + arguments.length);
////		}
////		var method = this;
////		var arr = arguments;
////		return function ()
////		{
////			return method.apply(method, arr)
////		};
////	};
////}
if (!Function.prototype.BindContext) {
    Function.prototype.BindContext = function (context) {
        /// <summary>
        /// Bind current function with context and optionally arguments.
        /// </summary>
        /// <param name="context">execution context</param>
        if (arguments.length != 1) {
            throw new Error("BindContext(...) requires 1 argument exactly, current arguments: " + arguments.length);
        }
        var method = this;
        var cx = context || this || null;
        return function ( /*arguments*/) {
            //now invoke this method within cx context and this arguments
            return method.apply(cx, arguments);
        };
    };
}
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Expressions;
        (function (Expressions) {
            function ParsePath(pathExpression) {
                let m1 = (pathExpression + "").match(new RegExp("return[\\s]+[\\w]+\\.([\\w\\.\\[\\]_@]+)"));
                if (m1 && m1[1])
                    return m1[1];
                else
                    throw new Error("Invalid path expression: " + pathExpression);
            }
            Expressions.ParsePath = ParsePath;
            function ParseExpression(expression, checkReturn) {
                var type = typeof (expression);
                if (!expression) {
                    return (function (x) { return x; });
                }
                else if (type == "function") {
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        if (checkReturn) {
                            var fnstr = (expression + "").substr(0, 1000);
                            if ((fnstr.indexOf("return") > 0) || (fnstr.indexOf("=>") > 0)) {
                                // it has return or it is lambda expression
                            }
                            else {
                                throw Error("Invalid lambda, missing return in: " + fnstr);
                            }
                        }
                    }
                    //#endif
                    return expression;
                }
                else if (type == "string") {
                    try {
                        var index1;
                        if (expression == "") {
                            return function (x) { return x; };
                        }
                        else if ((index1 = expression.indexOf("=>")) > 0) {
                            // split at first => only
                            // "(DataItem)=>{return DataItem.AsEnumerable().Where('o=>o.Selected').Count() > 1 ? 'yellow' : 'whitesmoke' ;}"
                            var left = expression.substr(0, index1);
                            var right = expression.substr(index1 + 2); // +2 because => lenth is 2
                            var parNames = left.match(new RegExp("[\\w$@_]+", "ig")) || []; // if there is no parameters
                            var mm;
                            if (mm = right.match(new RegExp("^[\\s]*new[\\s]+(\\{[\\w\\W]*)$"))) {
                                // "o, n => new {Name: o.Name, Age: o.Age}"
                                return new Function(parNames.join(","), "return " + mm[1] + ";");
                            }
                            else if (new RegExp("^[\\s]*\\{").test(right)) {
                                // "o, n => {var a = 10; var b = 20; return a + b;}"
                                return new Function(parNames.join(","), right + ";");
                            }
                            else {
                                // "o, n => o.Age > 10 && o.Legs > 1"
                                return new Function(parNames.join(","), "return " + right + ";");
                            }
                        }
                    }
                    catch (err1) {
                        throw new Error(err1 + "\r\n" + "in " + expression);
                    }
                }
                throw new Error("Unsupported expression in Calysto.Utility.Expressions.CompileLambdaExpression(" + expression + ")");
            }
            function CompileLambdaExpression(expression) {
                return ParseExpression(expression, true);
            }
            Expressions.CompileLambdaExpression = CompileLambdaExpression;
            function CompileLambdaNoReturnCheck(expression) {
                return ParseExpression(expression, false);
            }
            Expressions.CompileLambdaNoReturnCheck = CompileLambdaNoReturnCheck;
        })(Expressions = Utility.Expressions || (Utility.Expressions = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
/*
Modifier	Description
i		Perform case-insensitive matching
g		Perform a global match (find all matches rather than stopping after the first match)
m		Perform multiline matching

Expression	Description
[abc]	Find any character between the brackets
[^abc]	Find any character NOT between the brackets
[0-9]	Find any digit between the brackets
[^0-9]	Find any digit NOT between the brackets
(x|y)	Find any of the alternatives specified

Metacharacter	Description
.		Find a single character, except newline or line terminator
\w	Find a word character
\W	Find a non-word character
\d		Find a digit
\D		Find a non-digit character
\s		Find a whitespace character
\S		Find a non-whitespace character
\b		Find a match at the beginning/end of a word
\B		Find a match not at the beginning/end of a word
\0		Find a NUL character
\n		Find a new line character
\f		Find a form feed character
\r		Find a carriage return character
\t		Find a tab character
\v		Find a vertical tab character
\xxx		Find the character specified by an octal number xxx
\xdd		Find the character specified by a hexadecimal number dd
\uxxxx		Find the Unicode character specified by a hexadecimal number xxxx

Quantifier	Description
n+	Matches any string that contains at least one n
n*	Matches any string that contains zero or more occurrences of n
n?		Matches any string that contains zero or one occurrences of n
n{X}		Matches any string that contains a sequence of X n's
n{X,Y}	Matches any string that contains a sequence of X to Y n's
n{X,}	Matches any string that contains a sequence of at least X n's
n$	Matches any string with n at the end of it
^n	Matches any string with n at the beginning of it
?=n	Matches any string that is followed by a specific string n
?!n	Matches any string that is not followed by a specific string n
*/
if (!RegExp.Escape) {
    (function () {
        var reEscape = new RegExp("[" + [" ", "\\\\", "\\*", "\\+", "\\?", "\\|", "\\,", "\\^", "\\$", "\\.", "\\#", "\\(", "\\)", "\\{", "\\}", "\\[", "\\]"].join("") + "]", "g");
        RegExp.Escape = function (str) {
            /// <summary>
            /// Escapes a minimal set of characters (\, *, +, ?, |, {, [, (,), ^, $,., #, and white space) and return string with escaped chars.
            /// </summary>
            /// <param name="str" type="String"></param>
            return str.replace(reEscape, "\\$&");
        };
    })();
}
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        function Extend(destination, source, mayOverwrite, ownPropertiesOnly) {
            for (var prop in source) {
                if (!ownPropertiesOnly || source.hasOwnProperty(prop)) {
                    if (mayOverwrite || !(prop in destination)) {
                        destination[prop] = source[prop];
                    }
                }
            }
            return destination;
        }
        Utility.Extend = Extend;
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Type;
    (function (Type) {
        let KnownType;
        (function (KnownType) {
            KnownType[KnownType["String"] = 1] = "String";
            KnownType[KnownType["Boolean"] = 2] = "Boolean";
            KnownType[KnownType["Decimal"] = 3] = "Decimal";
            KnownType[KnownType["Number"] = 4] = "Number";
            KnownType[KnownType["Integer"] = 5] = "Integer";
            KnownType[KnownType["Array"] = 6] = "Array";
            KnownType[KnownType["Function"] = 7] = "Function";
            KnownType[KnownType["DateTime"] = 8] = "DateTime";
            KnownType[KnownType["Date"] = 9] = "Date";
            KnownType[KnownType["Any"] = 10] = "Any";
        })(KnownType = Type.KnownType || (Type.KnownType = {}));
        ;
    })(Type = Calysto.Type || (Calysto.Type = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Type;
    (function (Type) {
        var NumberConverter;
        (function (NumberConverter) {
            function ReplaceAll(str, search, replacement, ignoreCase) {
                if (!str) {
                    return str;
                }
                var re = new RegExp(RegExp.Escape(search), ignoreCase ? "ig" : "g");
                return str.replace(re, replacement);
            }
            /**
             * Parse as float number using current culture, or decimalSeparator. Returns number of defaultValue or null.
             * @param strOrNum
             * @param defaultValue default value to be returned if strOrNum is not number
             * @param decimalSeparator if not set, will use current culture
             */
            function ToNumberWithCulture(strOrNum, defaultValue, decimalSeparator) {
                if (Type.TypeInspector.IsNumber(strOrNum)) {
                    return strOrNum;
                }
                if (isNaN(defaultValue)) {
                    // leave NaN
                }
                else if (Type.TypeInspector.IsNullOrUndefined(defaultValue)) {
                    defaultValue = null;
                }
                decimalSeparator = decimalSeparator || Calysto.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator;
                // negative sign may have space after it, .NET formats with space: - 33
                var re = new RegExp("[\\-]*[ ]*[ \\.\\,]?[\\d]+[\\d\\.\\,]*"); // extract number from eg. "fsd---.423,636.432 kn"// masked edit will add "." eg: -.453.643,643
                var m = (strOrNum + "").match(re);
                var str1 = m && m[0] ? m[0] : "";
                // convert to US culture since parseFloat uses US culture always
                var str2 = str1
                    .replace(new RegExp(RegExp.Escape(decimalSeparator == "." ? "," : "."), "ig"), "")
                    .replace(new RegExp(RegExp.Escape(decimalSeparator), "ig"), ".")
                    .replace(new RegExp("[ ]*", "ig"), ""); // remove white spaces because parseFloat("- 43.53") fails if has space after minus
                // parseFloat("-432.6324") // ok
                // parseFloat("- 432.6324") // fails
                var parsed = parseFloat(str2);
                if (!isNaN(parsed) && isFinite(parsed)) //  && parsed + "" == str2 + "") // don't convert to string and compare because if parsing from : -00432.63 will get -432.63 and verification would fail
                 {
                    return parsed;
                }
                else {
                    return defaultValue;
                }
            }
            ;
            /**
             * Extract number from string and parse using current culture. Parse strOrNum and return number, if can't be parsed, return defaultValue
             * @param strOrNum
             * @param defaultValue default value to be returned if strOrNum is not number
             * @param decimalSeparator
             */
            function ToNumberOrDefault(strOrNum, defaultValue, decimalSeparator) {
                return ToNumberWithCulture(strOrNum, defaultValue, decimalSeparator);
            }
            NumberConverter.ToNumberOrDefault = ToNumberOrDefault;
            ;
            /**
             * Extract number from string and parse using current culture. Parse strOrNum and return number, if can't be parsed, return defaultValue
             * @param strOrNum
             * @param defaultValue default value to be returned if strOrNum is not number
             * @param decimalSeparator
             */
            function ToDecimal(strOrNum, defaultValue, decimalSeparator) {
                return ToNumberWithCulture(strOrNum, defaultValue, decimalSeparator);
            }
            NumberConverter.ToDecimal = ToDecimal;
            ;
            /**
             * Extract number from string and parse as float number using current culture, than convert to integer.
             * @param strOrNum
             * @param defaultValue
             */
            function ToInteger(strOrNum, defaultValue) {
                if (Type.TypeInspector.IsNullOrUndefined(defaultValue)) {
                    defaultValue = NaN;
                }
                var num = ToNumberOrDefault(strOrNum, defaultValue);
                if (!isNaN(num) && isFinite(num)) {
                    return num > 0 ? Math.floor(num) : Math.ceil(num);
                }
                else {
                    return defaultValue;
                }
            }
            NumberConverter.ToInteger = ToInteger;
            ;
            function ToBoolean(str, defaultValue) {
                if (Type.TypeInspector.IsBoolean(str))
                    return str;
                if (str == "true" || str == "True")
                    return true;
                if (str == "false" || str == "False")
                    return false;
                if (str > 0)
                    return true;
                if (str === 0)
                    return false;
                if (Type.TypeInspector.IsNullOrUndefined(defaultValue)) {
                    return null;
                }
                else {
                    return defaultValue;
                }
            }
            NumberConverter.ToBoolean = ToBoolean;
            ;
            /**
             * always returns string "" or default value +"" or ""
             * @param value
             * @param defaultValue
             */
            function ToString(value, defaultValue) {
                if (!Type.TypeInspector.IsNullOrUndefined(value)) {
                    return value + "";
                }
                else if (!Type.TypeInspector.IsNullOrUndefined(defaultValue)) {
                    return defaultValue + "";
                }
                return "";
            }
            NumberConverter.ToString = ToString;
            ;
        })(NumberConverter = Type.NumberConverter || (Type.NumberConverter = {}));
    })(Type = Calysto.Type || (Calysto.Type = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Type;
    (function (Type) {
        var TypeConverter;
        (function (TypeConverter) {
            /**
             * 	if obj is null or undefined or NaN, return empty string ""
                if exists obj.ToStringFormated, invoke obj.ToStringFormated(format), else, invoke ChangeType(obj, String).
             * @param obj
            * @param format eg.N1, N2, N0, dd.MM.yy HH: ss
             */
            function ToStringFormated(obj, format) {
                if (Type.TypeInspector.IsNullOrUndefined(obj))
                    return "";
                if (obj && obj.ToStringFormated)
                    return obj.ToStringFormated(format); // if format not provided, use default formating
                else
                    return ChangeType(obj, "String");
            }
            TypeConverter.ToStringFormated = ToStringFormated;
            ;
            /**
             * Convert obj to different type.
                If obj type already is of requested type, return obj itself.
                If obj is "", but toTypeName is not String, return null. This is required for element serialization, used in Calysto.Forms and Calysto.ObservableBinder
                If obj is null, but requested type is String, will return "" (empty string)
             * @param obj
             * @param toType type name, may end with question (?) which means nullable type
             * @param mayBeNull
             */
            function ChangeType(obj, toType, mayBeNull) {
                if (toType == "Int") {
                    throw new Error("Int is not supported, use Integer instead");
                }
                let destType = typeof (toType) == "string"
                    ? Type.TypeDescriptor.FromTypeName(toType, mayBeNull) :
                    toType;
                if (!destType.IsValidKnownType) {
                    throw new Error("Invalid destType: " + toType);
                }
                if (Type.TypeInspector.IsNullOrUndefined(obj) || (destType.KnownTypeName != Type.KnownType.String && obj === "")) {
                    // destType.NetType != DotNetType.String && obj === "": used in reading values from element and converting to type which is not string
                    if (destType.IsNullable) {
                        return null;
                    }
                    else {
                        throw new Error("Error in ChangeType(). Can not convert null to " + toType);
                    }
                }
                let currType = Type.TypeDescriptor.FromValue(obj);
                if (currType.UnderlayingTypeName == destType.UnderlayingTypeName) {
                    // obj already is of the required type
                    return obj;
                }
                switch (destType.KnownTypeName) {
                    case Type.KnownType.String:
                        if (currType.KnownTypeName == Type.KnownType.String)
                            return obj;
                        if (Type.TypeInspector.IsNullOrUndefined(obj))
                            return ""; // used in data binding to elments to convert undefined or null into empty string ""
                        if (obj.ToStringFormated)
                            return obj.ToStringFormated(); //this is way to convert date to string in Calysto.Forms.Deserialize
                        if (obj && obj.join)
                            return "[" + obj.join(",") + "]"; // convert array to string, there is already native converter in browser
                        // we could convert {...} to string too, but if object is large, lets better not do it, NO, DO NOT DO IT, LET'S THROW EXCEPTION
                        return obj + "";
                    case Type.KnownType.Boolean:
                        {
                            if (currType.KnownTypeName == Type.KnownType.Boolean)
                                return obj;
                            if (obj === true || obj == "true" || obj == "True" || obj == "1")
                                return true;
                            if (obj === false || obj == "false" || obj == "False" || obj == "0")
                                return false;
                            if (typeof (obj) == "number")
                                return obj === 0 ? false : true;
                            throw new Error("Can not create boolean from: " + obj);
                        }
                    //break;
                    case Type.KnownType.Decimal:
                    case Type.KnownType.Number:
                    case Type.KnownType.Integer:
                        {
                            if (!Type.TypeInspector.IsNumber(obj)) {
                                let re1 = new RegExp("^[\\+\\-]*[\\s]*[\\d\\,\\.]+$");
                                if (!re1.test(obj + ""))
                                    throw new Error("Can not create number from: " + obj);
                            }
                            var num = Type.NumberConverter.ToDecimal(obj); // convert using current culture
                            if (Type.TypeInspector.IsNumber(num)) {
                                if (destType.KnownTypeName == Type.KnownType.Integer) {
                                    return parseInt(num);
                                }
                                else {
                                    return num;
                                }
                            }
                            throw new Error("Can not create number from: " + obj);
                        }
                    //break;
                    case Type.KnownType.DateTime:
                    case Type.KnownType.Date:
                        {
                            if (typeof (obj) == "string") {
                                try {
                                    var dt = Calysto.DateTime.ParseDateTime(obj, undefined, true);
                                    if (!dt)
                                        throw new Error("Can not create DateTime from " + obj);
                                    if (dt && destType.KnownTypeName == Type.KnownType.Date)
                                        return dt.ToSystemDate();
                                    else
                                        return dt; // Calysto.DateTime
                                }
                                catch (e) {
                                    // na kraju ce baciti exception
                                }
                            }
                            throw new Error("Can not create DateTime from " + obj);
                        }
                    //break;
                    case Type.KnownType.Function:
                        return Calysto.Utility.Expressions.CompileLambdaExpression(obj);
                    case Type.KnownType.Array:
                        // csv values, [1,2,3,4]
                        return obj.Trim(['[', ']']).Split([',']).Select((o) => o.Trim());
                }
                throw new Error("Can not create " + toType + " from " + obj);
            }
            TypeConverter.ChangeType = ChangeType;
            ;
            /**
             * Try to change obj to toTypeName, output result into refOutArray. Returns true if successful.
             * @param obj
             * @param toType
             * @param refOut
             */
            function TryChangeType(obj, toType, refOut) {
                try {
                    refOut.SetValue(ChangeType(obj, toType));
                    return true;
                }
                catch (e1) { }
                return false;
            }
            TypeConverter.TryChangeType = TryChangeType;
            ;
        })(TypeConverter = Type.TypeConverter || (Type.TypeConverter = {}));
    })(Type = Calysto.Type || (Calysto.Type = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Type;
    (function (Type) {
        class TypeDescriptor {
            /** underlaying type name, without ? mark */
            get UnderlayingTypeName() { return this._typeName; }
            get KnownTypeName() { return Type.KnownType[this._typeName]; }
            /** Has ? mark: is nullable value type */
            get IsNullable() { return !!this._isNullable; }
            /** nullable type name, with ? mark if type is nullable */
            get NullableTypeName() { return this.UnderlayingTypeName + (this.IsNullable ? "?" : ""); }
            /** is net type parsed successfuly*/
            get IsValidKnownType() { return !!this.KnownTypeName; }
            static ResolveKnownTypeFromValue(value) {
                if (Type.TypeInspector.IsNullOrUndefined(value))
                    return Type.KnownType.Any;
                ////if (value.__typeName) return value.__typeName as string;
                if (Type.TypeInspector.IsString(value))
                    return Type.KnownType.String;
                if (Type.TypeInspector.IsBoolean(value))
                    return Type.KnownType.Boolean;
                if (Type.TypeInspector.IsNumber(value))
                    return Type.KnownType.Decimal;
                if (Type.TypeInspector.IsArrayOrDomArray(value))
                    return Type.KnownType.Array;
                if (Type.TypeInspector.IsFunction(value))
                    return Type.KnownType.Function;
                if (Type.TypeInspector.IsDateTime(value))
                    return Type.KnownType.DateTime;
                if (Type.TypeInspector.IsDate(value))
                    return Type.KnownType.Date;
                throw new Error("Can not reslove KnownType from value " + value);
            }
            /**
             *
             * @param typeName may be nullable with question mark, like in .NET, e.g. Integer?
             * @param isNullable
             */
            static FromTypeName(typeName, isNullable) {
                let tt = new TypeDescriptor();
                tt._isNullable = isNullable === true;
                tt._typeName = typeName;
                if ((typeName || "").indexOf("?") > 0) {
                    let name = (typeName || "").TrimEnd([' ', '?']);
                    tt._typeName = name;
                    tt._isNullable = true;
                }
                return tt;
            }
            static FromValue(value, isNullable) {
                return TypeDescriptor.FromTypeName(Type.KnownType[TypeDescriptor.ResolveKnownTypeFromValue(value)], isNullable || Type.TypeInspector.IsNullOrUndefined(value));
            }
        }
        Type.TypeDescriptor = TypeDescriptor;
    })(Type = Calysto.Type || (Calysto.Type = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Type;
    (function (Type) {
        var TypeInspector;
        (function (TypeInspector) {
            function fnTest(arr, fn) {
                if (arr && arr.length > 0) {
                    for (var n = 0; n < arr.length; n++) {
                        if (!fn(arr[n])) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }
            /**
             * for unittests
             * @param obj
             * @param property
             */
            function ContainsProperty(obj, property) {
                return obj && property && obj[property] !== undefined;
            }
            TypeInspector.ContainsProperty = ContainsProperty;
            /**
             * is boolean
             * @param args
             */
            function IsBoolean(...args) {
                return fnTest(arguments, (obj) => typeof (obj) == "boolean");
            }
            TypeInspector.IsBoolean = IsBoolean;
            ;
            /**
             * is finite number, not NaN
             * @param args
             */
            function IsNumber(...args) {
                //return !isNaN(parseFloat(obj)) && isFinite(obj); // from jQuery
                // if obj already is nuber, it may be parsed with parseFloat again
                // be carefull with null value, this is fnTested way to make sure we have the number and not (null or NaN or undefined)
                // isFinite(null) gives true
                // isFinite("") gives true
                // isFinite(NaN) gives false
                return fnTest(arguments, (obj) => typeof (obj) == "number" && !isNaN(obj) && isFinite(obj)); // provjereno ispravan test za number
            }
            TypeInspector.IsNumber = IsNumber;
            ;
            /**
             * is string
             * @param args
             */
            function IsString(...args) {
                return fnTest(arguments, (obj) => typeof (obj) == "string");
            }
            TypeInspector.IsString = IsString;
            ;
            /**
             * is system Array
             * @param args
             */
            function IsArray(...args) {
                // if obj is string, typeof(obj) == "string", everything else is the same as in array
                // dom array has length only, no push, pop, etc.
                return fnTest(arguments, (obj) => obj && obj.push && obj.pop && (obj.length > 0 || obj.length === 0));
            }
            TypeInspector.IsArray = IsArray;
            ;
            /**
             * is DOM array
             * @param args
             */
            function IsDomArray(...args) {
                // if obj is string, typeof(obj) == "string", everything else is the same as in array
                // dom array has length only, no push, pop, etc.
                // when used lambda, this is correct
                return fnTest(arguments, (obj) => {
                    var type = typeof (obj);
                    return obj
                        && (type == "object" || type == "function")
                        && !(type["tagName"] && type["nodeType"]) // exclude from and select elements which are arary of element or options
                        && (obj.length > 0 || obj.length === 0) // DOM array has length only, in Safari it is function
                        && !IsFunction(obj); // safari DOM array type is "function", but doesnt have Function specific properties
                });
            }
            TypeInspector.IsDomArray = IsDomArray;
            ;
            /**
             * is Array or DOM array
             * @param args
             */
            function IsArrayOrDomArray(...args) {
                return IsArray.apply(null, arguments) || IsDomArray.apply(null, arguments);
            }
            TypeInspector.IsArrayOrDomArray = IsArrayOrDomArray;
            ;
            /**
             * is functions with call and apply properties
             * @param args
             */
            function IsFunction(...args) {
                return fnTest(arguments, function (obj) {
                    // safari DOM array type is "function", but doesnt have Function specific properties
                    return typeof (obj) == "function" && "call" in obj && "apply" in obj;
                });
            }
            TypeInspector.IsFunction = IsFunction;
            ;
            /**
             * is null or undefined or NaN
             * @param args
             */
            function IsNullOrUndefined(...args) {
                if (arguments.length == 0)
                    return true;
                return fnTest(arguments, function (obj) {
                    if (obj === null || typeof (obj) == "undefined") {
                        return true;
                    }
                    else if (typeof (obj) == "number" && (isNaN(obj) || !isFinite(obj))) {
                        return true;
                    }
                    return false;
                });
            }
            TypeInspector.IsNullOrUndefined = IsNullOrUndefined;
            ;
            /**
             * Test if all values are valid string, number or boolean (excluding NaN, undefined and null of any type).
             * @param args
             */
            function IsValueType(...args) {
                return IsString.apply(null, arguments) || IsNumber.apply(null, arguments) || IsBoolean.apply(null, arguments);
            }
            TypeInspector.IsValueType = IsValueType;
            ;
            /**
             * is Calysto.DateTime
             * @param value
             */
            function IsDateTime(value) {
                return value && value.constructor == Calysto.DateTime;
            }
            TypeInspector.IsDateTime = IsDateTime;
            ;
            /**
             * is system Date
             * @param value
             */
            function IsDate(value) {
                return value && value.constructor == Date;
            }
            TypeInspector.IsDate = IsDate;
            ;
            function Coalesce(...args) {
                /// <summary>
                /// Returns first obj which is not null or undefined
                /// </summary>
                var tmp;
                for (var n = 0; n < arguments.length; n++) {
                    tmp = arguments[n];
                    if (!IsNullOrUndefined(tmp)) {
                        return tmp;
                    }
                }
                // don't return anything, this way method will return undefined
            }
            TypeInspector.Coalesce = Coalesce;
            ;
            /**
            * 1. If references are equal, returns true.
            * 2. If JSON is not supported, return false.
            * 3. If references are not equal, serializes both object into JSON and compare json strings.
            * @param {any} obj1
            * @param {any} obj2
            * @returns
            */
            function AreValuesEqual(obj1, obj2) {
                if (obj1 === obj2)
                    return true; // references are equal
                if (!window.JSON)
                    return false; // JSON is not supported, return false
                return JSON.stringify(obj1) === JSON.stringify(obj2);
            }
            TypeInspector.AreValuesEqual = AreValuesEqual;
            function CalculateHashCode(obj) {
                if (obj === null || obj === void 0 ? void 0 : obj.__$$hash)
                    return obj === null || obj === void 0 ? void 0 : obj.__$$hash;
                let val1 = JSON.stringify(obj);
                if (typeof val1 != "string")
                    val1 = obj + "";
                try {
                    obj.__$$hash = val1; // cache it for later
                }
                catch (e) {
                }
                return val1;
            }
            TypeInspector.CalculateHashCode = CalculateHashCode;
        })(TypeInspector = Type.TypeInspector || (Type.TypeInspector = {}));
    })(Type = Calysto.Type || (Calysto.Type = {}));
})(Calysto || (Calysto = {}));
/// <reference path="KnownType.ts" />
/// <reference path="NumberConverter.ts" />
/// <reference path="TypeConverter.ts" />
/// <reference path="TypeDescriptor.ts" />
/// <reference path="TypeInspector.ts" />
var Calysto;
(function (Calysto) {
    var Mathm;
    (function (Mathm) {
        /**
         * Generate rfc4122 version 4 compliant new GUID as function of current time and random number.
         * Returns string: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
        */
        function NewGuid() {
            var d = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(new RegExp("[xy]", "g"), function (c) {
                // number | 0 is the same as Math.floor(number)
                var r = (d + Math.random() * 16) % 16 | 0;
                d = Math.floor(d / 16);
                return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
            });
            return uuid;
        }
        Mathm.NewGuid = NewGuid;
        ;
        //#region random numbers
        /**
         * Returns random float value.
         * @param minVal inclusive min value, default: 0
         * @param maxVal exclusive max value, default: 1
         */
        function Random(minVal, maxVal) {
            minVal = Calysto.Type.TypeInspector.IsNumber(minVal) ? minVal : 0;
            maxVal = Calysto.Type.TypeInspector.IsNumber(maxVal) ? maxVal : 1;
            if (minVal > maxVal) {
                throw new Error("Invalid range in Calysto.Mathm.Random(...)");
            }
            return Math.random() * (maxVal - minVal) + minVal;
        }
        Mathm.Random = Random;
        ;
        /**
         * Returns random int value.
         * @param minVal inclusive min value, default: 0
         * @param maxVal exclusive max value, default: 100
         */
        function RandomInt(minVal, maxVal) {
            return Math.floor(Random(Calysto.Type.TypeInspector.IsNumber(minVal) ? minVal : 0, Calysto.Type.TypeInspector.IsNumber(maxVal) ? maxVal : 100));
        }
        Mathm.RandomInt = RandomInt;
        ;
        //#endregion
        //#region math functions
        function RunFunc(funcName, num, decimalPlaces) {
            // null == 0 is true
            if (!(decimalPlaces == 0 || decimalPlaces > 0))
                throw new Error("Missing decimalPlaces");
            // ne koristiti value % 1 za extrahiranje decimalnog dijela jer se dobije float infinite number
            var mult = Math.pow(10, decimalPlaces);
            return Math[funcName](num * mult) / mult;
        }
        function DecimalFloor(num, decimalPlaces) {
            /// <summary>
            /// Decimal floor to number of decimalPlaces.
            /// </summary>
            /// <param name="num" type="Number">number to invoke floor func on</param>
            /// <param name="decimalPlaces" type="int">decimal places to leave</param>
            return RunFunc("floor", num, decimalPlaces);
        }
        Mathm.DecimalFloor = DecimalFloor;
        ;
        function DecimalCeil(num, decimalPlaces) {
            /// <summary>
            /// Decimal ceil to number of decimalPlaces.
            /// </summary>
            /// <param name="num" type="Number">number to invoke ceil func on</param>
            /// <param name="decimalPlaces" type="int">decimal places to leave</param>
            return RunFunc("ceil", num, decimalPlaces);
        }
        Mathm.DecimalCeil = DecimalCeil;
        ;
        function DecimalRound(num, decimalPlaces) {
            /// <summary>
            /// Decimal round to number of decimalPlaces.
            /// </summary>
            /// <param name="num" type="Number">number to invoke round func on</param>
            /// <param name="decimalPlaces" type="int">decimal places to leave</param>
            return RunFunc("round", num, decimalPlaces);
        }
        Mathm.DecimalRound = DecimalRound;
        ;
        function DecimalTrunc(num, decimalPlaces) {
            /// <summary>
            /// Decimal truncate to number of decimalPlaces.
            /// </summary>
            /// <param name="num" type="Number">number to invoke trunc func on</param>
            /// <param name="decimalPlaces" type="int">decimal places to leave</param>
            return RunFunc("trunc", num, decimalPlaces);
        }
        Mathm.DecimalTrunc = DecimalTrunc;
        ;
        //#endregion
    })(Mathm = Calysto.Mathm || (Calysto.Mathm = {}));
})(Calysto || (Calysto = {}));
if (!Number.prototype.ToStringFormated) {
    Number.prototype.ToStringFormated = function (format) {
        let _tmpthis = this;
        if (isFinite(_tmpthis) && !isNaN(_tmpthis)) {
            let minDecPlaces = 0;
            let maxDecPlaces = 0;
            let isCurrency = false;
            let useThousandsSepator = false;
            let hashPattern = false;
            let m1;
            if (!format) {
                // unlimited decPlaces
                // will use decimal separator in current culture
                maxDecPlaces = 15;
            }
            else if ((m1 = format.toLowerCase().match(new RegExp("([NnCc])([\\d]*)")))) {
                useThousandsSepator = true;
                if (m1[1] == "c")
                    isCurrency = true;
                minDecPlaces = maxDecPlaces = !!m1[2] ? parseInt(m1[2], 10) : 2; // eg. N equals N2 (like in .NET), if not specified, 2 is default
                if (m1[3])
                    maxDecPlaces = parseInt(m1[3]);
                if (maxDecPlaces > 15)
                    throw new Error("Number format, allowed maxDecPlaces is 15, current: " + maxDecPlaces);
            }
            else if (format.indexOf("#") >= 0 && (m1 = format.match(new RegExp("([\\,\\.]*)([\\#]*)([0]*)([\\,\\.]+)([0]*)([\\#]*)$")))) {
                // format pattern ##,##0.##### // 0 is mandatory
                // "###,###,##0.00###".match(new RegExp("([\\,\\.]*)([\\#]*)([0]*)([\\,\\.]+)([0]*)([\\#]*)$"))
                // result: [",###0.00###", ",", "##", "0", ".", "00", "###"]
                let thousandSeparator = m1[1];
                useThousandsSepator = !!thousandSeparator;
                let decimalSeparator = m1[4];
                minDecPlaces = (m1[5] || "").length;
                maxDecPlaces = minDecPlaces + (m1[6] || "").length;
            }
            else {
                // unsupported format
                throw new Error("Unsupported number format in Number.ToStringFormated(" + format + ")");
            }
            let rounded = Calysto.Mathm.DecimalRound(_tmpthis, maxDecPlaces);
            let isNegative = rounded < 0;
            let parts = (Math.abs(rounded) + "").split('.'); // ne koristiti value % 1 za extrahiranje decimalnog dijela jer se dobije float infinite number
            let intpart = parts[0];
            let decpart = parts[1] || "";
            while (decpart.length < minDecPlaces)
                decpart += "0";
            // decimal separator
            if (decpart)
                decpart = Calysto.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator + decpart;
            if (useThousandsSepator) {
                let arr = intpart.split(""); // split to chars
                let chars1 = [];
                let tmp1;
                while (tmp1 = arr.pop()) {
                    if ((chars1.length + 1) % 4 == 0)
                        chars1.unshift(Calysto.Globalization.CultureInfo.CurrentCulture.NumberFormat.NumberGroupSeparator);
                    chars1.unshift(tmp1);
                }
                intpart = chars1.join("");
            }
            let numStr = (isNegative ? "-" : "") + intpart + decpart;
            // final:
            if (isCurrency) {
                return Calysto.Globalization.CultureInfo.CurrentCulture.NumberFormat.CurrencyPositivePatternString
                    .replace("{CurrencySymbol}", Calysto.Globalization.CultureInfo.CurrentCulture.NumberFormat.CurrencySymbol)
                    .replace("{Value}", numStr);
            }
            else {
                return numStr;
            }
        }
        else {
            throw new Error("NaN or undefined number can not be formated to string");
        }
    };
}
//WARNING: overloaded string methods create this as object (IE < 9), must convert it to string because comparison with string won't work
(function () {
    var fnCreateRegexStr = function (strCharArray) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="strCharArray" type="String|Array">string or string[] or char[]</param>
        if (typeof (strCharArray) == "string") {
            return RegExp.Escape(strCharArray);
        }
        else {
            var arr = new Array();
            for (var n = 0; n < strCharArray.length; n++) {
                arr.push(RegExp.Escape(strCharArray[n]));
            }
            return arr.join("|");
        }
    };
    String.IsNullOrEmpty = function (str1, str2, str3, etc) {
        ///<summary>
        /// Static.
        /// Returns true if any of strings is null or empty or undefined
        /// </summary>
        ///<param name="str1" type="String"></param>
        if (arguments.length == 0)
            return true;
        for (var n = 0; n < arguments.length; n++) {
            var tt = arguments[n];
            var type = typeof (tt);
            // on IE when invoked from String.prototype.AnyFunction using this, this is object, not string
            if (tt && (type == "string" || type == "object") && tt.length > 0) {
                // valid string
            }
            else {
                // null or empty string
                return true;
            }
        }
        return false;
    };
    String.IsNullOrWhiteSpace = function (str1, str2, str3, etc) {
        ///<summary>
        /// Static.
        /// Returns true if any of strings is null or empty or white space only or undefined
        /// </summary>
        ///<param name="str1" type="String"></param>
        if (arguments.length == 0)
            return true;
        for (var n = 0; n < arguments.length; n++) {
            var tt = arguments[n];
            var type = typeof (tt);
            // on IE when invoked from String.prototype.AnyFunction using this, this is object, not string
            if (tt && (type == "string" || type == "object") && tt.length > 0 && !new RegExp("^[\\s]+$").test(tt)) {
                // valid string
            }
            else {
                // null or empty or white space string
                return true;
            }
        }
        return false;
    };
    String.prototype.ToCharArray = function () {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str"></param>
        var str = this + "";
        var arr = [];
        for (var n = 0; n < str.length; n++) {
            arr.push(str.charAt(n));
        }
        return arr;
    };
    String.prototype.Equals = function (string2, ignoreCase) {
        /// <summary>
        /// Compare two string.
        /// </summary>
        /// <param name="string1">this</param>
        /// <param name="string2"></param>
        /// <param name="ignoreCase">If not set, default is false.</param>
        /// <returns type=""></returns>
        var string1 = this + "";
        if (string1 === string2) {
            return true;
        }
        else if (ignoreCase) {
            if (string1)
                string1 = string1.toLowerCase();
            if (string2)
                string2 = string2.toLowerCase();
            return string1 === string2;
        }
        return false;
    };
    var trimDefault = "(" + fnCreateRegexStr([' ', '\r', '\n', '\t']) + ")+"; // default chars to trim
    function Trim(str, charsArray, trimStart, trimEnd) {
        /// <summary>
        /// Trim string.
        /// </summary>
        /// <param name="str">String to be trimmed.</param>
        /// <param name="charsArray">Chars array to trim. If not set, will use default chars.</param>
        /// <param name="trimStart">If true, trim start.</param>
        /// <param name="trimEnd">If true, trim end.</param>
        /// <returns type="">Trimmed string.</returns>
        if (!str) {
            return str;
        }
        var restr = trimDefault;
        if (charsArray) {
            restr = "(" + fnCreateRegexStr(charsArray) + ")+";
        }
        if (arguments.length < 4) {
            trimEnd = true;
        }
        if (arguments.length < 3) {
            trimStart = true;
        }
        if (trimEnd && trimStart) {
            restr = "(^" + restr + ")|(" + restr + "$)";
        }
        else if (trimEnd) {
            restr += "$";
        }
        else if (trimStart) {
            restr = "^" + restr;
        }
        return str.replace(new RegExp(restr, "g"), "");
    }
    ;
    String.prototype.Trim = function (charsArray) {
        /// <summary>
        /// Trim string.
        /// </summary>
        /// <param name="str" type="String">this. String to be trimmed.</param>
        /// <param name="charsArray" type="Array" optional="true">Chars array to trim. If not set, will trim all white space with regex \s</param>
        var str = this + "";
        if (charsArray) {
            return Trim(str, charsArray, true, true);
        }
        else {
            return str.replace(new RegExp("(^[\\s]+)|([\\s]+$)", "g"), "");
        }
    };
    String.prototype.TrimStart = function (charsArray) {
        /// <summary>
        /// Trim string.
        /// </summary>
        /// <param name="str" type="String">this. String to be trimmed.</param>
        /// <param name="charsArray" type="Array" optional="true">Chars array to trim. If not set, will trim all white space with regex \s</param>
        var str = this + "";
        if (charsArray) {
            return Trim(str, charsArray, true, false);
        }
        else {
            return str.replace(new RegExp("(^[\\s]+)", "g"), "");
        }
    };
    String.prototype.TrimEnd = function (charsArray) {
        /// <summary>
        /// Trim string.
        /// </summary>
        /// <param name="str" type="String">this. String to be trimmed.</param>
        /// <param name="charsArray" type="Array" optional="true">Chars array to trim. If not set, will trim all white space with regex \s</param>
        var str = this + "";
        if (charsArray) {
            return Trim(str, charsArray, false, true);
        }
        else {
            return str.replace(new RegExp("([\\s]+$)", "g"), "");
        }
    };
    String.prototype.EndsWith = function (secondStr, ignoreCase) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="type">this</param>
        /// <param name="secondStr" type="String"></param>
        /// <param name="ignoreCase" type="boolean" optional="true"></param>
        // must test lenght>0 because !!new String("") == true, so length has to be tested too
        var str = this + "";
        if (!str || !secondStr)
            return false;
        var re = new RegExp(fnCreateRegexStr(secondStr) + "$", ignoreCase ? "ig" : "g");
        return re.test(str);
    };
    String.prototype.StartsWith = function (secondStr, ignoreCase) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="type">this</param>
        /// <param name="secondStr" type="String"></param>
        /// <param name="ignoreCase" type="boolean" optional="true"></param>
        // must test lenght>0 because !!new String("") == true, so length has to be tested too
        var str = this + "";
        if (!str || !secondStr)
            return false;
        if (ignoreCase) {
            var re = new RegExp("^" + fnCreateRegexStr(secondStr), ignoreCase ? "ig" : "g");
            return re.test(str);
        }
        else {
            return str.indexOf(secondStr) == 0;
        }
    };
    String.prototype.Contains = function (secondStr, ignoreCase) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="type">this</param>
        /// <param name="secondStr" type="String"></param>
        /// <param name="ignoreCase" type="boolean" optional="true"></param>
        // must test length>0 because !!new String("") == true, so length has to be tested too
        var str = this + "";
        if (!str || !secondStr)
            return false;
        if (ignoreCase) {
            var re = new RegExp(fnCreateRegexStr(secondStr), ignoreCase ? "ig" : "g");
            return re.test(str);
        }
        else {
            var index = str.indexOf(secondStr);
            return index >= 0;
        }
    };
    String.prototype.Substring = function (startIndex, length) {
        var str = this + "";
        if (!str) {
            return str;
        } // null or ""
        var maxlen = str.length - startIndex;
        if ((length || 0) > maxlen) {
            return str.substr(startIndex); // take all, length is larger than rest of the string
        }
        else {
            return str.substr(startIndex, length);
        }
    };
    String.prototype.Remove = function (startIndex) {
        var str = this + "";
        if (str && str.length > 0 && startIndex >= 0) {
            return str.substr(0, startIndex);
        }
        else {
            return "";
        }
    };
    String.prototype.Repeat = function (count) {
        /// <summary>repeated str count times</summary>
        /// <param name="str" type="Number|String|Object">The str to be repeated.</param>
        /// <param name="count" type="Number">The number of times to repeat the str in the generated sequence.</param>
        var str = this + "";
        var arr = [];
        for (var n = 0; n < count; n++) {
            arr.push(str);
        }
        return (arr.join(""));
    };
    function TakeSplitByWords(str, maxLength, takeLast, elipsis) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="string"></param>
        /// <param name="maxLength" type="int"></param>
        /// <param name="takeLast" type="bool"></param>
        /// <param name="elipsis" type="string"></param>
        var maxTextLength = maxLength - (elipsis || "").length;
        var currentLength = 0;
        var list = [];
        var split;
        var re = new RegExp("([\\w]+)|([^\\w]+)", "ig"); // m[1] je word, m[2] je non-word
        var matches = [];
        var m;
        while ((m = re.exec(str))) {
            matches.push(m);
        }
        if (takeLast) {
            matches.reverse(); // in-place reverse
        }
        for (var nn = 0; nn < matches.length; nn++) {
            m = matches[nn];
            currentLength += m[0].length;
            if (m[2]) // m[2] je split (non word)
             {
                // splitters are kept together, so we don't add tha splitter after the last word
                // there shouldn't be 2 splitters in a row, it is defined in regex
                split = (split || "") + m[0];
                continue;
            }
            else if (currentLength > maxTextLength) {
                break;
            }
            else {
                if (split) {
                    list.push(split);
                    split = null;
                }
                list.push(m[0]);
            }
        }
        if (elipsis) {
            list.push(elipsis);
        }
        if (takeLast) {
            list.reverse();
        }
        return list.join("");
    }
    String.prototype.TakeFirst = function (count, elipsis, wordSplit) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="string"></param>
        /// <param name="count" type="int"></param>
        /// <param name="wordSplit" type="bool">if true, split at word boundry</param>
        /// <param name="elipsis" type="string">eg. ...</param>
        var str = this + "";
        if (!str || count > str.length) {
            return str;
        }
        else if (wordSplit) {
            return TakeSplitByWords(str, count, false, elipsis);
        }
        else {
            return str.substr(0, count - (elipsis ? elipsis.length : 0)) + (elipsis || "");
        }
    };
    String.prototype.TakeLast = function (count, elipsis, wordSplit) {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str" type="string"></param>
        /// <param name="count" type="int"></param>
        /// <param name="wordSplit" type="bool">if true, split at word boundry</param>
        /// <param name="elipsis" type="string">eg. ...</param>
        var str = this + "";
        if (!str || count > str.length) {
            return str;
        }
        else if (wordSplit) {
            return TakeSplitByWords(str, count, true, elipsis);
        }
        else {
            return (elipsis || "") + str.substr(str.length - count + (elipsis ? elipsis.length : 0), count);
        }
    };
    String.prototype.Split = function (splitCharsArr, ignoreCase) {
        /// <summary>
        /// Split by any char
        /// </summary>
        /// <param name="str" type="String"></param>
        /// <param name="splitCharsArr" type="String|StringArray|CharArray">String or Array of chars or strings used as splitter</param>
        /// <param name="ignoreCase" type="Boolean"></param>
        var str = this + "";
        if (!str) {
            return [];
        }
        return str.split(new RegExp(fnCreateRegexStr(splitCharsArr), ignoreCase ? "ig" : "g")); // switch "g" nema utjecaja
    };
    String.prototype.ReplaceAll = function (search, replacement, ignoreCase) {
        /// <summary>
        /// Replace all occurances of search text inside of str, using RegExp.
        /// </summary>
        /// <param name="str" type="String"></param>
        /// <param name="search" type="String|StringArray|CharArray">String or Array of chars or strings to be replaced</param>
        /// <param name="replacement" type="String"></param>
        /// <param name="ignoreCase" type="Boolean"></param>
        var str = this + "";
        if (!str) {
            return str;
        }
        var re = new RegExp(fnCreateRegexStr(search), ignoreCase ? "ig" : "g");
        return str.replace(re, replacement);
    };
    String.prototype.ToNumber = function () {
        /// <summary>
        /// Convert to decimal number using current culture.
        /// </summary>
        /// <returns type=""></returns>
        return Calysto.Type.NumberConverter.ToDecimal(this + "");
    };
    String.prototype.ToFunc = function (noReturnCheck) {
        /// <summary>
        /// Convert lamba to function
        /// </summary>
        /// <returns type=""></returns>
        if (noReturnCheck) {
            return Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(this + "");
        }
        else {
            return Calysto.Utility.Expressions.CompileLambdaExpression(this + "");
        }
    };
    String.prototype.GetHashCode = function () {
        var str = this + "";
        var hash = 0;
        for (var n = 0; n < (str || "").length; n++) {
            var ch = str.charCodeAt(n);
            hash = ((hash << 5) - hash) + ch;
        }
        return hash & hash; // Convert to 32bit integer
    };
    String.prototype.FormatWith = function (obj, placeHolderStart = "{", placeHolderEnd = "}") {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="str">input string with property names or array indexes: My name is {Name}, or My name is {0}</param>
        /// <param name="obj" type="Object|Array">object with properties {Name:Tom, Age:22, ...} or array["Tom", 22"...]</param>
        /// <param name="placeHolderStart" optional="true" type="String" default="{"></param>
        /// <param name="placeHolderEnd" optional="true" type="String">default }</param>
        var str = this + "";
        if (!obj) {
            return str;
        }
        return str.replace(new RegExp("(" + RegExp.Escape(placeHolderStart || "{") + "([\\w_\\-\\.]+)" + RegExp.Escape(placeHolderEnd || "}") + ")", "g"), function (all, g1, g2, index, allStr) {
            var val = Calysto.DataBinder.GetValue(obj, g2);
            if (val == undefined) {
                throw new Error("Exception in String.FormatWith(), " + g1 + " property not found.");
            }
            return val;
        });
    };
    String.prototype.FormatWith2 = function (obj, placeHolderStart = "{{", placeHolderEnd = "}}") {
        return (this + "").FormatWith(obj, placeHolderStart, placeHolderEnd);
    };
    String.prototype.FormatWith3 = function (obj, placeHolderStart = "{{{", placeHolderEnd = "}}}") {
        return (this + "").FormatWith(obj, placeHolderStart, placeHolderEnd);
    };
    String.prototype.AsEnumerable = function () {
        return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(this + ""));
    };
    String.prototype.ToHtml = function (htmlEncode) {
        return Calysto.Utility.Html.StringToHtml(this + "", htmlEncode);
    };
    String.prototype.ToNullIfEmpty = function (trim) {
        let s1 = this + "";
        if (trim)
            s1 = s1.Trim();
        if (String.IsNullOrWhiteSpace(s1))
            return null;
        else
            return s1;
    };
})();
var Calysto;
(function (Calysto) {
    class TimeParts {
        constructor(ticks) {
            this.Ticks = ticks || 0;
            this.TotalSeconds = Math.floor(ticks / 1000);
            // hours part, can be > 24
            this.Hours = Math.floor(this.Ticks / 1000 / 60 / 60);
            this.Minutes = Math.floor(this.TotalSeconds / 60) % 60;
            this.Seconds = this.TotalSeconds % 60;
            this.Milliseconds = Math.floor(this.Ticks) % 1000;
        }
    }
    class TimeSpan {
        constructor() {
            this._token = new RegExp("[H]{1,2}|[h]{1,2}|[m]{1,2}|[s]{1,2}|[f]{1,3}", "g");
            this._ticks = 0;
        }
        /**
         * Returns ticks in milliseconds
         * @param {number} days
         * @param {number} hours
         * @param {number} minutes
         * @param {number} seconds
         * @param {number} milliseconds
         * @returns {type}
         */
        static GetTicks(days, hours, minutes, seconds, milliseconds) {
            /// <summary>
            /// Returns ticks in milliseconds
            /// </summary>
            /// <param name="days"></param>
            /// <param name="hours"></param>
            /// <param name="minutes"></param>
            /// <param name="seconds"></param>
            /// <param name="milliseconds"></param>
            return 1000 * 3600 * 24 * (days || 0)
                + 1000 * 3600 * (hours || 0)
                + 1000 * 60 * (minutes || 0)
                + 1000 * (seconds || 0)
                + (milliseconds || 0);
        }
        static Create(days, hours, minutes, seconds, milliseconds) {
            var tt = new Calysto.TimeSpan();
            tt._ticks = Calysto.TimeSpan.GetTicks(days, hours, minutes, seconds, milliseconds);
            return tt;
        }
        static Frommilliseconds(milliseconds) { return new Calysto.TimeSpan().AddMilliseconds(milliseconds); }
        static FromTicks(milliseconds) { return new Calysto.TimeSpan().AddMilliseconds(milliseconds); }
        static FromSeconds(seconds) { return new Calysto.TimeSpan().AddSeconds(seconds); }
        static FromMinutes(minutes) { return new Calysto.TimeSpan().AddMinutes(minutes); }
        static FromHours(hours) { return new Calysto.TimeSpan().AddHours(hours); }
        static FromDays(days) { return new Calysto.TimeSpan().AddDays(days); }
        AddTicks(ticksMs) {
            var tt = new Calysto.TimeSpan();
            tt._ticks = this._ticks + ticksMs;
            return tt;
        }
        AddDays(days) { return this.AddTicks(Calysto.TimeSpan.GetTicks(days)); }
        AddHours(hours) { return this.AddTicks(Calysto.TimeSpan.GetTicks(0, hours)); }
        AddMinutes(minutes) { return this.AddTicks(Calysto.TimeSpan.GetTicks(0, 0, minutes)); }
        AddSeconds(seconds) { return this.AddTicks(Calysto.TimeSpan.GetTicks(0, 0, 0, seconds)); }
        AddMilliseconds(milliseconds) { return this.AddTicks(milliseconds); }
        Totalmilliseconds() { return this._ticks; }
        TotalSeconds() { return this._ticks / 1000; }
        TotalMinutes() { return this._ticks / 1000 / 60; }
        TotalHours() { return this.TotalMinutes() / 60; }
        TotalDays() { return this.TotalHours() / 24; }
        ToParts() {
            return new TimeParts(this._ticks);
        }
        pad(val, len = 2) {
            val = String(val);
            len = len || 2;
            while (val.length < len)
                val = "0" + val;
            return val;
        }
        FormatTime(ticks, format) {
            // 1 tick == 1 ms
            var ms = this.pad(Math.floor(ticks) % 1000, 3);
            var totalSeconds = Math.floor(ticks / 1000);
            var hours = Math.floor(ticks / 1000 / 60 / 60); // total hours, can be > 24
            var min = Math.floor(totalSeconds / 60) % 60;
            var s = totalSeconds % 60;
            var flags = {
                H: hours,
                HH: this.pad(hours),
                m: min,
                mm: this.pad(min),
                s: s,
                ss: this.pad(s),
                f: String(ms).substr(0, 1),
                ff: String(ms).substr(0, 2),
                fff: String(ms).substr(0, 3)
            };
            return format.replace(this._token, function ($0) {
                //var dd = $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
                var dd = $0 in flags ? flags[$0] : ""; // if HH:mm:ss.ffffffff, take only parts which exists in flags{}
                return dd;
            });
        }
        ToStringFormated(format) {
            /// <summary>
            /// use format or current culture ShortTimePattern
            /// </summary>
            /// <param name="format"></param>
            return this.FormatTime(this._ticks, format || "HH:mm:ss.fff");
        }
    }
    Calysto.TimeSpan = TimeSpan;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    /**
    * .NET DayOfWeek
    */
    let DayOfWeek;
    (function (DayOfWeek) {
        DayOfWeek[DayOfWeek["Sunday"] = 0] = "Sunday";
        DayOfWeek[DayOfWeek["Monday"] = 1] = "Monday";
        DayOfWeek[DayOfWeek["Tuesday"] = 2] = "Tuesday";
        DayOfWeek[DayOfWeek["Wednesday"] = 3] = "Wednesday";
        DayOfWeek[DayOfWeek["Thursday"] = 4] = "Thursday";
        DayOfWeek[DayOfWeek["Friday"] = 5] = "Friday";
        DayOfWeek[DayOfWeek["Saturday"] = 6] = "Saturday";
    })(DayOfWeek = Calysto.DayOfWeek || (Calysto.DayOfWeek = {}));
    ;
    let DateFormat;
    (function (DateFormat) {
        ////var token = /d{1,4}|M{1,4}|yy(?:yy)?|([HhmsTtFf])\1?|[LloKSZ]|"[^"]*"|'[^']*'/g,
        ////timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        ////timezoneClip = /[^-+\dA-Z]/g,
        // fixed regex for AjaxMin and Packer
        var _token = new RegExp("d{1,4}|M{1,4}|yy(?:yy)?|[H]{1,2}|[h]{1,2}|[m]{1,2}|[s]{1,2}|[f]{1,3}|[t]{1,2}|[LloKSZT]|\"[^\"]*\"|'[^']*", "g");
        var _timezone = new RegExp("\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b", "g");
        var _timezoneClip = new RegExp("[^-+\dA-Z]", "g");
        function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len)
                val = "0" + val;
            return val;
        }
        // Regexes and supporting functions are cached through closure
        function Format(date, format, utc) {
            /// <summary>
            /// use mask or GeneralLongTimePattern
            /// </summary>
            /// <param name="date" type="Date"></param>
            /// <param name="mask" type="String"></param>
            /// <param name="utc" type="Boolean"></param>
            format = format || Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.GeneralLongTimePattern;
            // Allow setting the utc argument via the mask
            if (format.slice(0, 4) == "UTC:") {
                format = format.slice(4);
                utc = true;
            }
            var tzone;
            var mtz1 = (date + "").match(_timezone);
            if (mtz1 && mtz1.length > 0) {
                tzone = (mtz1[0] || "").replace(_timezoneClip, "");
            }
            var get = utc ? "getUTC" : "get", datum = date[get + "Date"](), // day in month: 1...31
            dan = date[get + "Day"](), // day of week, 0:Sunday, 1: Monday...
            month = date[get + "Month"](), // 0...11
            year = date[get + "FullYear"](), hours = date[get + "Hours"](), min = date[get + "Minutes"](), s = date[get + "Seconds"](), L = date[get + "Milliseconds"](), L = pad(Math.floor(L) % 1000, 3), // create 3 chars, eg if L was 12 ticks, convert it  to "012"
            o = utc ? 0 : date.getTimezoneOffset(), // minutes, eg. if zone is -120 (minutes), it is GMT+0200 (hours) because sign is opposite
            flags = {
                dddd: i18n.DayNames[dan],
                ddd: i18n.AbbreviatedDayNames[dan],
                dd: pad(datum),
                d: datum,
                MMMM: i18n.MonthNames[month],
                MMM: i18n.AbbreviatedMonthNames[month],
                MM: pad(month + 1),
                M: month + 1,
                yy: String(year).slice(2),
                yyyy: year,
                h: hours % 12 || 12,
                hh: pad(hours % 12 || 12),
                H: hours,
                HH: pad(hours),
                m: min,
                mm: pad(min),
                s: s,
                ss: pad(s),
                f: String(L).substr(0, 1),
                ff: String(L).substr(0, 2),
                fff: L,
                t: hours < 12 ? "A" : "P",
                tt: hours < 12 ? "AM" : "PM",
                K: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60)) + ":" + pad(Math.abs(o) % 60),
                Z: utc ? "UTC" : tzone,
                //o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S: ["th", "st", "nd", "rd"][(datum % 10 > 3) || (datum >= 10 && datum <= 20) ? 0 : (datum % 10)]
            };
            return format.replace(_token, function ($0) {
                var dd = $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
                return dd;
            });
        }
        DateFormat.Format = Format;
        function GetInt(parseString, parseFormat, dic, possibleArr) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="valueArr" type="Array"></param>
            /// <param name="formatArr" type="Array"></param>
            /// <param name="posibleArr" type="Array"></param>
            for (var k of possibleArr) {
                // dic contains properties which are set in format string
                if (k in dic) {
                    if (Calysto.Type.TypeInspector.IsNumber(dic[k])) {
                        return dic[k];
                    }
                    else {
                        return NaN; // we have format, but there is no value, it is error
                    }
                }
            }
            return 0;
        }
        // ISO with T or without and with or without ending time zone info
        var reg1 = new RegExp("([\\d]+)-([\\d]+)-([\\d]+)[T\\s]+([\\d]*)[:]*([\\d]*)[:]*([\\d]*)[\\.]*([\\d]*)([\\+ \\:\\d\\w]*)");
        // HR with T or without and with or without ending time zone info
        var reg2 = new RegExp("([\\d]+).([\\d]+).([\\d]+)[\\.]*[T\\s]+([\\d]*)[:]*([\\d]*)[:]*([\\d]*)[\\.]*([\\d]*)([\\+ \\:\\d\\w]*)");
        var fnPadRight = function (n, places) {
            n += "";
            while (n.length < places) {
                n = n + "0";
            }
            return n;
        };
        function TryParseExact(arg, format, refOut, throwError) {
            var _a;
            if (Calysto.Type.TypeInspector.IsDate(arg)) {
                refOut.SetValue(new DateTime(arg));
                return true;
            }
            else if (Calysto.Type.TypeInspector.IsDateTime(arg)) {
                refOut.SetValue(arg);
                return true;
            }
            let str = arg || "";
            if (format) {
                var f1 = format.split(new RegExp("[^\\w]+"));
                var v1 = str.split(new RegExp("[^\\d]+"));
                var dic = {};
                for (let n = 0; n < f1.length; n++) {
                    let val = v1[n];
                    if ((_a = f1[n]) === null || _a === void 0 ? void 0 : _a.StartsWith("f"))
                        val = fnPadRight(val, 3); // convert to full milliseconds
                    dic[f1[n]] = parseInt(val);
                }
                var args = [
                    GetInt(str, format, dic, ["yyyy", "yy"]),
                    GetInt(str, format, dic, ["MM", "M"]),
                    GetInt(str, format, dic, ["dd", "d"]),
                    GetInt(str, format, dic, ["HH", "H"]),
                    GetInt(str, format, dic, ["mm", "m"]),
                    GetInt(str, format, dic, ["ss", "s"]),
                    GetInt(str, format, dic, ["fff", "ff", "f"])
                ];
                if (args.Where(o => o == NaN).Any()) {
                    if (throwError) {
                        throw new Error("Error parsing date from: " + str + ", to format: " + format);
                    }
                    else {
                        return false;
                    }
                }
                try {
                    refOut.SetValue(Calysto.DateTime.Create.apply(null, args));
                    return true;
                }
                catch (e) {
                    if (throwError)
                        throw e;
                }
                return false;
            }
            let m = str.match(reg1);
            if (m) {
                refOut.SetValue(Calysto.DateTime.Create(parseInt(m[1], 10), // day
                parseInt(m[2], 10), // month
                parseInt(m[3], 10), // year
                parseInt(m[4], 10), // hour
                parseInt(m[5], 10), // minutes
                parseInt(m[6], 10), // seconds
                parseInt(fnPadRight(m[7] || "", 3).substr(0, 3), 10) // ms
                ));
                return true;
            }
            m = str.match(reg2);
            if (m) {
                refOut.SetValue(Calysto.DateTime.Create(parseInt(m[3], 10), // year
                parseInt(m[2], 10), // month
                parseInt(m[1], 10), // day
                parseInt(m[4], 10), // hours
                parseInt(m[5], 10), // minutes
                parseInt(m[6], 10), // seconds
                parseInt(fnPadRight(m[7] || "", 3).substr(0, 3), 10) // ms
                ));
                return true;
            }
            let date;
            if ((date = new Date(Date.parse(str))) && !isNaN(date.getFullYear())) {
                refOut.SetValue(new Calysto.DateTime(date));
                return true;
            }
            if (throwError) {
                throw new Error("Can not parse DateTime from " + str);
            }
            return false;
        }
        DateFormat.TryParseExact = TryParseExact;
        // Some common format strings
        DateFormat.masks = {
            "default": "ddd MMM dd yyyy HH:mm:ss",
            shortDate: "M/d/yy",
            mediumDate: "MMM d, yyyy",
            longDate: "MMMM d, yyyy",
            fullDate: "dddd, MMMM d, yyyy",
            shortTime: "h:mm tt",
            mediumTime: "h:mm:ss tt",
            longTime: "h:mm:ss tt K",
            isoDate: "yyyy-MM-dd",
            isoTime: "HH:mm:ss",
            isoDateTime: "yyyy-MM-dd HH:mm:ss.fff",
            iso3DateTime: "yyyy-MM-ddTHH:mm:ss.fff",
            iso6DateTime: "yyyy-MM-ddTHH:mm:ss.ffffff",
            isoUtcDateTime: "UTC:yyyy-MM-dd HH:mm:ss.fff"
        };
        // Internationalization strings
        var i18n = Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat;
        ////__df.i18n = {
        ////	AbbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        ////	DayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        ////	AbbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        ////	MonthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        ////	FirstDayOfWeek: : 0
        ////};
    })(DateFormat = Calysto.DateFormat || (Calysto.DateFormat = {}));
    class DateTimeParts {
        constructor(date) {
            this.Year = date.getFullYear();
            this.Month = date.getMonth() + 1;
            // day or date in month
            this.Day = date.getDate();
            // .NET like day of week: 0=Sunday, 1=Monday, ... use Calysto.DateTime.DayOfWeek enumeration
            this.DayOfWeek = date.getDay();
            this.Hour = date.getHours();
            this.Minute = date.getMinutes();
            this.Second = date.getSeconds();
            this.Millisecond = date.getMilliseconds();
            this.Ticks = date.getTime();
        }
    }
    Calysto.DateTimeParts = DateTimeParts;
    class DateTime {
        constructor(date) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="date" type="Date|String">if not set, will use new Date(0) which is 1.1.1970.</param>
            this._typeName = "DateTime";
            if (!date) {
                this._dateItem = new Date(0);
            }
            else if (typeof (date) == "string") {
                // iso date time string
                this._dateItem = Date.FromLocalISOTString(date);
            }
            else if (date.constructor == DateTime) {
                this._dateItem = date._dateItem;
            }
            else if (date.constructor == Date) {
                this._dateItem = date;
            }
            if (Calysto.Core.IsDebugDefined) {
                this._isoDateStr = Date.ToLocalISOTString(this._dateItem);
                this._currCultureStr = this._dateItem.ToStringFormated();
            }
        }
        ToStringFormated(format) {
            return DateFormat.Format(this._dateItem, format);
        }
        ToShortDateString() {
            return this.ToStringFormated(Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern);
        }
        toString() { return this.ToStringFormated("yyyy-MM-dd HH:mm:ss.fff K"); }
        ; // for convertion to string on this + ""
        DayOfWeek() {
            /// <summary>
            /// JS and .NET has the same DayOfWeek, Sunday==0, enumeration Calysto.DateTime.DayOfWeek
            /// </summary>
            return this._dateItem.getDay();
        }
        DatePart() {
            /// <summary>
            /// Returns date component only and time 00:00:00
            /// </summary>
            var p = this.ToParts();
            return Calysto.DateTime.Create(p.Year, p.Month, p.Day);
        }
        TimePart() {
            /// <summary>
            /// Returns TimeSpan, a time interval that represents the fraction of the day that has elapsed since midnight. 
            /// </summary>
            var p = this.ToParts();
            return Calysto.TimeSpan.Create(0, p.Hour, p.Minute, p.Second, p.Millisecond);
        }
        ToParts() {
            return new DateTimeParts(this._dateItem);
        }
        AddHours(hours) { return new Calysto.DateTime(new Date(this._dateItem.getTime() + hours * 60 * 60 * 1000)); }
        AddMinutes(minutes) { return new Calysto.DateTime(new Date(this._dateItem.getTime() + minutes * 60 * 1000)); }
        AddSeconds(seconds) { return new Calysto.DateTime(new Date(this._dateItem.getTime() + seconds * 1000)); }
        AddMiliseconds(misliseconds) { return new Calysto.DateTime(new Date(this._dateItem.getTime() + misliseconds)); }
        AddDays(days) { return new Calysto.DateTime(new Date(this._dateItem.getTime() + days * 24 * 60 * 60 * 1000)); }
        AddMonths(months) {
            var currMonths = this._dateItem.getFullYear() * 12 + this._dateItem.getMonth() + months;
            var year = currMonths / 12;
            var month = currMonths % 12;
            var date = new Date(this._dateItem.getTime());
            date.setMonth(month);
            date.setFullYear(year);
            return new Calysto.DateTime(date);
        }
        AddYears(years) {
            var year = this._dateItem.getFullYear() + years;
            var date = new Date(this._dateItem.getTime());
            date.setFullYear(year);
            return new Calysto.DateTime(date);
        }
        /**
         * to JS Date object, create copy
         */
        ToSystemDate() {
            // IE cannot instantinate new Date from date, so get ticks first
            let ticks = this._dateItem ? this._dateItem.getTime() : 0;
            return new Date(ticks);
        }
        /**
         * to Calysto.DateTime, create copy
         */
        ToDateTime() {
            return new DateTime(this._dateItem);
        }
        static Now() {
            return new Calysto.DateTime(new Date());
        }
        static Create(year, month, day, hours, minutes, seconds, miliseconds) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="year">eg. 2014</param>
            /// <param name="month">1-12</param>
            /// <param name="day">1-31</param>
            /// <param name="hours" optional="true">0-23</param>
            /// <param name="minutes" optional="true">0-59</param>
            /// <param name="seconds" optional="true">0-59</param>
            /// <param name="miliseconds" optional="true">0-999</param>
            if (arguments.length > 2 && Calysto.Type.TypeInspector.IsNumber(year, month, day)) {
                // Date accepts month [0-11]
                return new Calysto.DateTime(new Date(year || 1700, (month || 1) - 1, day || 1, hours || 0, minutes || 0, seconds || 0, miliseconds || 0));
            }
            else {
                throw new Error("Can not create DateTime");
            }
        }
        static TryParseDateTime(str, format, refOut) {
            /// <summary>
            /// Parse str using format or current culture GeneralLongTimePattern.<br/>
            /// Than try using Date.parse(str)<br/>
            /// Returns Calysto.DateTime, or null if can't be parsed.
            /// </summary>
            /// <param name="str"></param>
            /// <param name="format" type="String" optional="true">.NET like date format string, if not provided, will use CurrentCulture format</param>
            if (format) {
                return DateFormat.TryParseExact(str, format, refOut);
            }
            else if (DateFormat.TryParseExact(str, Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.GeneralLongTimePattern, refOut)) {
                return true;
            }
            else if (DateFormat.TryParseExact(str, Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern, refOut)) {
                return true;
            }
            return false;
        }
        static TryParseDate(str, format, refOut) {
            if (DateTime.TryParseDateTime(str, format, refOut)) {
                refOut.SetValue(refOut.GetValue().DatePart());
                return true;
            }
            return false;
        }
        /**
         * Returns Calysto.DateTime, throw exception if can't be parsed.
         * @param {string} str
         * @param {string} format?
         * @returns
         */
        static ParseDateTime(str, format, throwEx) {
            /// <summary>
            /// Parse str using format or current culture GeneralLongTimePattern.<br/>
            /// Than try using Date.parse(str)<br/>
            /// Returns Calysto.DateTime, or null if can't be parsed.
            /// </summary>
            /// <param name="str"></param>
            /// <param name="format" type="String" optional="true">.NET like date format string, if not provided, will use CurrentCulture format</param>
            let refOut = new Calysto.BoxValue();
            if (DateTime.TryParseDateTime(str, format, refOut)) {
                return refOut.GetValue();
            }
            if (throwEx) {
                throw Error("Error in ParseDateTime, can not parse: " + str);
            }
            return undefined; // we need this for imagine, to prevent from throwing exception
        }
        /**
         * Returns Calysto.DateTime, date part only, throw exception if can't be parsed.
         * @param {string} str
         * @param {string} format?
         * @returns
         */
        static ParseDate(str, format, throwEx) {
            let refOut = new Calysto.BoxValue();
            if (DateTime.TryParseDate(str, format, refOut)) {
                return refOut.GetValue();
            }
            if (throwEx) {
                throw Error("Error in ParseDate, can not parse: " + str);
            }
            return undefined;
        }
    }
    Calysto.DateTime = DateTime;
})(Calysto || (Calysto = {}));
// used in CalystoDatePicker:
Date.prototype.ToStringFormated = function (format) {
    /// <summary>
    /// format DateTime to string, default is yyyy-MM-dd HH:mm:ss.fff
    /// </summary>
    /// <param name="format" optional="true">.NET date time string format</param>
    return Calysto.DateFormat.Format(this, format);
};
Date.prototype.ToDateTime = function () {
    return new Calysto.DateTime(this);
};
Date.prototype.ToSystemDate = function () {
    return new Date(this);
};
Date.prototype.ToDateTime = function () {
    return new Calysto.DateTime(this);
};
var Calysto;
(function (Calysto) {
    class KeyValue {
        constructor(key, value) {
            this.Key = key;
            this.Value = value;
        }
    }
    Calysto.KeyValue = KeyValue;
    class Dictionary {
        constructor() {
            this._map = new Map();
        }
        AsEnumerable() {
            return Calysto.CalystoEnumerable.From(() => function* (__this) {
                for (let kv of __this._map.entries())
                    yield new KeyValue(kv[0], kv[1]);
            }(this));
        }
        GetItems() {
            return this.AsEnumerable().ToArray();
        }
        ToRawObject(errorOnDuplicateKey) {
            var d = {};
            // key must be string, since key in {} is always string
            // dic[1] = "test"; dic[1] returns "test", but ["1"] returns "test" too, which means that key is converted into string by JS engine
            this.GetItems().ForEach(o => {
                let keyStr = o.Key + "";
                if (errorOnDuplicateKey && d[keyStr] != undefined)
                    throw new Error("Duplicated key: " + o.Key);
                d[keyStr] = o.Value;
            });
            return d;
        }
        Clear() {
            this._map.clear();
        }
        RemoveKey(key) {
            this._map.delete(key);
        }
        GetValues() {
            return this.AsEnumerable().Select(o => o.Value).ToArray();
        }
        GetKeys() {
            return this.AsEnumerable().Select(o => o.Key).ToArray();
        }
        Count() {
            return this._map.size;
        }
        ContainsKey(key) {
            return !!this._map.has(key);
        }
        AddKeyValue(kv) {
            return this.Add(kv.Key, kv.Value);
        }
        Add(key, value) {
            if (this._map.has(key)) {
                throw Error("Duplicated key: " + key);
            }
            this._map.set(key, value);
            return this;
        }
        SetValue(key, value) {
            this._map.set(key, value);
            return this;
        }
        TryGetValue(key, refOut) {
            if (this._map.has(key)) {
                refOut.SetValue(this._map.get(key));
                return true;
            }
            return false;
        }
        GetValue(key) {
            var refOut = new Calysto.BoxValue();
            if (this.TryGetValue(key, refOut)) {
                return refOut.GetValue();
            }
            throw new Error("Key not found: " + key);
        }
        GetValueOrDefault(key, defaultValue) {
            var refOut = new Calysto.BoxValue();
            if (this.TryGetValue(key, refOut)) {
                return refOut.GetValue();
            }
            return defaultValue;
        }
    }
    Calysto.Dictionary = Dictionary;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class CalystoEnumerator {
        constructor(fnYieldNext) {
            this.fnYieldNext = fnYieldNext;
        }
        YieldNext(refYield) {
            if (this.fnYieldNext(refYield)) {
                this.current = refYield.GetValue();
                return true;
            }
            return false;
        }
        ;
        GetNext() {
            let box = new Calysto.BoxValue();
            this.YieldNext(box);
            return box;
        }
        MoveNext() {
            return this.YieldNext(new Calysto.BoxValue());
        }
        ;
        get Current() {
            return this.current;
        }
        ;
        static FromYieldFunc(fnYieldNext) {
            if (fnYieldNext /*as (refYield: BoxValue<TElement>) => boolean*/ && Calysto.Type.TypeInspector.IsFunction(fnYieldNext)) {
                return new CalystoEnumerator(fnYieldNext);
            }
            throw new Error("CalystoEnumerator can not be created from fnYieldNext: " + fnYieldNext);
        }
        static From(source) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            if (source) {
                if (typeof source == "string") {
                    return FromString(source);
                }
                else if (((_b = (_a = source) === null || _a === void 0 ? void 0 : _a.GetEnumerator) === null || _b === void 0 ? void 0 : _b.apply) && "GetEnumerator" in source) {
                    // source is ICalystoEnumerable<TElement>
                    return source.GetEnumerator();
                }
                else if (((_d = (_c = source) === null || _c === void 0 ? void 0 : _c.YieldNext) === null || _d === void 0 ? void 0 : _d.apply) && ((_f = (_e = source) === null || _e === void 0 ? void 0 : _e.MoveNext) === null || _f === void 0 ? void 0 : _f.apply) && "Current" in source) {
                    // source is CalystoEnumerator
                    return source;
                }
                else if (Calysto.Type.TypeInspector.IsArrayOrDomArray(source)) {
                    // source is TElement[]
                    return FromArray(source);
                }
                else if ((_j = (_h = (_g = source) === null || _g === void 0 ? void 0 : _g.next) === null || _h === void 0 ? void 0 : _h.apply) === null || _j === void 0 ? void 0 : _j.apply) {
                    // source is Iterator<TElement>
                    // if "return" in source && "throw" in source then source is IterableIterator<TElement>
                    // Chrome Iterator has next, without return or throw, e.g. new FormData().next(), but no return and no throw props
                    return FromIterableIterator(source);
                }
                else if (typeof source == "function") {
                    if ((_o = (_m = (_l = (_k = source) === null || _k === void 0 ? void 0 : _k.prototype) === null || _l === void 0 ? void 0 : _l.next) === null || _m === void 0 ? void 0 : _m.apply) === null || _o === void 0 ? void 0 : _o.apply) {
                        // generator function: function*(){yield value;}
                        return FromGeneratorFunc(source);
                    }
                    // if it is TypeScript generated generator for ES5, we have to invoke the function
                    // because function*(){} when translated to ES5, doesn't have prototype with next(), return() or throw()
                    // invoking the function returns object which has next(), return() and throw() which mimics IterableIterator<TElement>
                    let gen1 = source();
                    if ((_q = (_p = gen1 === null || gen1 === void 0 ? void 0 : gen1.next) === null || _p === void 0 ? void 0 : _p.apply) === null || _q === void 0 ? void 0 : _q.apply) {
                        return FromIterableIterator(gen1);
                    }
                    else if (((_r = gen1 === null || gen1 === void 0 ? void 0 : gen1.YieldNext) === null || _r === void 0 ? void 0 : _r.apply) && ((_s = gen1 === null || gen1 === void 0 ? void 0 : gen1.MoveNext) === null || _s === void 0 ? void 0 : _s.apply) && "Current" in gen1) {
                        // source is CalystoEnumerator
                        return gen1;
                    }
                }
            }
            throw new Error("CalystoEnumerator can not be created from source: " + source);
        }
    }
    Calysto.CalystoEnumerator = CalystoEnumerator;
    ;
    function FromArray(source) {
        var index = -1;
        return new CalystoEnumerator((refYield) => {
            if (source.length > 0 && ++index < source.length) {
                refYield.SetValue(source[index]);
                return true;
            }
            return false;
        });
    }
    function FromIterableIterator(source) {
        let res1;
        return new CalystoEnumerator((refYield) => {
            res1 = source.next();
            if (res1 && !res1.done) {
                refYield.SetValue(res1.value);
                return true;
            }
            return false;
        });
    }
    /**
        * From generator, function* (){ yield value; } with yield inside.
        * @param fn
        */
    function FromGeneratorFunc(fn) {
        let res1;
        let source;
        return new CalystoEnumerator((refYield) => {
            if (!source)
                source = fn();
            res1 = source.next();
            if (res1 && !res1.done) {
                refYield.SetValue(res1.value);
                return true;
            }
            return false;
        });
    }
    /**
        * From string, distinction from lambda as string.
        * Returns chars enumerable
        * @param source
        */
    function FromString(source) {
        if (source && Calysto.Type.TypeInspector.IsString(source)) {
            var index = -1;
            return new CalystoEnumerator((refYield) => {
                if (source.length > 0 && ++index < source.length) {
                    refYield.SetValue(source.charAt(index));
                    return true;
                }
                return false;
            });
        }
        throw new Error("CalystoEnumerator can not be created from source: " + source);
    }
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Features;
    (function (Features) {
        let BrowserKindEnum;
        (function (BrowserKindEnum) {
            BrowserKindEnum[BrowserKindEnum["Unknown"] = 0] = "Unknown";
            BrowserKindEnum[BrowserKindEnum["Firefox"] = 1] = "Firefox";
            BrowserKindEnum[BrowserKindEnum["Chrome"] = 2] = "Chrome";
            BrowserKindEnum[BrowserKindEnum["Safari"] = 3] = "Safari";
            BrowserKindEnum[BrowserKindEnum["Opera"] = 4] = "Opera";
            BrowserKindEnum[BrowserKindEnum["MSIE"] = 5] = "MSIE";
            BrowserKindEnum[BrowserKindEnum["Bot"] = 6] = "Bot";
            BrowserKindEnum[BrowserKindEnum["MobileBot"] = 7] = "MobileBot";
            BrowserKindEnum[BrowserKindEnum["iPhone"] = 8] = "iPhone";
            BrowserKindEnum[BrowserKindEnum["AndroidMobile"] = 9] = "AndroidMobile";
            BrowserKindEnum[BrowserKindEnum["NokiaMobile"] = 10] = "NokiaMobile";
            BrowserKindEnum[BrowserKindEnum["WapPhone"] = 11] = "WapPhone";
            // Google bot
            BrowserKindEnum[BrowserKindEnum["MobilePhone"] = 12] = "MobilePhone";
            BrowserKindEnum[BrowserKindEnum["IEMobile"] = 13] = "IEMobile";
            BrowserKindEnum[BrowserKindEnum["iPad"] = 14] = "iPad";
            BrowserKindEnum[BrowserKindEnum["AndroidTablet"] = 15] = "AndroidTablet";
            BrowserKindEnum[BrowserKindEnum["iPod"] = 16] = "iPod";
            BrowserKindEnum[BrowserKindEnum["BlackBerry"] = 17] = "BlackBerry";
            BrowserKindEnum[BrowserKindEnum["MSEdge"] = 18] = "MSEdge";
            BrowserKindEnum[BrowserKindEnum["ChromiumEdge"] = 19] = "ChromiumEdge";
        })(BrowserKindEnum = Features.BrowserKindEnum || (Features.BrowserKindEnum = {}));
        let OSKindEnum;
        (function (OSKindEnum) {
            OSKindEnum[OSKindEnum["Unknown"] = 0] = "Unknown";
            OSKindEnum[OSKindEnum["Windows"] = 1] = "Windows";
            OSKindEnum[OSKindEnum["Macintosh"] = 2] = "Macintosh";
            OSKindEnum[OSKindEnum["Android"] = 3] = "Android";
            OSKindEnum[OSKindEnum["Linux"] = 4] = "Linux";
            OSKindEnum[OSKindEnum["WindowsPhone"] = 5] = "WindowsPhone";
        })(OSKindEnum = Features.OSKindEnum || (Features.OSKindEnum = {}));
        //#region Flash & Silverlight detection
        function IsContained(str) {
            if (window.navigator && navigator.mimeTypes) {
                for (var n = 0; n < navigator.mimeTypes.length; n++) {
                    if ((navigator.mimeTypes[n]["type"] + "").indexOf(str) > 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        var hasFlash;
        function HasFlash() {
            if (!hasFlash)
                hasFlash = { value: IsContained("x-shockwave-flash") };
            return hasFlash.value;
        }
        Features.HasFlash = HasFlash;
        var hasSilverlight;
        function HasSilverlight() {
            if (!hasSilverlight)
                hasSilverlight = { value: IsContained("x-silverlight") };
            return hasSilverlight.value;
        }
        Features.HasSilverlight = HasSilverlight;
        ;
        //#endregion
        /* UserAgent examples:
    
        navigator.userAgent:
        IE11: "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko"
        IE10: "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"
        IE9: "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"
        IE8: "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"
        IE7: "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"
        
        Opera: "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154 Safari/537.36 OPR/20.0.1387.82"
        
        Chrome: "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36"
        
        Firefox: "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0"
        
        Safari: "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"
        
        Intel Mac OS X 10.7
        
        "Mozilla/5.0 (Windows Phone 8.1; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; NOKIA; Lumia 520) like Gecko"
    
        "Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)"
        */
        //#region Browser detection
        function RemoveDots(verStr) {
            // eg. "20.0.1387.82", leave first dot and remove others: 20.0138782
            var arr = verStr.split(".");
            var vv = arr.shift();
            if (arr.length > 0) {
                vv += "." + arr.join("");
            }
            return vv || "";
        }
        function DetectBrowser() {
            var ua = navigator.userAgent || "";
            var vendor = navigator.vendor || "";
            var detMatch = null;
            var detKind = null;
            var detIsMobile = null;
            var detIsTablet = null;
            var detIsCrawler = null;
            var detHasTouch = null;
            //**********************************
            // 0th level detection
            //**********************************
            if (ua.Contains("Bot", true) || ua.Contains("Crawler", true)) {
                detIsCrawler = true;
            }
            if (ua.Contains("Mobile", true)) {
                detIsMobile = true;
            }
            detHasTouch = navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
            //**********************************
            // 1st level detection
            //**********************************
            if (ua.Contains("iPad")) {
                // Mozilla/5.0 (iPad; U; CPU OS 4_3_5 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8L1 Safari/6533.18.5
                detIsTablet = true;
                detKind = BrowserKindEnum.iPad;
                detMatch = ua.match("Version\\/([\\d\\.]+)");
            }
            else if (ua.Contains("iPod")) {
                // Mozilla/5.0 (iPod; U; CPU OS 4_3_5 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8L1 Safari/6533.18.5
                detIsMobile = true;
                detKind = BrowserKindEnum.iPod;
                detMatch = ua.match("Version\\/([\\d\\.]+)");
            }
            else if (ua.Contains("iPhone")) {
                // iphone User-Agent: Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7
                detIsMobile = true;
                detKind = BrowserKindEnum.iPhone;
                detMatch = ua.match("Version\\/([\\d\\.]+)");
            }
            else if (ua.Contains("IEMobile")) {
                // new nokia is Windows Phone: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)"
                // Windows Phone 8.1: "Mozilla/5.0 (Windows Phone 8.1; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; NOKIA; Lumia 520) like Gecko"
                // vidi: http://www.zytrax.com/tech/web/mobile_ids.html
                detIsMobile = true;
                detKind = BrowserKindEnum.IEMobile;
                detMatch = ua.match("IEMobile\\/([\\d\\.]+)");
            }
            else if (ua.Contains("Nokia")) {
                // must be case-sensitive comparison for Nokia
                // User-Agent: Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 Nokia5230/20.0.005; Profile/MIDP-2.1 Configuration/CLDC-1.1 ) AppleWebKit/525 (KHTML, like Gecko) Version/3.0 BrowserNG/7.2.3
                detIsMobile = true;
                detKind = BrowserKindEnum.NokiaMobile;
                detMatch = ua.match("Version\\/([\\d\\.]+)");
            }
            else if (ua.Contains("PlayBook") || ua.Contains("BlackBerry") || ua.Contains("BB10")) {
                // "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+"
                // "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+"
                detKind = BrowserKindEnum.BlackBerry;
                if (!(detIsTablet = ua.Contains("Tablet"))) {
                    detIsMobile = ua.Contains("Mobile");
                }
            }
            else if ((detMatch = ua.match("MSIE ([\\d\\.]+)"))) // ie v <= 10
             {
                detKind = BrowserKindEnum.MSIE;
            }
            else if (("msMaxTouchPoints" in navigator || "msManipulationViewsEnabled" in navigator) && (detMatch = ua.match("rv:([\\d\\.]+)"))) // ie 11 only
             {
                // ie 11 has no vendor string
                detKind = BrowserKindEnum.MSIE;
            }
            else if ("msManipulationViewsEnabled" in navigator && (detMatch = ua.match("Edge[\\/]([\\d\\.]+)"))) {
                detKind = BrowserKindEnum.MSEdge;
            }
            else if (detMatch = ua.match(" Edg[\\/]([\\d\\.]+)")) {
                detKind = BrowserKindEnum.ChromiumEdge;
            }
            else if (ua.Contains("MSIE")) {
                // MSIE 8
                // User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)
                detKind = BrowserKindEnum.MSIE;
            }
            else if (ua.Contains("Android")) {
                // Android HTC Evo user agent string:
                // Mozilla/5.0 (Linux; U; Android 2.2; en-us; Sprint APA9292KT Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1
                // Mozilla/5.0 (Android; Mobile; rv:33.0) Gecko/33.0 Firefox/33.0
                // Mozilla/5.0 (Android; Tablet; rv:33.0) Gecko/33.0 Firefox/33.0
                if (!(detMatch = ua.match("Version\\/([\\d\\.]+)"))) {
                    detMatch = ua.match("Android ([\\d\\.]+)");
                }
                // mobile android has 360x640 screen
                // tablets has width > 900
                if (ua.Contains("Tablet") || (screen.width > 900 && screen.width > screen.height)) {
                    detIsTablet = true;
                    detKind = BrowserKindEnum.AndroidTablet;
                }
                else {
                    detIsMobile = true;
                    detKind = BrowserKindEnum.AndroidMobile;
                }
            }
            else if (vendor.Contains("Opera") || ua.Contains("OPR/") || ua.Contains("Opera")) {
                detKind = BrowserKindEnum.Opera;
                detMatch = ua.match("(OPR|Opera)\\/([\\d\\.]+)"); // version is in detMatch[2]
                if (detMatch) {
                    detMatch = [detMatch[0], detMatch[2]];
                }
            }
            else if (vendor.Contains("Google")) {
                if (detMatch = ua.match("(OPR|Opera)\\/([\\d\\.]+)")) {
                    // version is in detMatch[2]
                    // New Opera: 
                    // vendor: Google Inc.
                    // useragent: "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.152 Safari/537.36 OPR/29.0.1795.60"
                    detKind = BrowserKindEnum.Opera;
                }
                else {
                    // Chrome original:
                    // useragent: "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36"
                    detKind = BrowserKindEnum.Chrome;
                    detMatch = ua.match("Chrome\\/([\\d\\.]+)");
                }
            }
            else if (vendor.Contains("Apple")) {
                detKind = BrowserKindEnum.Safari;
                detMatch = ua.match("Version\\/([\\d\\.]+)");
            }
            else if ((detMatch = ua.match("Firefox\\/([\\d\\.]+)"))) {
                // firefox has no vendor string
                detKind = BrowserKindEnum.Firefox;
            }
            else if (ua.Contains("Firefox")) {
                // User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8
                detKind = BrowserKindEnum.Firefox;
            }
            else if (ua.Contains("Mobile")) {
                detIsMobile = true;
                detKind = BrowserKindEnum.MobilePhone;
            }
            else if (ua.Contains("Chrome")) {
                detKind = BrowserKindEnum.Chrome;
            }
            else if (ua.Contains("Safari")) {
                detKind = BrowserKindEnum.Safari;
            }
            //**********************************
            // parse version
            //**********************************
            var verNum = null, verStr = detMatch ? detMatch[1] : "";
            if (verStr) {
                verNum = parseFloat(RemoveDots(verStr));
            }
            //**********************************
            // final object
            //**********************************
            if (detIsMobile && detIsTablet) {
                // this is tablet with Mobile in user-agent: //"Mozilla/5.0 (Linux; Android 4.3; Nexus 7 Build/JSS15Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2307.2 Mobile Safari/537.36
                // leave IsTablet = true, remove IsMobile
                detIsMobile = false;
            }
            // return object so we may set property comments
            return ({
                // [bool] true: browser was detected, false: not detected
                Found: !!(detKind && detKind > 0),
                // [string] Browser name: Firefox, Chrome, Safari, Opera, MSIE, Unknown
                KindName: BrowserKindEnum[detKind || 0],
                // [BrowserKindEnum] Unknown: 0, Firefox: 1, Chrome: 2, Safari: 3, Opera: 4, MSIE: 5
                Kind: detKind || 0,
                // [float] eg. 8.1
                Version: verNum || 0,
                // [string] version as string, not parsed version, may contains non digit chars
                VersionString: verStr,
                IsCrawler: !!detIsCrawler,
                IsMobile: !!detIsMobile,
                IsTablet: !!detIsTablet,
                IsDesktop: !detIsMobile && !detIsTablet,
                HasTouch: !!detHasTouch,
            });
        }
        var detectedBrowser;
        function GetBrowser() {
            return detectedBrowser || (detectedBrowser = DetectBrowser());
        }
        Features.GetBrowser = GetBrowser;
        //#endregion
        //#region OS detection
        function GetWindowsVersionName(ntversion) {
            switch (ntversion) {
                case 10.0:
                    return "Windows 10";
                case 6.3:
                    return "Windows 8.1";
                case 6.2:
                    return "Windows 8";
                case 6.1:
                    return "Windows 7";
                case 6.0:
                    return "Windows Vista";
                case 5.2:
                    return "Windows XP Professional x64";
                case 5.1:
                    return "Windows XP";
                case 4.9:
                    return "Windows ME";
                case 5.0:
                    return "Windows 2000";
                case 4.1:
                    return "Windows 98";
                case 4.0:
                    return "Windows NT 4.0";
                default:
                    return null;
            }
        }
        function GetIphoneVersion(version) {
            switch (version) {
                case 4.21:
                    return "iPhone 4";
                case 7.0:
                    return "iPhone 5";
                case 8.0:
                    return "iPhone 6";
                default:
                    return null;
            }
        }
        function DetectOS() {
            var ua = navigator.userAgent || "";
            var detMatch = null;
            var detKind = null;
            if (ua.Contains("Windows Phone")) {
                // "Mozilla/5.0 (Windows Phone 8.1; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; NOKIA; Lumia 520) like Gecko"
                // "Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0)"
                detKind = OSKindEnum.WindowsPhone;
                detMatch = ua.match(new RegExp("Windows Phone( OS | )([\\d\\.]+)"));
                if (detMatch) {
                    detMatch = [detMatch[0], detMatch[2]];
                }
            }
            else if (ua.Contains("Windows")) {
                detKind = OSKindEnum.Windows;
                detMatch = ua.match(new RegExp("Windows NT ([\\d\\.]+)"));
            }
            else if (ua.Contains("Mac")) {
                detKind = OSKindEnum.Macintosh;
                // "Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4"
                // Mozilla/5.0 (iPad; CPU OS 7_1_1 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D201 Safari/9537.53
                // Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.59.10 (KHTML, like Gecko) Version/5.1.9 Safari/534.59.10
                detMatch = ua.match(new RegExp("(OS |OS X )([\\d_]+)"));
                if (detMatch && detMatch[2]) {
                    detMatch = [detMatch[0], detMatch[2].replace(new RegExp("_", "g"), ".")];
                }
            }
            else if (ua.Contains("Android")) {
                // must test for Android before Linux because Android userAgent contains Linux word too
                detKind = OSKindEnum.Android;
                detMatch = ua.match(new RegExp("Android ([\\d\\.]+)"));
            }
            else if (ua.Contains("Linux")) {
                detKind = OSKindEnum.Linux;
            }
            var verNum = null, verStr = detMatch ? detMatch[1] : "", winVersion = null, iPhoneVersion = null;
            if (verStr) {
                verNum = parseFloat(RemoveDots(verStr));
                if (detKind == OSKindEnum.Windows) {
                    winVersion = GetWindowsVersionName(verNum);
                }
                else if (detKind == OSKindEnum.Macintosh) {
                    // detect iPhone version
                    iPhoneVersion = GetIphoneVersion(verNum);
                }
            }
            return {
                // [bool] true: OS was detected, false: not detected
                Found: !!(detKind && detKind > 0),
                // [string] OS name: Windows, Macintosh, Android, Linux, Unknown
                KindName: Calysto.Enum.GetName(OSKindEnum, detKind || 0),
                // [OSKindEnum] Unknown: 0, Windows: 1, Macintosh: 2, Android: 3, Linux: 4
                Kind: detKind || 0,
                // [float] version
                Version: verNum || 0,
                // [string] version as string, non parsed
                VersionString: verStr,
                // [string] windows exact version
                WinName: winVersion,
                // [string] iPhone version
                iPhoneVersion: iPhoneVersion,
                IsWindows: detKind == OSKindEnum.Windows,
                IsAndroid: detKind == OSKindEnum.Android,
                IsLinux: detKind == OSKindEnum.Linux,
                IsMacintosh: detKind == OSKindEnum.Macintosh
            };
        }
        var detectedOS;
        function GetOS() {
            return detectedOS || (detectedOS = DetectOS());
        }
        Features.GetOS = GetOS;
        //#endregion
    })(Features = Calysto.Features || (Calysto.Features = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var CookieUtility;
    (function (CookieUtility) {
        /**
         * Set cookie value.
         * @param cookieName
         * @param cookieValue
         * @param expiresAfterSECONDS Number of seconds to keep cookie alive. If value not set or null, creates session cookie.
         * @param domain Domain with dot before: .domain.com or .www.domain.com
         * @param path Path, default /
         * @param secure Is secure
         */
        function SetCookieValue(cookieName, cookieValue, expiresAfterSECONDS, domain, path, secure) {
            // Set-Cookie:cookieName=cookieValue; domain=.pnew.hr; expires=Wed, 26-Oct-2112 07:54:37 GMT; path=/
            if (!cookieName) {
                throw Error("cookieName is required");
            }
            var expires = expiresAfterSECONDS ? new Date(Math.round(Date.now() + (1000 * expiresAfterSECONDS))) : null; // getTime() return ticks in ms, new Date(ticks in ms)
            var cc = encodeURIComponent(cookieName + "") + '=' + encodeURIComponent(cookieValue + "") // convert cookieValue to string
                + (expires ? '; expires=' + expires.toUTCString() : '')
                + (domain ? ('; domain=' + domain) : '') // if not set, browser uses current host, if domain is different than current host or not subset of current host, cookie is not set
                + ('; path=' + (path ? path : '/')) // default /
                + (secure ? '; secure' : '');
            document.cookie = cc;
        }
        CookieUtility.SetCookieValue = SetCookieValue;
        /**
         * Get cookie value by cookie name.
         * @param cookieName
         */
        function GetCookieValue(cookieName) {
            // document.cookie has "name=value; name1=value1" only, last value doesn't have ;
            var cookieValue = '';
            var posName = document.cookie.indexOf(encodeURIComponent(cookieName) + '=');
            if (cookieName && posName >= 0) {
                var posValue = posName + (encodeURIComponent(cookieName) + '=').length;
                var endPos = document.cookie.indexOf(';', posValue);
                if (endPos >= 0) {
                    cookieValue = decodeURIComponent(document.cookie.substring(posValue, endPos));
                }
                else {
                    // there is no ; so it is last cookie
                    cookieValue = decodeURIComponent(document.cookie.substring(posValue));
                }
            }
            return (cookieValue || "");
        }
        CookieUtility.GetCookieValue = GetCookieValue;
        /** Get all cookies as array of Name-Values: [{Name:c1, Value:v1}, {Name:c2, Value:v2},...] */
        function GetCookies() {
            var arr = document.cookie.split(';');
            var col = []; // return type
            for (var n = 0; n < arr.length; n++) {
                var nv = arr[n].replace(new RegExp("(^[\\s]+)|([\\s]$)", "ig"), ""); // trim white space
                if (nv) {
                    var a = nv.split('=');
                    col.push({ Name: decodeURIComponent(a[0]), Value: decodeURIComponent(a[1]) });
                }
            }
            return col;
        }
        CookieUtility.GetCookies = GetCookies;
        ;
        /**
         * Delete cookie.
         * @param cookieName
         * @param domain
         */
        function DeleteCookie(cookieName, domain) {
            return SetCookieValue(cookieName, "", (-1) * Date.now() / 1000, domain);
        }
        CookieUtility.DeleteCookie = DeleteCookie;
        ;
    })(CookieUtility = Calysto.CookieUtility || (Calysto.CookieUtility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Event;
    (function (Event) {
        var TAGNAMES = {
            'select': 'input',
            'change': 'input',
            'submit': 'form',
            'reset': 'form',
            'error': 'img',
            'load': 'img',
            'abort': 'img'
        };
        function IsSupported(eventType) {
            /// <summary>
            /// Test if event name is supported by the browser.
            /// </summary>
            /// <param name="eventType" type="String">event name without 'on'</param>
            /// <returns type="Boolean"></returns>
            if (eventType.indexOf("on") == 0)
                eventType = eventType.substr(2);
            switch (eventType) {
                case "hover":
                    eventType = "mouseover";
                    break;
                case "hout":
                    eventType = "mouseout";
                    break;
                case "enterKey":
                case "escKey":
                    return true;
            }
            var el = document.createElement(TAGNAMES[eventType] || 'div');
            eventType = 'on' + eventType;
            var isSupported = (eventType in el);
            if (!isSupported) {
                el.setAttribute(eventType, 'return;');
                isSupported = typeof el[eventType] == 'function';
            }
            el = null;
            return isSupported;
        }
        Event.IsSupported = IsSupported;
        ;
        /**
         *
         * @param element
         * @param eventFullName includes event name and namespace: click.stage1.allStages
         * @param callbackMethod event handler function  function (ev) { }
         * @param useCapture
         */
        function fnEventDefinition(element, eventFullName, callbackMethod, useCapture) {
            eventFullName = eventFullName || "";
            if (eventFullName.indexOf("on") == 0)
                eventFullName = eventFullName.substr(2);
            var arr = eventFullName.split('.');
            return {
                /** DOM element */
                element: element,
                /** full name with namespaces after dot, eg: click.state-one.all-states, used for removal by name */
                eventFullName: eventFullName,
                /** event type string, without namespace, eg. click or focus */
                type: arr.shift(),
                /** namespaces, array split by */
                namespaces: arr,
                /** event handler function  function (ev) { } */
                callbackFunc: callbackMethod,
                /** function to remove event, function(){ } */
                removeEvent: () => { },
                /** use capture, true/false */
                useCapture: !!useCapture,
                /** passive, true/false */
                passive: false
            };
        }
        ;
        function Attach(element, eventFullName, callbackMethod, useCapture) {
            ///<summary>Attach event</summary>
            ///<param name="element" type="Object">Object to attach event to</param>
            ///<param name="eventFullName" type="String">Event type or namespace or type and namespace (click.ns1.ns2)</param>
            ///<param name="callbackMethod" type="Function">Callback delegate function(event){...}</param>
            ///<param name="useCapture" type="Boolean" optional="true">if false, inner element event has precedence</param>
            // parse argument for namespaces
            var obj1 = fnEventDefinition(element, eventFullName, callbackMethod, useCapture);
            if (!obj1.element)
                throw new Error("element is required");
            if (!obj1.type)
                throw new Error("eventFullName is required");
            if (!obj1.callbackFunc)
                throw new Error("callbackMethod is required");
            // ***************************************************
            // create object for tracking
            if (!obj1.element.$$calysto_EventsArr)
                obj1.element.$$calysto_EventsArr = [];
            obj1.element.$$calysto_EventsArr.push(obj1);
            // create removal function for removig the event listener from element
            obj1.removeEvent = () => {
                obj1.element.$$calysto_EventsArr.Remove(obj1);
                if (!obj1.element.$$calysto_EventsArr.Any())
                    delete (obj1.element.$$calysto_EventsArr);
                fnDetachNativeEvent(obj1);
            };
            // ***************************************************
            // attach native event
            if (obj1.element.addEventListener) {
                obj1.element.addEventListener(obj1.type, obj1.callbackFunc, obj1.useCapture);
            }
            else if (obj1.element.attachEvent) {
                obj1.element.attachEvent("on" + obj1.type, obj1.callbackFunc, obj1.useCapture);
            }
            else {
                throw new Error("Attaching event is not supported");
            }
            return obj1;
        }
        Event.Attach = Attach;
        ;
        function fnGetListeners(element, eventFullName, callbackMethod, useCapture) {
            ///<summary>Get listeners by condition</summary>
            ///<param name="element" type="Element">Element</param>
            ///<param name="eventFullName" type="String" optional="true">Event type or namespace or type and namespace (click.ns1.ns2)</param>
            ///<param name="callbackMethod" type="Function" optional="true">Callback delegate</param>
            ///<param name="useCapture" type="Boolean" optional="true">if false, inner element event has precedence</param>
            ////#if INTE LLISENSE
            //if (Calysto.IsVSIntellisense)
            //{
            //	return [fnEventDefinition(), fnEventDefinition()];
            //}
            ////#endif
            if (!eventFullName) {
                return element.$$calysto_EventsArr; // include all listeners
            }
            var conditionObj1 = fnEventDefinition(element, eventFullName, callbackMethod, useCapture);
            if (!conditionObj1.element.$$calysto_EventsArr)
                return [];
            return conditionObj1.element.$$calysto_EventsArr.Where((o) => {
                return (!conditionObj1.type || conditionObj1.type == o.type)
                    && (!conditionObj1.callbackFunc || conditionObj1.callbackFunc == o.callbackFunc)
                    && (conditionObj1.namespaces.length == 0 || (conditionObj1.namespaces.AsEnumerable().All(function (ns1) { return o.namespaces.Contains(ns1); })));
            });
        }
        function Detach(element, eventFullName, callbackMethod, useCapture) {
            ///<summary>Detach event, select by any condition provided</summary>
            ///<param name="element" type="Object">Object to detach event from</param>
            ///<param name="eventFullName" type="String" optional="true">Event type or namespace or type and namespace (click.ns1.ns2)</param>
            ///<param name="callbackMethod" type="Function" optional="true">Callback delegate</param>
            ///<param name="useCapture" type="Boolean" optional="true">if false, inner element event has precedence</param>
            // detach monitored events
            var listeners = fnGetListeners(element, eventFullName, callbackMethod, useCapture);
            if (listeners)
                listeners.ForEach(o => o.removeEvent());
            // detach any other event not monitored by $$calysto_EventsArr
            var obj1 = fnEventDefinition(element, eventFullName, callbackMethod, useCapture);
            fnDetachNativeEvent(obj1);
        }
        Event.Detach = Detach;
        function fnDetachNativeEvent(obj1) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="obj1" type="fnEventDefinition"></param>
            if (obj1.element.removeEventListener) {
                obj1.element.removeEventListener(obj1.type, obj1.callbackFunc, obj1.useCapture);
            }
            else if (obj1.element.detachEvent) {
                obj1.element.detachEvent("on" + obj1.type, obj1.callbackFunc, obj1.useCapture);
            }
            else {
                throw new Error("Dettaching event is not supported");
            }
        }
        ;
        function GetTarget(event) {
            ///<summary>Returns source element</summary>
            ///<param name="obj" type="Object">Event object</param>
            return event.target || event.srcElement;
        }
        Event.GetTarget = GetTarget;
        ;
        function StopPropagation(event, doStop) {
            /// <summary>
            /// Set event state to prevent event propagation. iPhone reuses event so, we have to be able to stop and to continue propagation.
            /// </summary>
            /// <param name="event" type="Event"></param>
            /// <param name="doStop" type="Boolean">true to stop, false to propagate</param>
            // prevent execution if handler method returns false
            if (!!doStop) {
                if (event.preventDefault) {
                    event.preventDefault();
                }
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
            }
            event.returnValue = !doStop;
            event.cancelBubble = !!doStop;
        }
        Event.StopPropagation = StopPropagation;
        function GetOffsetToTarget(event) {
            /// <summary>
            /// Mouse event relative positions to target element. Returns {offsetX:..., offsetY:...}. Firefox doesn't have offsetX,Y, so, take layerX, layerY.
            /// </summary>
            /// <param name="event"></param>
            return {
                offsetX: "offsetX" in event ? event.offsetX : "layerX" in event ? event["layerX"] : NaN,
                offsetY: "offsetY" in event ? event.offsetY : "layerY" in event ? event["layerY"] : NaN
            };
        }
        Event.GetOffsetToTarget = GetOffsetToTarget;
        function IsLeftMouseButton(event) {
            ///<summary>Returns event source element</summary>
            ///<param name="obj" type="Object">Event object</param>
            // mouse button:
            // IE : 1=left down, 2=right down, 4=middle down
            // Chrome, FF, Safari: 0=left down or up, 2=right down, 1=middle down or up
            // right button is alway 2 on all browsers
            if (!!window.attachEvent) {
                return event.button === 0 || event.button === 1; // left down = 1, left up = 0
            }
            else if (!!window.addEventListener) {
                return event.button === 0; // non ie browsers: 0 up or down
            }
            return false;
        }
        Event.IsLeftMouseButton = IsLeftMouseButton;
        ;
        function IsRightMouseButton(event) {
            ///<summary>Returns event source element</summary>
            ///<param name="obj" type="Object">Event object</param>
            // mouse button:
            // IE: 1=left, 2=right, 4=middle
            // Chrome, FF, Safari: 0=left, 2=right, 1=middle
            return event.button === 2;
        }
        Event.IsRightMouseButton = IsRightMouseButton;
        ;
        function IsMiddleMouseButton(event) {
            ///<summary>Returns event source element</summary>
            ///<param name="obj" type="Object">Event object</param>
            // mouse button:
            // IE: 1=left, 2=right, 4=middle
            // Chrome, FF, Safari: 0=left, 2=right, 1=middle
            if (!!window.attachEvent) {
                return event.button === 4;
            }
            else if (!!window.addEventListener) {
                return event.button === 1;
            }
            return false;
        }
        Event.IsMiddleMouseButton = IsMiddleMouseButton;
        ;
        function IsAnyMouseButton(event) {
            return event && (event.button === 0 || event.button > 0);
        }
        Event.IsAnyMouseButton = IsAnyMouseButton;
        ;
        function IsEnterKey(event) {
            /// <summary>
            /// Test if key or char is ENTER.
            /// </summary>
            /// <param name="event" type="Char|Event"></param>
            return event && (event.keyCode == 10 || event.keyCode == 13); // CTRL + enter (ie = 10, ff = 13)
        }
        Event.IsEnterKey = IsEnterKey;
        ;
        function IsCtrlKey(event) {
            return event && event.ctrlKey ? true : false;
        }
        Event.IsCtrlKey = IsCtrlKey;
        ;
        function IsShiftKey(event) {
            return event && event.shiftKey ? true : false;
        }
        Event.IsShiftKey = IsShiftKey;
        ;
        function IsEscKey(event) {
            return event && event.keyCode == 27;
        }
        Event.IsEscKey = IsEscKey;
        ;
        function IsHoverChanged(element, ev, isHover) {
            /// <summary>
            /// Test first mouseover or mouseout to element.<br/>
            /// If mouse moves from element to its child or back, there is no hover state change, return false.
            /// </summary>
            /// <param name="element"></param>
            /// <param name="event"></param>
            /// <param name="isHover">hover state to be tested. true: test if mouseover occured, false: test if mouseout ocured</param>
            ev = ev || window.event; // old IE doesn't send event
            // if comes from toolbar or goes to toolbar, relTarget is null
            var relTarget = (isHover ? ev["fromElement"] : ev["toElement"]) || ev.relatedTarget;
            if (element != relTarget && !Calysto.Utility.Dom.IsDescendant(relTarget, element)) {
                // mouse enter or exit to element
                return true;
            }
            return false;
        }
        Event.IsHoverChanged = IsHoverChanged;
        ;
        /*
        event dispatch
        http://stackoverflow.com/questions/1225798/javascript-programmatically-invoking-events
    
        For IE:
        document.getElementById("thing_with_mouseover_handler").fireEvent("onmouseover");
        See the MSDN library for more info.
    
        For the real browsers:
        var event = document.createEvent("MouseEvent");
        event.initMouseEvent("mouseover", true, true, window);
        document.getElementById("thing_with_mouseover_handler").dispatchEvent(event);
        */
        // inheritance:
        // Object -> Event -> UIEvent -> MouseEvent | KeyboardEvent
        function DispatchEvent(el, ev) {
            /// <summary>
            /// Dispatch event or event type on element el.
            /// </summary>
            /// <param name="el" type="HTMLDivElement"></param>
            /// <param name="event" type="MouseEvent|KeyboardEvent|String">Event object or string event type name</param>
            if (typeof (ev) == "string") {
                var evType = ev;
                if (evType.indexOf("on") == 0)
                    evType = evType.substr(2); // remove on
                if (el.dispatchEvent) {
                    if (evType.Contains("mouse") || evType.Contains("click")) {
                        var ev1 = document.createEvent("MouseEvent");
                        ev1.initEvent(evType, false, true);
                        el.dispatchEvent(ev1);
                        return;
                    }
                    else if (evType.Contains("key")) {
                        var ev2 = document.createEvent("KeyboardEvent");
                        ev2.initEvent(evType, false, true);
                        el.dispatchEvent(ev2);
                        return;
                    }
                    else {
                        var ev3 = document.createEvent("Event");
                        ev3.initEvent(evType, false, true);
                        el.dispatchEvent(ev3);
                        return;
                    }
                }
                else if (el.fireEvent) {
                    el.fireEvent("on" + evType);
                    return;
                }
            }
            else if (el.dispatchEvent) {
                el.dispatchEvent(ev);
                return;
            }
            else if (el.fireEvent) {
                el.fireEvent("on" + ev.type);
                return;
            }
            throw new Error("Not supported dispatchEvent: " + ev);
        }
        Event.DispatchEvent = DispatchEvent;
    })(Event = Calysto.Event || (Calysto.Event = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Html;
        (function (Html) {
            function RemoveHtmlTags(html, replacement = "") {
                var re = new RegExp("\\<[^\\>]+\\>");
                while (html.match(re) != null) {
                    html = html.replace(re, replacement || "");
                }
                return html;
            }
            Html.RemoveHtmlTags = RemoveHtmlTags;
            function ExtractAspNameOrId(aspNetIdOrName) {
                // include asp.net id: page$sub$txtName or page_sub_txtName
                if (aspNetIdOrName) {
                    let n2 = aspNetIdOrName.lastIndexOf("_");
                    if (n2 > 0) {
                        return aspNetIdOrName.substr(n2 + 1);
                    }
                    let n1 = aspNetIdOrName.lastIndexOf("$");
                    if (n1 > 0) {
                        return aspNetIdOrName.substr(n1 + 1);
                    }
                    return aspNetIdOrName;
                }
                return undefined;
            }
            Html.ExtractAspNameOrId = ExtractAspNameOrId;
            function UrlEncode(str) {
                //return escape(Calysto.Utility.Encoding.StringEncoder.EncodeUTF8(string)); // will not encode right slash in http://something
                return encodeURIComponent(Calysto.Utility.Encoding.Utf8CharsEncoder.EncodeUTF8(str)); // will encode right slash in http://something
            }
            Html.UrlEncode = UrlEncode;
            ;
            function UrlDecode(str) {
                //return Calysto.Utility.Encoding.StringEncoder.DecodeUTF8(unescape(string));
                return Calysto.Utility.Encoding.Utf8CharsEncoder.DecodeUTF8(decodeURIComponent(str));
            }
            Html.UrlDecode = UrlDecode;
            ;
            function HtmlEncodeSimple(html) {
                return html.replace(new RegExp("<", "g"), "&lt;").replace(new RegExp(">", "g"), "&gt;");
            }
            Html.HtmlEncodeSimple = HtmlEncodeSimple;
            ;
            function HtmlDecodeSimple(html) {
                return html.replace(new RegExp("&lt;", "g"), "<").replace(new RegExp("&gt;", "g"), ">");
            }
            Html.HtmlDecodeSimple = HtmlDecodeSimple;
            ;
            //#region html encode & decode
            let map = {
                "&": "&amp;",
                "'": "&#39;",
                '"': "&quot;",
                "<": "&lt;",
                ">": "&gt;",
                "\r": "&#13",
                "\n": "&#10",
            };
            let mapReStr;
            let reversedMap;
            let reversedReStr;
            function HtmlEncode(html) {
                if (!html)
                    return "";
                if (!mapReStr) {
                    let arr1 = [];
                    for (let prop in map) {
                        arr1.push("(" + RegExp.Escape(prop) + ")");
                    }
                    mapReStr = arr1.join("|");
                }
                return html.replace(new RegExp(mapReStr, 'g'), (a, b) => {
                    return map[a];
                });
            }
            Html.HtmlEncode = HtmlEncode;
            function HtmlDecode(html) {
                if (!html)
                    return "";
                if (!reversedMap) {
                    reversedMap = {};
                    let arr1 = [];
                    for (let prop in map) {
                        reversedMap[map[prop]] = prop;
                        arr1.push("(" + RegExp.Escape(map[prop]) + ")");
                    }
                    reversedReStr = arr1.join("|");
                }
                return html.replace(new RegExp(reversedReStr, "g"), (a, b) => {
                    return reversedMap[a];
                });
            }
            Html.HtmlDecode = HtmlDecode;
            function StringToHtml(str, htmlEncode) {
                if (String.IsNullOrEmpty(str)) {
                    return str;
                }
                else {
                    str = str.ReplaceAll("\r\n", "\n").ReplaceAll("\r", "");
                    if (htmlEncode) {
                        return str.Split('\n').Select(row => HtmlEncode(row)).ToStringJoined("<br/>");
                    }
                    else {
                        return str.ReplaceAll("\n", "<br/>");
                    }
                }
            }
            Html.StringToHtml = StringToHtml;
            //#endregion
            //#region JavaScript encode
            const escapeeChars = {
                "\b": '\\b',
                "\t": '\\t',
                "\n": '\\n',
                "\f": '\\f',
                "\r": '\\r',
                '"': '\\"',
                "\\": '\\\\'
            };
            function JavaScriptStringEncode(str) {
                return str.replace(new RegExp('([\\\\\x00-\x1f\\"])', 'g'), (a, b) => {
                    var c = escapeeChars[b];
                    if (c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return "\\u00" +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                });
            }
            Html.JavaScriptStringEncode = JavaScriptStringEncode;
            //#endregion
            //#region JS & CSS minify
            /**
             * Minify JS or CSS content.
             * @param jscode content string
             * @param kind default Full
             */
            function Minify(jscode, kind = "Full") {
                //remove /* */ comments
                // obavezno [\\w\\W], ne .*? jer tocka nece selektirati neke unicode charove
                jscode = new Calysto.Regex(Calysto.Regex.Escape("/*") + "[\\w\\W]*?" + Calysto.Regex.Escape("*/")).Replace(jscode, " ");
                if (kind == "Full") {
                    // remove any space including tab, new line, space...
                    jscode = new Calysto.Regex("[\\s]+").Replace(jscode, " ");
                    // remove space near to symbols // don't use it, it breaks css, must have space between css class names, e.g.: solid 1px red, :nth-child(1) :first-child, itd.
                    //jscode = Regex.Replace(jscode, @"[ ]*([\;\{\}\[\]\(\)\:\,\=\-\+\*\/\<\>]+)[ ]*", "$1");
                    jscode = new Calysto.Regex(`[ ]*([\\;\\{\\}\\,]+)[ ]*`).Replace(jscode, "$1"); // tested, ok, don't use : because of: :nth-child(1) :first-child
                    let re2 = new RegExp(`\\{[^\\}]+\\}`, "ig");
                    let re3 = new RegExp(`[ ]*([\\:])[ ]*`, "ig");
                    jscode = jscode.replace(re2, substr => {
                        return substr.replace(re3, ":");
                    });
                    return jscode.TrimStart();
                }
                return jscode;
            }
            Html.Minify = Minify;
            //#endregion
        })(Html = Utility.Html || (Utility.Html = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Encoding;
        (function (Encoding) {
            /*
            // RFC JavaScript table 36 Calysto extended to 64
            // this data are create in FileCompiler.s to be 100% the same with C# data
            export var Base64CharsTable = {
                
                // 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_!~
                JavaScriptRFCTable64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_!-", // acceptable for url: ~ ! - _ ( )
                
                // ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
                StandardBase64RFC: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                
                RandomRFCTable64: ""
            };
            Base64CharsTable.RandomRFCTable64 = Base64CharsTable.JavaScriptRFCTable64;
            */
            var _a, _b;
            let Base64CharsTable = Calysto.Constants.BaseXCharsTable;
            let Utf8CharsEncoder;
            (function (Utf8CharsEncoder) {
                /**
                 * Encode chars in string into utf chars string
                 * @param str
                 */
                function EncodeUTF8(str) {
                    /// <summary>
                    /// Encode chars in string into utf chars string.
                    /// </summary>
                    /// <param name="string"></param>
                    str = str.replace(new RegExp("\r\n", "g"), "\n");
                    var utftext = "";
                    for (var n = 0; n < str.length; n++) {
                        var c = str.charCodeAt(n);
                        if (c < 128) {
                            utftext += String.fromCharCode(c);
                        }
                        else if ((c > 127) && (c < 2048)) {
                            utftext += String.fromCharCode((c >> 6) | 192);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                        else {
                            utftext += String.fromCharCode((c >> 12) | 224);
                            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                    }
                    return utftext;
                }
                Utf8CharsEncoder.EncodeUTF8 = EncodeUTF8;
                /**
                 * Decore utf chars string into string
                 * @param utftext
                 */
                function DecodeUTF8(utftext) {
                    /// <summary>
                    /// Decore utf chars string into string.
                    /// </summary>
                    /// <param name="utftext"></param>
                    var string = "";
                    var i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;
                    while (i < utftext.length) {
                        c = utftext.charCodeAt(i);
                        if (c < 128) {
                            string += String.fromCharCode(c);
                            i++;
                        }
                        else if ((c > 191) && (c < 224)) {
                            c2 = utftext.charCodeAt(i + 1);
                            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                            i += 2;
                        }
                        else {
                            c2 = utftext.charCodeAt(i + 1);
                            c3 = utftext.charCodeAt(i + 2);
                            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                            i += 3;
                        }
                    }
                    return string;
                }
                Utf8CharsEncoder.DecodeUTF8 = DecodeUTF8;
            })(Utf8CharsEncoder = Encoding.Utf8CharsEncoder || (Encoding.Utf8CharsEncoder = {}));
            let UTF8;
            (function (UTF8) {
                function GetBytes(str) {
                    var input = Utf8CharsEncoder.EncodeUTF8(str);
                    var arr = [];
                    for (var n = 0; n < input.length; n++) {
                        arr.push(input.charCodeAt(n));
                    }
                    return arr;
                }
                UTF8.GetBytes = GetBytes;
                ;
                function GetString(arr) {
                    var chars = [];
                    for (var n = 0; n < arr.length; n++) {
                        chars.push(String.fromCharCode(arr[n]));
                    }
                    return Utf8CharsEncoder.DecodeUTF8(chars.join(""));
                }
                UTF8.GetString = GetString;
                ;
            })(UTF8 = Encoding.UTF8 || (Encoding.UTF8 = {}));
            class CalystoBaseConverter {
                constructor(charsTable = Base64CharsTable.JavaScriptRFCTable64) {
                    this.charsTable = charsTable;
                }
                ConvertBytes(bytes, fromBits, toBits) {
                    var result = [];
                    var buffer = 0;
                    var buffLen = 0;
                    var mask = (Math.pow(2, toBits) - 1);
                    var doShift = false;
                    for (var n = 0; n < bytes.length; n++) {
                        var bb = bytes[n];
                        // push into buffer
                        if (doShift) {
                            buffer = buffer << fromBits;
                        }
                        else {
                            doShift = true;
                        }
                        buffer = buffer | bb;
                        buffLen += fromBits;
                        // pop from buffer
                        while (buffLen >= toBits) {
                            result.push(((buffer >> (buffLen - toBits)) & mask));
                            buffLen -= toBits;
                        }
                    }
                    while (buffLen >= toBits) {
                        result.push(((buffer >> (buffLen - toBits)) & mask));
                        buffLen -= toBits;
                    }
                    // used when converting to smaller amount of bits
                    // when converting to greater amount of bits, then reminder bytes should be ignored
                    while (buffLen > 0 && fromBits > toBits) {
                        result.push(((buffer << (toBits - buffLen)) & mask));
                        buffLen -= toBits;
                    }
                    return result;
                }
                Convert(bytes, fromBits, toBits) {
                    if (!fromBits || (fromBits != 8 && (fromBits < 1 || fromBits > 6))) {
                        throw Error(fromBits + " is invalid value. fromBits can be in range [1-6] or 8");
                    }
                    if (!toBits || (toBits != 8 && (toBits < 1 || toBits > 6))) {
                        throw Error(toBits + " is invalid value. toBits can be in range [1-6] or 8");
                    }
                    var convertedEnumerable = this.ConvertBytes(bytes, fromBits, toBits);
                    if (this.charsTable != Base64CharsTable.StandardBase64RFC) {
                        return convertedEnumerable;
                    }
                    else {
                        // standard base64 RFC uses padding at the end
                        if (fromBits == 8 && toBits == 6) {
                            // encoding
                            if (bytes.length % 3 > 0) {
                                // if using standard Base64 RFC table, use padding
                                var pad = 3 - bytes.length % 3;
                                var alignmentCharIndex = (this.charsTable.length - 1);
                                while (pad > 0) {
                                    pad--;
                                    convertedEnumerable.push(alignmentCharIndex);
                                }
                            }
                        }
                        else if (fromBits == 6 && toBits == 8) {
                            // decoding
                            // count alignment chars
                            var alignmentCharIndex = (this.charsTable.length - 1);
                            var cnt = 0;
                            var len = bytes.length;
                            while (cnt < len && (bytes[len - 1 - cnt] == alignmentCharIndex)) {
                                cnt++;
                            }
                            var take = convertedEnumerable.length - cnt;
                            convertedEnumerable = convertedEnumerable.slice(0, take);
                        }
                    }
                    return convertedEnumerable;
                }
                EncodeToBaseString(data, toBits) {
                    /// <summary>
                    /// <para>Convert string or array of chars or 8-bits based items to base(toBits) string using.</para>
                    /// <para>Use Calysto.Utility.UTF8.GetBytes() and Calysto.Utility.UTF8.GetString() to converto from or to arrayOrString</para>
                    /// </summary>
                    /// <param name="data">byte[] or string</param>
                    /// <param name="toBits">1-6</param>
                    /// <returns type="">baseString</returns>
                    if (typeof (data) == "string") {
                        // convert to array
                        data = UTF8.GetBytes(data);
                    }
                    var arr = this.Convert(data, 8, toBits);
                    var sb = [];
                    for (var n = 0; n < arr.length; n++) {
                        sb.push(this.charsTable.charAt(arr[n]));
                    }
                    return sb.join("");
                }
                ;
                DecodeBaseStringToArray(baseString, fromBits) {
                    /// <summary>
                    /// <para>Convert base(fromBits) encoded string to aray of 8-bits based items using.</para>
                    /// <para>Use Calysto.Utility.UTF8.GetBytes() and Calysto.Utility.UTF8.GetString() to converto from or to array</para>
                    /// </summary>
                    /// <param name="baseString">string</param>
                    /// <param name="fromBits">1-6</param>
                    /// <returns type="">byte[]</returns>
                    var arr = [];
                    for (var n = 0; n < baseString.length; n++) {
                        arr.push(this.charsTable.indexOf(baseString.charAt(n)));
                    }
                    return this.Convert(arr, fromBits, 8);
                }
                ;
                DecodeBaseStringToString(baseString, fromBits) {
                    return UTF8.GetString(this.DecodeBaseStringToArray(baseString, fromBits));
                }
                ;
            }
            Encoding.CalystoBaseConverter = CalystoBaseConverter;
            class CalystoHexConverter {
                constructor() {
                    this.converter = new CalystoBaseConverter(); // use JavaScriptRFCTable64
                }
                EncodeToHexString(data) {
                    return this.converter.EncodeToBaseString(data, 4);
                }
                DecodeHexStringToArray(hexString) {
                    /// <summary>
                    /// Convert base(fromBits) encoded string to aray of 8-bits based items. Returns array of bytes.
                    /// </summary>
                    /// <param name="hexString"></param>
                    return this.converter.DecodeBaseStringToArray(hexString, 4);
                }
                DecodeHexStringToString(hexString) {
                    /// <summary>
                    /// Decode str from base64 using current chars table. Returns raw string.
                    /// </summary>
                    /// <param name="hexString">base64 encoded string</param>
                    return this.converter.DecodeBaseStringToString(hexString, 4);
                }
            }
            Encoding.HEX = new CalystoHexConverter();
            class CalystoBase64EncoderImpl {
                constructor(charsTable) {
                    this.converter = new CalystoBaseConverter(charsTable);
                }
                EncodeToBase64String(data) {
                    /// <summary>
                    /// Encode str to base64 using table or RFC base64 table. Returns base64 encoded string.
                    /// </summary>
                    /// <param name="rawStr" type="type"></param>
                    return this.converter.EncodeToBaseString(data, 6);
                }
                DecodeBase64StringToArray(base64str) {
                    /// <summary>
                    /// Decode str from base64 using current chars table. Returns raw string.
                    /// </summary>
                    /// <param name="str">base64 encoded string</param>
                    return this.converter.DecodeBaseStringToArray(base64str, 6);
                }
                DecodeBase64StringToString(base64str) {
                    /// <summary>
                    /// Decode str from base64 using current chars table. Returns raw string.
                    /// </summary>
                    /// <param name="str">base64 encoded string</param>
                    return this.converter.DecodeBaseStringToString(base64str, 6);
                }
            }
            /** Standard base64 encoder*/
            Encoding.RfcBase64 = new CalystoBase64EncoderImpl(Base64CharsTable.StandardBase64RFC);
            /** Calysto base64 encoder for urls */
            Encoding.CalystoBase64 = new CalystoBase64EncoderImpl(Base64CharsTable.JavaScriptRFCTable64);
            Encoding.Base64RndEncoder = new CalystoBase64EncoderImpl(((_b = (_a = Calysto.Core) === null || _a === void 0 ? void 0 : _a.Constants) === null || _b === void 0 ? void 0 : _b.RandomRFCTable64) || Base64CharsTable.RandomRFCTable64);
        })(Encoding = Utility.Encoding || (Utility.Encoding = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Dom;
        (function (Dom) {
            class ScrollHandler {
                constructor() {
                    this._currDeltaY = 0;
                    this._currDeltaX = 0;
                }
                HandleScroll(sender, ev) {
                    //////#if DEBUG
                    ////if (Calysto.Core.IsDebugDefined)
                    ////{
                    ////	console.log(ev);
                    ////}
                    //////#endif
                    if (ev.deltaY || ev.deltaX) {
                        //WheelEvent.deltaMode Read only
                        //Returns an unsigned long representing the unit of the delta values scroll amount. Permitted values are:
                        //DOM_DELTA_PIXEL	0x00	The delta values are specified in pixels.
                        //DOM_DELTA_LINE	0x01	The delta values are specified in lines.
                        //DOM_DELTA_PAGE	0x02	The delta values are specified in pages.
                        let dy = ev.deltaY || 0;
                        let dx = ev.deltaX || 0;
                        if (ev.shiftKey) {
                            let t1 = dy;
                            dy = dx;
                            dx = t1;
                        }
                        switch (ev.deltaMode) {
                            case 0: // pixels, chrome
                                this._currDeltaY += dy;
                                this._currDeltaX += dx;
                                break;
                            case 1: // lines, firefox
                                this._currDeltaY += dy * 20; // 1 line = 20px, average
                                this._currDeltaX += dx * 20; // 1 line = 20px, average
                                break;
                            case 2:
                                this._currDeltaY += dy * window.screen.height;
                                this._currDeltaX += dx * window.screen.height;
                                break;
                        }
                        if (Math.abs(this._currDeltaY) > 10) {
                            // scroll has no deltaY
                            // apply scroll to sender
                            sender.scrollTop += this._currDeltaY;
                            this._currDeltaY = 0;
                        }
                        if (Math.abs(this._currDeltaX) > 10) {
                            // scroll has no deltaY
                            // apply scroll to sender
                            sender.scrollLeft += this._currDeltaX;
                            this._currDeltaX = 0;
                        }
                    }
                }
            }
            Dom.ScrollHandler = ScrollHandler;
            let NodeTypeEnum;
            (function (NodeTypeEnum) {
                NodeTypeEnum[NodeTypeEnum["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
                NodeTypeEnum[NodeTypeEnum["ATTRIBUTE_NODE"] = 2] = "ATTRIBUTE_NODE";
                NodeTypeEnum[NodeTypeEnum["TEXT_NODE"] = 3] = "TEXT_NODE";
                NodeTypeEnum[NodeTypeEnum["CDATA_SECTION_NODE"] = 4] = "CDATA_SECTION_NODE";
                NodeTypeEnum[NodeTypeEnum["ENTITY_REFERENCE_NODE"] = 5] = "ENTITY_REFERENCE_NODE";
                NodeTypeEnum[NodeTypeEnum["ENTITY_NODE"] = 6] = "ENTITY_NODE";
                NodeTypeEnum[NodeTypeEnum["PROCESSING_INSTRUCTION_NODE"] = 7] = "PROCESSING_INSTRUCTION_NODE";
                NodeTypeEnum[NodeTypeEnum["COMMENT_NODE"] = 8] = "COMMENT_NODE";
                NodeTypeEnum[NodeTypeEnum["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
                NodeTypeEnum[NodeTypeEnum["DOCUMENT_TYPE_NODE"] = 10] = "DOCUMENT_TYPE_NODE";
                NodeTypeEnum[NodeTypeEnum["DOCUMENT_FRAGMENT_NODE"] = 11] = "DOCUMENT_FRAGMENT_NODE";
                NodeTypeEnum[NodeTypeEnum["NOTATION_NODE"] = 12] = "NOTATION_NODE";
            })(NodeTypeEnum = Dom.NodeTypeEnum || (Dom.NodeTypeEnum = {}));
            function TrimSpaces(str) {
                if (!str) {
                    return str;
                }
                return (str || "").replace(new RegExp("(^[\\s]+)|([\\s]+$)", "ig"), "");
            }
            Dom.TrimSpaces = TrimSpaces;
            //#region DOM utility methods
            /**
             * Return element id. If doesn't exist, will create new id.
             * @param el
             */
            function EnsureElementId(el) {
                if (typeof el == "string")
                    return el;
                else if (el.id)
                    return el.id;
                else
                    return (el.id = Calysto.Utility.Generators.GenerateLabel(20));
            }
            Dom.EnsureElementId = EnsureElementId;
            /**
             * test if element is visible in DOM, using style.display and offsetHeight and offsetWidht
             * @param element
             */
            function IsElementVisible(element) {
                var el = element;
                return !!(el && el.parentNode && el.offsetWidth > 0 && el.offsetHeight > 0 && el.style && el.style.display != "none");
            }
            Dom.IsElementVisible = IsElementVisible;
            /**
             * Returns true if el is in DOM. Traverse complete DOM tree from element to document root.
             * @param element
             */
            function IsElementInDom(element) {
                // seems that offsetParent property have elements with real dimensions and real visibility in dom, e.g. div element
                // link, #text nodes etc. don't have offsetParent property, or is null or undefined
                // offsetParent is quicker way to traverse up on the DOM tree, but we always have to use parentNode as backup
                var tmp = element;
                while (tmp
                    && tmp != document
                    && (tmp = (tmp.offsetParent || tmp.parentNode))) {
                    // use offsetParent to find offset ancestor, it is less iterations thant with parentNode which finds first parent
                }
                return tmp == document; // el is in dom if tmp == document
            }
            Dom.IsElementInDom = IsElementInDom;
            ;
            /**
             * Test if el is child or descendant of parent or ancestor.
             * @param element
             * @param parent
             */
            function IsDescendant(element, parent) {
                var el = element;
                if (!el || !parent || el == parent) {
                    return false;
                }
                while (el && el != parent) {
                    try {
                        el = el.parentNode;
                    }
                    catch (e) {
                        return false;
                    }
                }
                return el == parent;
            }
            Dom.IsDescendant = IsDescendant;
            ;
            /**
             * Get innerText or innerHtml with removed html tags or nodeValue.
             * @param element
             */
            function GetInnerText(element) {
                var el = element;
                if (!el)
                    return "";
                var val = "innerText" in el ? el.innerText :
                    "innerHTML" in el ? Calysto.Utility.Html.RemoveHtmlTags(el.innerHTML, "") :
                        "nodeValue" in el ? el.nodeValue :
                            el.value || ""; // force to return "" if all values are empty or null
                return val + ""; // make sure it is string
            }
            Dom.GetInnerText = GetInnerText;
            function HasTagName(obj, tagName) {
                if (obj && obj.tagName && obj.tagName.toLowerCase() == tagName.toLowerCase()) {
                    return true;
                }
                return false;
            }
            Dom.HasTagName = HasTagName;
            //#endregion
            //#region positions calculation: element, page, viewport position
            var _fixedDiv;
            function GetViewportDiv() {
                if (!_fixedDiv) {
                    // more secure way is to create fixed div and mesure it's dimmension: <div style='position:fixed;top:0;left:0;bottom:0;right:0;z-index:-100000;'></div>
                    var tmp = document.createElement("div");
                    tmp.innerHTML = "<div id='calystoViewportSizeDiv' style='position:fixed;top:0;left:0;bottom:0;right:0;z-index:-10000000;'></div>";
                    _fixedDiv = tmp.childNodes[0];
                    (document.body || document.documentElement).appendChild(_fixedDiv);
                }
                return _fixedDiv;
            }
            Dom.GetViewportDiv = GetViewportDiv;
            /**
             * Get element's position relative to visible viewport. {top:n, left:n, width:n, height:d}.
             * Position is measured from top left corner.
             * Bottom and right values are confusing. It is value from top left corner to the bottom or right side of element, not from bottom of the page.
             * @param element
             */
            function GetElementScreenPosition(element) {
                var tmpEl = element;
                if (tmpEl.getBoundingClientRect) {
                    return tmpEl.getBoundingClientRect(); // getBoundingClientRect() returns element position on screen
                }
                else {
                    var el = element;
                    var result = {
                        left: 0,
                        top: 0,
                        bottom: 0,
                        right: 0,
                        width: tmpEl.offsetWidth,
                        height: tmpEl.offsetHeight
                    };
                    do {
                        result.left += (tmpEl.offsetLeft || 0) - (tmpEl.scrollLeft || 0); // document nema offsetLeft i scrollLeft, zapravo je undefined i NaN, zato || 0
                        result.top += (tmpEl.offsetTop || 0) - (tmpEl.scrollTop || 0);
                        if (tmpEl.style && (tmpEl.style.position == "fixed" || GetComputedStyleDeclaration(tmpEl).position == "fixed")) {
                            // if it is fixed element, take any of: offsetLeft i offsetTop i scrollLeft i scrollTop and stop climbing up in DOM
                            break;
                        }
                        else {
                            tmpEl = (tmpEl.offsetParent || tmpEl.parentNode); // preferiramo offsetParent, body ima samo parentNode
                        }
                    } while (tmpEl);
                    return result;
                }
            }
            Dom.GetElementScreenPosition = GetElementScreenPosition;
            ;
            /**
             * Get element's absolute position on page. {top:n, left:n, width:n, height:d}.
             * @param element
             */
            function GetElementPagePosition(element) {
                var pos = GetElementScreenPosition(element);
                // add page scrolls
                var page = GetPageDimensions();
                return {
                    left: pos.left + page.scrollLeft,
                    top: pos.top + page.scrollTop,
                    width: pos.width,
                    height: pos.height
                };
            }
            Dom.GetElementPagePosition = GetElementPagePosition;
            function GetScrollableAncestors(el) {
                let arr = [];
                let tmp1 = el;
                let stop = 0;
                let sleft = 0;
                while ((tmp1 = tmp1.parentNode)) {
                    stop = tmp1.scrollTop;
                    sleft = tmp1.scrollTop;
                    if (tmp1.scrollTop > 0 || tmp1.scrollTop > 0) {
                        arr.push(tmp1);
                        continue;
                    }
                    ++tmp1.scrollTop;
                    if (tmp1.scrollTop == stop + 1) {
                        --tmp1.scrollTop;
                        arr.push(tmp1);
                        continue;
                    }
                    --tmp1.scrollTop;
                    if (tmp1.scrollTop == stop - 1) {
                        ++tmp1.scrollTop;
                        arr.push(tmp1);
                        continue;
                    }
                    ++tmp1.scrollLeft;
                    if (tmp1.scrollLeft == sleft + 1) {
                        --tmp1.scrollLeft;
                        arr.push(tmp1);
                        continue;
                    }
                    --tmp1.scrollLeft;
                    if (tmp1.scrollLeft == sleft - 1) {
                        ++tmp1.scrollLeft;
                        arr.push(tmp1);
                        continue;
                    }
                }
                return arr;
            }
            Dom.GetScrollableAncestors = GetScrollableAncestors;
            /**
             * Get current html page scroll dimensions as object: {scrollLeft:.., scrollTop:..., scrollWidth:..., scrollHeight:..., clientWidth:..., clientHeight:...}
             * scrollHeight: full height including scroll
             * scrollWidth: full width including scroll
            */
            function GetPageDimensions() {
                var dim = {
                    scrollLeft: Math.max(document.body.scrollLeft, document.documentElement.scrollLeft, window.pageXOffset || 0),
                    scrollTop: Math.max(document.body.scrollTop, document.documentElement.scrollTop, window.pageYOffset || 0),
                    scrollWidth: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth),
                    scrollHeight: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
                    clientWidth: GetViewportDiv().offsetWidth,
                    clientHeight: GetViewportDiv().offsetHeight // visible size
                };
                return dim;
            }
            Dom.GetPageDimensions = GetPageDimensions;
            /**
             * Test if element is in visible viewport.
             * @param el
             * @param onlyPart if true, at least 1 dimension must be included in viewport, if false, all dimensions must be included
             */
            function IsElementInViewport(el, onlyPart) {
                var pos = GetElementScreenPosition(el);
                var viewport = GetElementScreenPosition(GetViewportDiv());
                var top = pos.top >= viewport.top && pos.top <= (viewport.top + viewport.height);
                var bottom = (pos.top + pos.height) >= viewport.top && (pos.top + pos.height) <= (viewport.top + viewport.height);
                var left = pos.left >= viewport.left && pos.left <= (viewport.left + viewport.width);
                var right = (pos.left + pos.width) >= viewport.left && (pos.left + pos.width) <= (viewport.left + viewport.width);
                if (onlyPart) {
                    var w = pos.width <= viewport.width ? (left || right) : ((left && !right) || (!left && right) || (!left && !right && pos.left < viewport.left && (pos.left + pos.width) > viewport.left));
                    var h = pos.height <= viewport.height ? (top || bottom) : ((top && !bottom) || (!top && bottom) || (!top && !bottom && pos.top < viewport.top && (pos.top + pos.height) > viewport.top));
                    return w && h;
                }
                else {
                    return top && bottom && left && right;
                }
            }
            Dom.IsElementInViewport = IsElementInViewport;
            /**
            * Calculate element position compared to viewport position. Negative value means element is outside of viewport.
            * @param el
            */
            function GetElementToViewportPosition(el) {
                var pos = GetElementScreenPosition(el);
                var viewport = GetElementScreenPosition(GetViewportDiv());
                return {
                    left: pos.left - viewport.left,
                    top: pos.top - viewport.top,
                    bottom: (viewport.top + viewport.height) - (pos.top + pos.height),
                    right: (viewport.left + viewport.width) - (pos.left + pos.width)
                };
            }
            Dom.GetElementToViewportPosition = GetElementToViewportPosition;
            /**
             * Margins is Calysto specific, defines margin from top, right, bottom, left.
             * Rect is css standard, defined as left, right: from left, top, bottom: from top.
             * @param el
             * @param clipStyleString
             */
            function ParseClip(el, clipStyleString) {
                var m = clipStyleString.match(new RegExp("(rect|margins)[\\(][\\s]*([\\d\\+\\-px\\%]+)[\\s]+([\\d\\+\\-px\\%]+)[\\s]+([\\d\\+\\-px\\%]+)[\\s]+([\\d\\+\\-px\\%]+)[\\s]*[\\)]"));
                m = m || [];
                return ({
                    match: m,
                    useMargins: m && m[1] == "margins",
                    top: parseFloat(m[2]) || 0,
                    right: m[3] ? parseFloat(m[3]) : el.offsetWidth,
                    bottom: m[4] ? parseFloat(m[4]) : el.offsetHeight,
                    left: parseFloat(m[5]) || 0
                });
            }
            Dom.ParseClip = ParseClip;
            /**
             * Get element's current clip value.
             * clip: rect(0px 10px 100px 20px );
             * clip is always in px, all 4 values has to be set: top right bottom left
             * @param el
             */
            function GetClip(el) {
                return ParseClip(el, GetComputedStyle(el, "clip").StyleValue);
            }
            Dom.GetClip = GetClip;
            /**
             * Calculate clip. Used with animator.
             * @param el
             * @param newDim
             */
            function CalculateClip(el, newDim) {
                // Calysto clip value is different from css clip: has to be provided as string with 4 values "from top, from right, from bottom, from left", default unit is px, but % may be used
                // var arr = item.finalValue.split(new RegExp("[, ]")).AsEnumerable().Where(function (o) { return !!o; }).ToArray();
                // var final = { top: fromTop, right: fromRight, bottom: fromBottom, left: fromLeft };
                // css clip: rect(0px 10px 100px 20px );
                // clip is always in px, all 4 values has to be set: top right bottom left
                var curr = GetClip(el);
                var deltaDim;
                if (typeof (newDim) == "string") {
                    var mm = newDim.match(new RegExp("[\\d\\+\\-px\\%]+", "g"));
                    mm = mm || [];
                    // must use string values to include % if exists
                    deltaDim = {
                        top: mm[0],
                        right: mm[1],
                        bottom: mm[2],
                        left: mm[3],
                        useMargins: newDim.indexOf("margins") >= 0
                    };
                }
                else {
                    deltaDim = newDim;
                }
                if (deltaDim.useMargins) {
                    return ({
                        top: CalculateNumericValue(curr.top, deltaDim.top),
                        right: el.offsetWidth - CalculateNumericValue(curr.right, deltaDim.right),
                        bottom: el.offsetHeight - CalculateNumericValue(curr.bottom, deltaDim.bottom),
                        left: CalculateNumericValue(curr.left, deltaDim.left)
                    });
                }
                else {
                    return ({
                        top: CalculateNumericValue(curr.top, deltaDim.top),
                        right: CalculateNumericValue(curr.left, deltaDim.right),
                        bottom: CalculateNumericValue(curr.top, deltaDim.bottom),
                        left: CalculateNumericValue(curr.left, deltaDim.left)
                    });
                }
            }
            Dom.CalculateClip = CalculateClip;
            /**
             * Set clip. Not implemented.
             * @param el
             * @param clipValue e.g. already parsed into object or "margins(100% 0 0 0)" or "rect:(10px 100px 50px 53px)"
             */
            function SetClip(el, clipValue) {
                // this will add position:absolute to an element because clip requires absolute position
                // Calysto clip: "margins(fromTop  fromRight  fromBottom  fromLeft)"; // units none, px, %, +=...%, eg. .ToAnimator({ clip: "margins(100% 0 0 0)", marginTop: "-100%" })
                // css clip: "rect(fromTop fromLeftToRight fromTopToBottom fromLeft)// eg. ss clip: rect(0px 10px 100px 20px ); // always in px
                // Calysto clip value is different from css clip: has to be provided as string with 4 values "from top, from right, from bottom, from left", default unit is px, but % may be used
                throw new Error("Not implemeted: SetClip()");
                //if (typeof (clipValue) == "string")
                //{
                //	clipValue = this.CalculateClip(el, clipValue);
                //}
                //////console.log(clipValue);
                //// css clip: rect(0px 10px 100px 20px );
                //var cc = clipValue;
                //el.style.clip = "rect(" + cc.top + "px " + cc.right + "px " + cc.bottom + "px " + cc.left + "px" + ")";
                //el.style.position = "absolute";
                ////console.log(el.style.clip);
            }
            Dom.SetClip = SetClip;
            //#endregion
            //#region CSS class methods
            function HasClass(obj, cls) {
                return !!(obj && obj.className && cls && (' ' + obj.className + ' ').indexOf(' ' + (cls) + ' ') >= 0);
            }
            Dom.HasClass = HasClass;
            /**
             * Add css class, prevent duplicates.
             * @param obj
             * @param cls
             */
            function AddClass(obj, cls) {
                if (cls && obj) {
                    RemoveClass(obj, cls); // to prevent duplicates
                    obj.className = TrimSpaces(obj.className + " " + cls);
                }
            }
            Dom.AddClass = AddClass;
            /**
             * Remove class name or multiple class names.
             * @param obj
             * @param cls may contain multiple names separated by space
             */
            function RemoveClass(obj, cls) {
                if (cls && obj) {
                    // make sure className is not substring of some other className
                    // replace with space " " if class is inside other classes: cls1 cls2 cls3, replace " " + cls2 + " " with " "
                    var arr = cls.split(' ');
                    for (var n = 0; n < arr.length; n++) {
                        if (cls = arr[n]) {
                            obj.className = TrimSpaces((" " + obj.className + " ").replace(new RegExp(" " + cls + " ", "g"), " ")); // replace all matches of cls
                        }
                    }
                }
            }
            Dom.RemoveClass = RemoveClass;
            /**
             * Set exact cls value, removing all previous values.
             * @param obj
             * @param cls
             */
            function SetClass(obj, cls) {
                if (obj) {
                    obj.className = TrimSpaces(cls) || "";
                }
            }
            Dom.SetClass = SetClass;
            function ToggleClass(obj, cls) {
                if (obj && "className" in obj && cls) {
                    if (HasClass(obj, cls)) {
                        RemoveClass(obj, cls);
                    }
                    else {
                        AddClass(obj, cls);
                    }
                }
            }
            Dom.ToggleClass = ToggleClass;
            //#endregion
            //#region CSS style methods
            /**
             * Takes border-color and returns borderColor.
             * @param name
             */
            function ConvertCssNameToCamel(name) {
                var re = new RegExp("(([\\w]*)-([a-z]))|([^\\-]+)", "g");
                var exarr;
                var ss = "";
                while ((exarr = re.exec(name)) != null) {
                    ss += (exarr[2] || "") + (exarr[3] || "").toUpperCase() + (exarr[4] || "");
                }
                return ss;
            }
            Dom.ConvertCssNameToCamel = ConvertCssNameToCamel;
            /**
             * Takes borderColor and returns border-color.
             * @param name
             */
            function ConvertCssNameFromCamel(name) {
                var re = new RegExp("(([a-z]*)([A-Z]))|([\\w\\-]+)", "g");
                var exarr;
                var ss = "";
                while ((exarr = re.exec(name)) != null) // IE has "" if group not found, FF has undefined as default value in exarr
                 {
                    ss += (exarr[2] || "") + ((exarr[3] || "") != "" ? "-" + (exarr[3] || "").toLowerCase() : "") + (exarr[4] || "");
                }
                return ss;
            }
            Dom.ConvertCssNameFromCamel = ConvertCssNameFromCamel;
            /**
             * Set opacity.
             * @param element
             * @param value 0.0 - 1.0
             */
            function SetOpacity(element, value) {
                if (element && element.style) {
                    let numValue = typeof (value) == "string" ? parseFloat(value) : value;
                    if (numValue < 0)
                        numValue = 0;
                    else if (numValue > 1)
                        numValue = numValue / 100; // ako je poslan postotak do 100%
                    if (numValue > 1)
                        numValue = 1;
                    // chrome requires for opacity to be set, ie7 and ie8 requires filter to be set :(
                    // must test filter first, ie7 has opacity, but setting opacity value doesn't work
                    // must set both properties for compatibility
                    if ("opacity" in element.style) {
                        // opacity: 0...1
                        // default is "" which is equal to 1
                        // we have to set value 1 too, eg. if opacity is defined in css as 0.5 and now we want to set value 1, we can not use "" value, it will not override css value
                        element.style.opacity = numValue + "";
                    }
                    if ("filter" in element.style) {
                        // filter opacity: 0...100
                        element.style.filter = "alpha(opacity=" + (numValue * 100.0) + ")";
                    }
                }
            }
            Dom.SetOpacity = SetOpacity;
            ;
            /**
             * Returns opacity percent value 0...100 or 100 if not set.
             * @param element
             */
            function GetOpacity(element) {
                var op = NaN;
                if (element && element.style) {
                    if ("opacity" in element.style) // 0...1
                     {
                        op = parseFloat(element.style.opacity) * 100;
                    }
                    else if ("filter" in element.style) // 0...100
                     {
                        var match = element.style["filter"].match(new RegExp("opacity[\\s\\=]+([\\d]+)"));
                        if (match) {
                            op = parseFloat(match[1]); // may be 0
                        }
                    }
                }
                return typeof (op) == "number" && op >= 0 && op < 100 ? op : 100;
            }
            Dom.GetOpacity = GetOpacity;
            ;
            function GetZIndex(element) {
                // zIndex is not computed value, so computed value is always auto
                let refArr = [];
                if (element && element.style && TryExtractStyleNumericValue(element.style.zIndex, refArr)) {
                    return refArr[0];
                }
                return NaN;
            }
            Dom.GetZIndex = GetZIndex;
            /**
             * Get zIndex from element or from the first ancestor where value is defined.
             * @param element
             */
            function GetZIndexNested(element) {
                let tmp1 = element;
                let zIndex = NaN;
                while (tmp1 && tmp1.ownerDocument && !Calysto.Type.TypeInspector.IsNumber(zIndex = GetZIndex(tmp1))) {
                    tmp1 = tmp1.parentNode;
                }
                return zIndex;
            }
            Dom.GetZIndexNested = GetZIndexNested;
            var rePxNumericProperties = new RegExp("top|left|bottom|right|width|height|size|radius|padding|margin", "i"); // ignore case, eg. borderTop
            function ExtractUnits(value, name) {
                if (name == "opacity" || name == "zoom" || name == "zIndex") {
                    return "";
                }
                var match;
                if (value && typeof (value) == "string" && (match = value.match(new RegExp("(px|%)$", "ig"))) && match && match[1]) {
                    return match[1];
                }
                if (typeof (name) == "string" && rePxNumericProperties.test(name)) {
                    return "px";
                }
                return "";
            }
            Dom.ExtractUnits = ExtractUnits;
            function TryExtractStyleNumericValue(value, refArr) {
                var num;
                if (value && typeof (value) == "string") {
                    // values: +=10, -10, +=10px, +=10%,
                    // color should not be parsed: rgb(0, 3, 5), 
                    var match = value.match(new RegExp("^[\\*\\-\\+\\=]*?([\\-]{0,1}[\\d\\.]+)(px|%)?$")); // extract negative decimal number
                    if (match) {
                        num = parseFloat(match[1]);
                    }
                }
                else {
                    num = value;
                }
                if (Calysto.Type.TypeInspector.IsNumber(num)) {
                    refArr.push(num);
                    return true;
                }
                return false;
            }
            Dom.TryExtractStyleNumericValue = TryExtractStyleNumericValue;
            function ExtractNumericValue(value, defaultValue) {
                var refArr = [];
                if (TryExtractStyleNumericValue(value, refArr)) {
                    return refArr.pop();
                }
                else if (Calysto.Type.TypeInspector.IsNumber(defaultValue)) {
                    return defaultValue;
                }
                throw new Error("Can not extract number from: " + value);
            }
            Dom.ExtractNumericValue = ExtractNumericValue;
            /**
             * test if exists += 10 or -= 10 or *=20
             * @param value
             */
            function IsIncrementValue(value) {
                return !!value && typeof (value) == "string" && value.indexOf("=") == 1;
            }
            Dom.IsIncrementValue = IsIncrementValue;
            /**
             * test if exists % in value
             * @param value
             */
            function IsPercent(value) {
                return !!value && typeof (value) == "string" && value.indexOf("%") > 0;
            }
            Dom.IsPercent = IsPercent;
            function CreateStyleValue(value, units) {
                if (typeof (value) == "string") {
                    // if value is "10", add px
                    // if value is "10%", replace % with units
                    // "auto", "inherit" should not have units
                    return value.replace(new RegExp("^([\\-]?[\\.\\d]+)(px|%)?$", "i"), "$1" + units);
                }
                else if (isNaN(value)) {
                    return "auto";
                }
                else if (units) {
                    return Math.round(value) + "" + units;
                }
                else {
                    // zoom and opacity has no units and allows decimal values
                    return value + "";
                }
            }
            Dom.CreateStyleValue = CreateStyleValue;
            /**
             * Calculate style value from currValue value corrected by newValue. Returns number. If there is originalValue and newValue is in %, return percentage value of originalValue.
             * @param currValue numeric or string, with px, %, or no units
             * @param newValue new value or eg. +=10, auto, -=20, *=30, 10px, with px, % or no units
             */
            function CalculateNumericValue(currValue, newValue) {
                if (typeof (newValue) == "string") {
                    if (IsIncrementValue(newValue)) {
                        var numVal = ExtractNumericValue(newValue.substr(2));
                        var isCurrPercent = false;
                        if (typeof (currValue) == "string") {
                            isCurrPercent = IsPercent(currValue);
                            currValue = parseFloat(currValue); // make sure it is number
                        }
                        if (IsPercent(newValue)) {
                            if (isCurrPercent) {
                                // nothing
                            }
                            else {
                                // numVal is percentage, get value from percent
                                numVal = currValue * numVal / 100;
                            }
                        }
                        var m1 = newValue ? newValue.match(new RegExp("^[\\+\\-\\*]\\=")) : null;
                        if (m1 && m1[0]) {
                            switch (m1[0]) {
                                case "+=":
                                    currValue += numVal;
                                    break;
                                case "-=":
                                    currValue -= numVal;
                                    break;
                                case "*=":
                                    currValue *= numVal;
                                    break;
                            }
                        }
                        return currValue;
                    }
                    else {
                        return ExtractNumericValue(newValue);
                    }
                }
                else {
                    return newValue;
                }
            }
            Dom.CalculateNumericValue = CalculateNumericValue;
            function GetComputedStyleDeclaration(element) {
                // computed style on Chrowe won't work if html is not attached to dom
                if (element.ownerDocument && element.ownerDocument.defaultView && element.ownerDocument.defaultView.getComputedStyle) {
                    // firefox and other
                    return element.ownerDocument.defaultView.getComputedStyle(element);
                }
                else if (window.getComputedStyle) {
                    // ie 9, chrome
                    return window.getComputedStyle(element);
                }
                else if (element.currentStyle) {
                    // ie 6, ie7, ie8
                    return element.currentStyle;
                }
                return element.style;
            }
            Dom.GetComputedStyleDeclaration = GetComputedStyleDeclaration;
            /**
             * Get element style value if available, else get computed value.
             * @param element
             * @param stylePropName style property name
             */
            function GetComputedStyle(element, stylePropName) {
                var styleName = ConvertCssNameToCamel(stylePropName);
                var style;
                var styleValue = undefined;
                var computedStyleValue;
                var numValue = NaN;
                var cunits;
                var isNumber = false;
                if (stylePropName == "opacity") {
                    numValue = GetOpacity(element);
                    styleValue = numValue + "";
                }
                else if (styleName == "zIndex") {
                    // zIndex is not computed value, so computed value is always auto
                    numValue = GetZIndex(element);
                    styleValue = numValue + "";
                }
                else if (stylePropName.indexOf("client") == 0 || stylePropName.indexOf("offset") == 0 || stylePropName.indexOf("scroll") == 0) {
                    // names: client|offset|scroll + Width|Height|Left|Top
                    var tmp1 = element[styleName];
                    if (typeof (tmp1) == "string") {
                        styleValue = tmp1;
                        numValue = ExtractNumericValue(tmp1);
                    }
                    else if (Calysto.Type.TypeInspector.IsNumber(tmp1)) {
                        numValue = tmp1;
                        styleValue = tmp1 + "";
                    }
                    else {
                        throw new Error("Extracting number is not supported");
                    }
                }
                else {
                    // get value from .style object first, if value is not set, then get from computed style object
                    // eg. if name is "border-width", it may be retreived from element.style only, computed style value is always ""
                    styleValue = element.style[styleName];
                    if (!styleValue || stylePropName.indexOf("color") >= 0 || styleValue == "auto" || styleValue == "initial" || styleValue == "inherit") {
                        // if we need start value for animator in percent (%), we have to get value as element.style[styleName] because computed value is always in px
                        // always get computed value, eg if style.height == "auto", we must get mesured numeric value for animator to work
                        // styleValue is always string, so "" is false
                        styleValue = GetComputedStyleDeclaration(element)[styleName];
                    }
                    var refArr = [];
                    if (TryExtractStyleNumericValue(styleValue, refArr)) {
                        isNumber = true;
                        numValue = Math.round(refArr.pop()); // 0 is default for height, width, etc...
                        cunits = ExtractUnits(styleValue, stylePropName);
                    }
                }
                if (!Calysto.Type.TypeInspector.IsNumber(numValue)) {
                    ////numValue = styleValue; // can't be converted to number
                }
                else if (styleValue == "auto") {
                    // fix for IE7 and older which returns "auto" if value is not set
                    switch (styleName) {
                        case "height":
                            numValue = element.clientHeight;
                            break;
                        case "width":
                            numValue = element.clientWidth;
                            break;
                    }
                }
                // return final object:
                // "name" may be: background-color, "styleName" will be backgroundColor
                // styleValue may be: 10px, then value is 10, units is px
                return {
                    Element: element,
                    // original name passed to function
                    Name: stylePropName,
                    NumericValue: numValue,
                    IsNumber: isNumber,
                    Units: cunits,
                    // original style value as string (used for colors)
                    StyleValue: styleValue + "",
                    // camelCaseName accepted by style object
                    StyleName: styleName
                };
            }
            Dom.GetComputedStyle = GetComputedStyle;
            /**
             * Set style value.
             * @param element
             * @param name
             * @param value can be string '+=10' which wil increment current value or '-=10" to decrement current value
             * @param units
             */
            function SetStyleValue(element, name, value, units) {
                if (element && element.style) {
                    var styleName = ConvertCssNameToCamel(name);
                    var styleValue;
                    var numVal;
                    if (IsIncrementValue(value)) {
                        var curr = GetComputedStyle(element, name); // get current first
                        numVal = CalculateNumericValue(curr.NumericValue, value);
                        styleValue = CreateStyleValue(numVal, units || curr.Units);
                    }
                    else if (typeof (value) == "string") {
                        // eg. value = "10", use px units if units are required
                        let units1 = ExtractUnits(value, name);
                        styleValue = CreateStyleValue(value, units1); // "10px", "auto", "10", ""...
                        ////alert(units + ", " + value + ", " + name + ", " + styleValue);
                    }
                    else {
                        // numeric value
                        let units2 = units || ExtractUnits(value, name);
                        numVal = value;
                        styleValue = CreateStyleValue(value, units2);
                    }
                    if (name == "opacity") {
                        SetOpacity(element, numVal);
                    }
                    else if (name.indexOf("offset") == 0) {
                        // offset values can not be set
                    }
                    else if (name.indexOf("client") == 0 || name.indexOf("scroll") == 0) {
                        // set attribute value, this is required for animator
                        element[name] = numVal;
                    }
                    else {
                        try {
                            // ie 7 may throw exception if setting negative width or height
                            element.style[styleName] = styleValue;
                        }
                        catch (e) {
                        }
                    }
                }
            }
            Dom.SetStyleValue = SetStyleValue;
            //#endregion
            //#region element attribute methods
            function GetAttributeNode(element, attrName) {
                if (element && element.getAttributeNode) {
                    return element.getAttributeNode(attrName);
                }
                return null;
            }
            Dom.GetAttributeNode = GetAttributeNode;
            /**
             * Returns attribute value as string or null if there is no attribute defined.
             * @param element
             * @param attrName
             */
            function GetAttribute(element, attrName) {
                if (element && element.getAttribute) {
                    return element.getAttribute(attrName);
                }
                return null;
            }
            Dom.GetAttribute = GetAttribute;
            function SetAttribute(element, attrName, value) {
                if (element && element.setAttribute) {
                    element.setAttribute(attrName, value);
                }
            }
            Dom.SetAttribute = SetAttribute;
            function RemoveAttribute(element, attrName) {
                if (element && element.removeAttribute) {
                    element.removeAttribute(attrName);
                }
            }
            Dom.RemoveAttribute = RemoveAttribute;
            function HasAttribute(element, attrName) {
                if (element) {
                    // IE8< doesn't have .hasAttribute, so use .getAttribute
                    if (element.hasAttribute) {
                        return element.hasAttribute(attrName);
                    }
                    else if (element.getAttribute) {
                        // if element has attribute, but has no value, getAttribute() returns ""
                        // if element doesn't have attribute, return null
                        return !(element.getAttribute(attrName) == null);
                    }
                }
                return false;
            }
            Dom.HasAttribute = HasAttribute;
            //#endregion
            //#region element DOM manipulation
            function SetEnabled(element, enabled) {
                if (element) {
                    if (enabled) {
                        RemoveAttribute(element, "disabled");
                        element.disabled = false;
                    }
                    else {
                        // disable
                        // if "a" tag is disabled, firefox and chrome ignores disabled attribute and acts like it is not disabled. We have to disable click event on element.
                        // warning: don't manipulate click event, it will mess up with MS ajax events, just add disabled attribute
                        SetAttribute(element, "disabled", "disabled");
                        element.disabled = true;
                    }
                }
            }
            Dom.SetEnabled = SetEnabled;
            function CloneNodeIfHasParent(node) {
                if (node && node.parentNode && node.cloneNode) {
                    // if node has parent, clone it, full depth
                    return node.cloneNode(true);
                }
                else {
                    return node;
                }
            }
            Dom.CloneNodeIfHasParent = CloneNodeIfHasParent;
            function RemoveNodeFromDom(node) {
                if (node && node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            }
            Dom.RemoveNodeFromDom = RemoveNodeFromDom;
            /**
             * Insert elements before refNode without cloning - remove elements from previous position.
             * @param refNode
             * @param elArray array of elements to insert, element are not cloned, so they will be removed from previous position and will be inserted into new position
             */
            function InsertBefore(refNode, elArray) {
                if (refNode && refNode.parentNode) {
                    if (elArray && elArray.length > 0) {
                        // insert backwards because we have system .insertBefore() only, there is no .insertAfter()
                        for (var n = elArray.length - 1; n >= 0; n--) {
                            var n1 = elArray[n];
                            if (n1 && refNode.parentNode) {
                                ////n1 = __dom.CloneNodeIfHasParent(n1); // NO!!! node has to be already cloned in the code before
                                refNode.parentNode.insertBefore(n1, refNode);
                                refNode = n1;
                            }
                        }
                    }
                }
                else {
                    throw new Error("InsertBefore failed, no parentNode");
                }
            }
            Dom.InsertBefore = InsertBefore;
            /**
             * Replace refNode with new one. refNode has to be in DOM, otherwise it won't work with replaceWith method.
             * @param refNode node which should be replaced
             * @param elArray array of replacement elements
             */
            function ReplaceWith(refNode, elArray) {
                InsertBefore(refNode, elArray);
                if (refNode && refNode.parentNode)
                    refNode.parentNode.removeChild(refNode);
            }
            Dom.ReplaceWith = ReplaceWith;
            /**
             * Insert elements after refNode without cloning - remove elements from previous position.
             * @param refNode
             * @param elArray array of elements to insert, element are not cloned, so they will be removed from previous position and will be inserted into new position
             */
            function InsertAfter(refNode, elArray) {
                if (refNode && refNode.parentNode) {
                    if (elArray && elArray.length > 0) {
                        // insert element before, than swap nodes
                        // insert backwards because we have system .insertBefore() only, there is no .insertAfter()
                        for (var n = 0; n < elArray.length; n++) {
                            var n1 = elArray[n];
                            if (n1 && refNode.parentNode) {
                                ////n1 = __dom.CloneNodeIfHasParent(n1); // NO!!! node has to be already cloned before if required
                                refNode.parentNode.insertBefore(n1, refNode);
                                // swap nodes
                                refNode.parentNode.insertBefore(refNode, n1);
                                // change anchor node
                                refNode = n1;
                            }
                        }
                    }
                }
                else {
                    throw new Error("InsertAfter failed, no parentNode");
                }
            }
            Dom.InsertAfter = InsertAfter;
            /**
             * Replace parent's children with childrenArray.
             * @param parent
             * @param childrenArray If null, remove children only. Array of elements to insert, element are not cloned, so they will be removed from previous position and will be inserted into new position
             */
            function ReplaceChildrenWith(parent, childrenArray) {
                if (parent && parent.childNodes && parent.nodeType == 1) {
                    // remove children first
                    // parent.innerHTML = ""; // remove children first this way, or use removeChild()
                    for (var n = parent.childNodes.length - 1; n >= 0; n--) {
                        var nn = parent.childNodes[n];
                        if (nn && nn.parentNode) {
                            nn.parentNode.removeChild(nn);
                        }
                    }
                    if (childrenArray && childrenArray.length > 0) {
                        // add children
                        for (var n = 0; n < childrenArray.length; n++) {
                            ////parent.appendChild(__dom.CloneNodeIfHasParent(childrenArray[n])); // NO!!! node has to be already cloned before if required
                            parent.appendChild((childrenArray[n]));
                        }
                    }
                }
            }
            Dom.ReplaceChildrenWith = ReplaceChildrenWith;
            /**
             * Add childrenArray to parent's children without cloning.
             * @param parent
             * @param childrenArray Array of elements to insert, element are not cloned, so they will be removed from previous position and will be inserted into new position
             */
            function AddChildren(parent, childrenArray) {
                if (parent && parent.childNodes && parent.nodeType == 1) {
                    if (childrenArray && childrenArray.length > 0) {
                        for (var n = 0; n < childrenArray.length; n++) {
                            var n1 = childrenArray[n];
                            if (n1) {
                                ////n1 = __dom.CloneNodeIfHasParent(n1); // NO!!! node has to be already cloned before if required
                                parent.appendChild(n1);
                            }
                        }
                    }
                }
            }
            Dom.AddChildren = AddChildren;
            ;
            /**
             * Insert childrenArray as first child to parent node without cloning.
             * @param parent
             * @param childrenArray Array of elements to insert, element are not cloned, so they will be removed from previous position and will be inserted into new position.
             */
            function InsertChildren(parent, childrenArray) {
                if (parent && parent.childNodes) {
                    if (parent.childNodes.length > 0) {
                        InsertBefore(parent.childNodes[0], childrenArray);
                    }
                    else {
                        AddChildren(parent, childrenArray);
                    }
                }
            }
            Dom.InsertChildren = InsertChildren;
            ;
            function ConvertToElementsArray(...args) {
                if (arguments.length == 0) {
                    // args is null or empty
                    // this is possible, e.g. .ReplaceChildren() without arguments, means should remove children without adding any new child
                    return [];
                }
                var res = [];
                var args = Calysto.Collections.SelectFlatten(arguments);
                for (var n1 = 0; n1 < args.length; n1++) {
                    res.AddRange(ConvertSingleToElementsArray(args[n1]));
                }
                return res;
            }
            Dom.ConvertToElementsArray = ConvertToElementsArray;
            /**
             * All arrays or enumerables are flattened and items are converted to HtlmElements array.
             * @param htmlOrElement html, array of htmls, element or array or elements
             */
            function ConvertSingleToElementsArray(htmlOrElement) {
                // possible values: value, null, undefined, e.g. inside .Select(...), if we don't want to create dom element, we're sending null instead of html or element
                if (Calysto.Type.TypeInspector.IsNullOrUndefined(htmlOrElement)) {
                    return [];
                }
                if (typeof (htmlOrElement) == "number") {
                    htmlOrElement = htmlOrElement + "";
                }
                if (typeof (htmlOrElement) == "string") // string
                 {
                    if (String.IsNullOrWhiteSpace(htmlOrElement)) {
                        return [];
                    }
                    var div = document.createElement("div"); // container div
                    div.innerHTML = htmlOrElement;
                    var items = [];
                    for (var n = 0; n < div.childNodes.length; n++) {
                        var node1 = div.childNodes[n];
                        items.push(node1);
                    }
                    // must remove parentNode to remove container div from parentNode
                    for (var n = 0; n < items.length; n++) {
                        var node2 = items[n];
                        if (node2 && node2.parentNode) {
                            node2.parentNode.removeChild(node2); // to remove node.parentNode value
                        }
                    }
                    return items;
                }
                else if (htmlOrElement.childNodes) // dom node
                 {
                    return [htmlOrElement];
                }
                throw new Error("Invalid type in ConvertSingleToElementsArray");
            }
            /**
             * Center element into parent. Larger element is shrinked to fit into container.
             * @param element
             * @param crop false: fit larger dimension; true: overscan to fit smaller dimension
             * @param enlarge true: smaller element is enlarged to fit into parent, false: smaller element is not enlarged
             */
            function CenterElementIntoParent(element, crop, enlarge) {
                var el = element;
                if (!el || !el.parentNode || !(el.parentNode.clientHeight > 0 && el.parentElement.clientWidth > 0)) {
                    // on IE 11 in full screen ajax loader image has offsetHeight == 0 && offsetWidth == 0
                    // if el is not visible or not in dom
                    return;
                }
                /// <param name="shrink" type="Boolean" optional="true" default="true">true: larger element is shrinked to fit into parent, smaller element is not resized, false: larger element is not shrinked</param>
                var shrink = true; // always shrink larger element
                el.parentNode.style.overflow = "hidden";
                if (enlarge || shrink) {
                    if ((el.tagName || "").toLowerCase() == "img") {
                        el.removeAttribute("width");
                        el.removeAttribute("height");
                        el.style.width = "";
                        el.style.height = "";
                    }
                    el.style.margin = "";
                }
                // width and height are needed to calcucate AR only
                var elWidth = el.__initialWidth || el.offsetWidth || el.clientWidth;
                var elHeight = el.__initialHeight || el.offsetHeight || el.clientHeight;
                var ar = elWidth / elHeight || 1; // if elHeight is 0
                var w = elWidth;
                var h = elHeight;
                // if fit always shring or enlarge to fit into parent
                // if not fit: shrink if larger; if smaller, don't change size
                if ((enlarge && (w < el.parentElement.clientWidth || h < el.parentElement.clientHeight)) || (shrink && (w > el.parentElement.clientWidth || h > el.parentElement.clientHeight))) {
                    w = el.parentElement.clientWidth;
                    h = w / ar;
                    if ((crop && h < el.parentElement.clientHeight) || (!crop && h > el.parentElement.clientHeight)) {
                        h = el.parentElement.clientHeight;
                        w = h * ar;
                    }
                }
                // WARNING: el must be positioned as relative or nothing, set position:relative or nothing
                // position has to be set using margin-top and margin-left
                // don't use position:absolute, it won't work in Firefox and Android mobile
                el.style.position = "relative"; // user relative or none, works better on Firefox and Mobile
                el.style.top = "0";
                el.style.left = "0";
                el.style.bottom = "0";
                el.style.right = "0";
                el.style.padding = "0";
                el.style.margin = "0";
                w = Math.ceil(w); // ceil: round to upper level to avoid empty space around the picture
                h = Math.ceil(h);
                // parent must not have align='center', everything has to be default on parent
                var mleft = Math.floor((el.parentNode.clientWidth - w) / 2);
                var mtop = Math.floor((el.parentNode.clientHeight - h) / 2);
                // positioning with margin-top and margin-right doesn't require parent to have position:absolute, while positioning with top and left requires position:absolute on parent
                el.style.marginTop = mtop + "px";
                el.style.marginLeft = mleft + "px";
                el.style.width = w + "px";
                el.style.height = h + "px";
            }
            Dom.CenterElementIntoParent = CenterElementIntoParent;
            /**
             * Select transform value of current elements and return new Calysto.List with string values.
             * @param node
             */
            function SelectTransform(node) {
                if (node && node.style) {
                    return node.style.transform || node.style.msTransform || node.style.webkitTransform;
                }
                return "";
            }
            Dom.SelectTransform = SelectTransform;
            //#endregion
        })(Dom = Utility.Dom || (Utility.Dom = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Path;
        (function (Path) {
            function RemoveQueryStr(path) {
                var index;
                if (path && (index = path.indexOf("?")) >= 0) {
                    return path.substr(0, index);
                }
                return path;
            }
            function GetQueryString(path) {
                /// <summary>
                /// Returns query string from path, starting with ?<br/>
                /// Returns "?par=something&amp;nn=4325" from "/CalystoWebControlsTests/TelephoneNumbers.aspx?par=something&amp;nn=4325"<br/>
                /// Works with left and right slash: / \
                /// </summary>
                /// <param name="path"></param>
                var index;
                if (path && (index = path.indexOf("?")) >= 0) {
                    return path.substr(index);
                }
                return "";
            }
            Path.GetQueryString = GetQueryString;
            function GetFilePath(path) {
                /// <summary>
                /// Returns "/CalystoWebControlsTests/TelephoneNumbers.aspx" from "/CalystoWebControlsTests/TelephoneNumbers.aspx?par=something&amp;nn=4325"<br/>
                /// Works with left and right slash: / \
                /// </summary>
                /// <param name="path"></param>
                var index;
                if (path && (index = path.indexOf("?")) >= 0) {
                    return path.substr(0, index);
                }
                return path;
            }
            Path.GetFilePath = GetFilePath;
            function GetExtension(path) {
                /// <summary>
                /// Returns ".aspx" from "/CalystoWebControlsTests/TelephoneNumbers.aspx?par=something&amp;nn=4325"<br/>
                /// Works with left and right slash: / \
                /// </summary>
                /// <param name="path"></param>
                var index;
                if (path && (path = RemoveQueryStr(path)) && (index = path.lastIndexOf(".")) >= 0) {
                    return path.substr(index);
                }
                return "";
            }
            Path.GetExtension = GetExtension;
            function GetDirectoryName(path) {
                /// <summary>
                /// Returns "/CalystoWebControlsTests" from "/CalystoWebControlsTests/TelephoneNumbers.aspx"<br/>
                /// Works with left and right slash: / \
                /// </summary>
                /// <param name="path"></param>
                var index;
                if (path && (path = RemoveQueryStr(path)) && ((index = path.lastIndexOf("/")) >= 0 || (index = path.lastIndexOf("\\")) >= 0)) {
                    return path.substr(0, index);
                }
                return path;
            }
            Path.GetDirectoryName = GetDirectoryName;
            function GetFileName(path) {
                /// <summary>
                /// Returns "TelephoneNumbers.aspx" from "/CalystoWebControlsTests/TelephoneNumbers.aspx"<br/>
                /// Works with left and right slash: / \
                /// </summary>
                /// <param name="path"></param>
                var index;
                if (path && (path = RemoveQueryStr(path)) && ((index = path.lastIndexOf("/")) >= 0 || (index = path.lastIndexOf("\\")) >= 0)) {
                    return path.substr(index + 1);
                }
                return path;
            }
            Path.GetFileName = GetFileName;
        })(Path = Utility.Path || (Utility.Path = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Blob;
        (function (Blob) {
            /**
             *
             * @param byteArrays Uint8Array|Blob|File, example: [new Uint8Array([data]), new Blob(), new File(), ...]
             * @param contentType
             */
            function CreateBlob(byteArrays, contentType) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="byteArrays" type="[Uint8Array|Blob|File]">example: [new Uint8Array([data]), new Blob(), new File(), ...]</param>
                /// <param name="contentType" type="String">mime type</param>
                /// <returns type=""></returns>
                // warning: byteArrays has to be array of arrays
                // byteArrays accepts: [new Uint8Array([data]), new Blob(), new File(), ...]
                // simple Array is not suported, convert it to Uint8Array: new Unit8Array(Array instance)
                if (window.Blob) {
                    return new window.Blob(byteArrays, { type: contentType });
                }
                else {
                    var win = window;
                    var blobCtor = win.BlobBuilder ||
                        win.WebKitBlobBuilder ||
                        win.MozBlobBuilder ||
                        win.MSBlobBuilder;
                    if (blobCtor) {
                        var bb = new blobCtor();
                        bb.append(byteArrays);
                        return bb.getBlob(contentType);
                    }
                }
                throw new Error("Blob is not supported");
            }
            Blob.CreateBlob = CreateBlob;
            function Base64ToBlob(base64Data, contentType) {
                /// <summary>
                /// returns Blob object
                /// </summary>
                /// <param name="base64Data" type="string"></param>
                /// <param name="contentType" type="string"></param>
                contentType = contentType || '';
                var sliceSize = 1024; // text MUST be in slices, max size 1024
                var byteCharacters = atob(base64Data);
                var bytesLength = byteCharacters.length;
                var slicesCount = Math.ceil(bytesLength / sliceSize);
                var byteArrays = new Array(slicesCount);
                for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
                    var begin = sliceIndex * sliceSize;
                    var end = Math.min(begin + sliceSize, bytesLength);
                    var bytes = new Array(end - begin);
                    for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
                        bytes[i] = byteCharacters[offset].charCodeAt(0); // converting chars to bytes
                    }
                    var arr = new Uint8Array(bytes);
                    byteArrays[sliceIndex] = arr;
                }
                return CreateBlob(byteArrays, contentType);
            }
            Blob.Base64ToBlob = Base64ToBlob;
            function DataUrlToBlob(dataUrl, filename) {
                /// <summary>
                /// convert string eg. data:image/png;base64,iVBORw0KGgoAAkJggg== to Blob instance
                /// </summary>
                /// <param name="dataUrl" type="String"></param>
                var type, base64data;
                var parts = dataUrl.split(";");
                for (var n = 0; n < parts.length; n++) {
                    var pp = parts[n];
                    if (pp.StartsWith("data:")) {
                        type = pp.substr("data:".length);
                    }
                    else if (pp.StartsWith("base64,")) {
                        base64data = pp.substr("base64,".length);
                    }
                }
                var blob = Base64ToBlob(base64data, type);
                blob.filename = filename;
                return blob;
            }
            Blob.DataUrlToBlob = DataUrlToBlob;
            /**
             * convert blob to RFC base64 string
             * @param blob
             * @param onComplete
             */
            function BlobToBase64Async(blob, onComplete) {
                /// <summary>
                /// returns string as base64 encoded blob data
                /// </summary>
                /// <param name="blob" type="Blob"></param>
                /// <param name="onComplete" type="function">function(base64str){...}</param>
                var reader = new FileReader();
                reader.onload = function (res) {
                    var arr = new Uint8Array(res.currentTarget.result);
                    // convert bytes[] to chars
                    var chars = [arr.length];
                    for (var n = 0; n < arr.length; n++) {
                        chars[n] = String.fromCharCode(arr[n]);
                    }
                    var str = chars.join("");
                    var b64 = btoa(str);
                    onComplete(b64);
                };
                reader.readAsArrayBuffer(blob);
            }
            Blob.BlobToBase64Async = BlobToBase64Async;
            /**
             * convert blob to string eg. data:image/png;base64,iVBORw0KGgoAAkJggg==
             * @param blob
             * @param onComplete
             */
            function BlobToDataUrlAsync(blob, onComplete) {
                /// <summary>
                /// return string eg. data:image/png;base64,iVBORw0KGgoAAkJggg==
                /// </summary>
                /// <param name="blob" type="Blob"></param>
                /// <param name="onComplete" type="function">function(dataUrl, fileName){...}</param>
                var reader = new FileReader();
                reader.onload = function (res) {
                    onComplete(res.currentTarget.result, blob.name || blob.filename);
                };
                reader.readAsDataURL(blob);
            }
            Blob.BlobToDataUrlAsync = BlobToDataUrlAsync;
        })(Blob = Utility.Blob || (Utility.Blob = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var Caret;
        (function (Caret) {
            function SetInputSelectionRange(node, start, end) {
                /// <summary>
                /// Select text from start to end index. If start and end are not set, will unselect all.
                /// </summary>
                /// <param name="object"></param>
                /// <param name="start" optional="true">if not set, select from start</param>
                /// <param name="end" optional="true">if not set, select to the end of string</param>
                var object = node;
                if (object == null || !object.type) {
                    return;
                }
                try {
                    if (!start || start < 0) {
                        start = 0;
                    }
                    if (arguments.length < 3 || end > object.value.length) {
                        end = object.value.length;
                    }
                    if (object.setSelectionRange) {
                        object.focus();
                        object.setSelectionRange(start, end);
                    }
                    else if (object.createTextRange) {
                        object.focus();
                        var range;
                        if (object.caret) {
                            range = object.caret;
                            range.moveStart("textedit", -1);
                            range.moveEnd("textedit", -1);
                        }
                        else {
                            range = object.createTextRange();
                        }
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                }
                catch (e) {
                    // Ignore
                }
            }
            Caret.SetInputSelectionRange = SetInputSelectionRange;
            function SetCaretPosition(node, position) {
                /// <summary>
                /// Set caret position in text.
                /// </summary>
                /// <param name="object"></param>
                SetInputSelectionRange(node, position, position);
            }
            Caret.SetCaretPosition = SetCaretPosition;
            function GetCaretPosition(obj) {
                /// <summary>
                /// Returns caret position in text.
                /// </summary>
                /// <param name="object"></param>
                var object = obj;
                if (object == null || !object.type) {
                    return null;
                }
                try {
                    if (object.createTextRange && object.caret) {
                        var range = object.caret.duplicate();
                        range.moveStart('textedit', -1);
                        return range.text.length;
                    }
                    else if (object.selectionStart || object.selectionStart == 0) {
                        return object.selectionStart;
                    }
                }
                catch (e) {
                }
                return null;
            }
            Caret.GetCaretPosition = GetCaretPosition;
            function GetInputSelectionRange(obj) {
                /// <summary>
                /// Returns array with start and end index of current text selection.
                /// </summary>
                /// <param name="object"></param>
                var object = obj;
                if (object == null || !object.type) {
                    return null;
                }
                try {
                    if (object.selectionEnd) {
                        return { start: object.selectionStart, end: object.selectionEnd };
                    }
                    else if (object.createTextRange && object.caret) {
                        var end = GetCaretPosition(object);
                        if (typeof (end) == "number") {
                            return { start: end - object.caret.text.length, end: end };
                        }
                        // nothing selected
                    }
                }
                catch (e) {
                    // Ignore
                }
                return null;
            }
            Caret.GetInputSelectionRange = GetInputSelectionRange;
        })(Caret = Utility.Caret || (Utility.Caret = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var FullScreen;
        (function (FullScreen) {
            // NOTE: Fullscreen requests to be invoked from event handler's thread, otherwise permision is denied.
            function RequestFullScreen(el) {
                var divObj = el;
                var requestFunc = divObj.requestFullscreen
                    || divObj.msRequestFullscreen
                    || divObj.mozRequestFullScreen
                    || divObj.webkitRequestFullscreen
                    || divObj.webkitRequestFullScreen /*safari*/
                    || divObj.webkitEnterFullScreen
                    || divObj.webkitEnterFullscreen;
                //Use the specification method before using prefixed versions
                if (requestFunc) {
                    requestFunc.apply(divObj);
                }
            }
            FullScreen.RequestFullScreen = RequestFullScreen;
            var cancelFunc = (() => {
                var doc = document;
                return (doc.cancelFullscreen
                    || doc.msExitFullscreen
                    || doc.msCancelFullscreen
                    || doc.mozCancelFullScreen
                    || doc.webkitExitFullscreen
                    || doc.webkitExitFullScreen /*iPhone*/
                    || doc.webkitCancelFullscreen
                    || doc.webkitCancelFullScreen /*safari*/);
            })();
            function CancelFullScreen() {
                // Use the specification method before using prefixed versions
                // IE has msExitFullscreen
                if (cancelFunc) {
                    cancelFunc.apply(document);
                }
            }
            FullScreen.CancelFullScreen = CancelFullScreen;
            function GetFullScreenElement() {
                var doc = document;
                //  get full screen element across several browsers
                return doc.fullscreenElement
                    || doc.msFullscreenElement
                    || doc.mozFullScreenElement
                    || doc.webkitFullscreenElement
                    || doc.webkitCurrentFullScreenElement /*safari*/
                    || doc.webkitDisplayingFullscreen; // warning: this should be true/false only, not the element which is in fullscreen
            }
            FullScreen.GetFullScreenElement = GetFullScreenElement;
            function IsInFullscreen() {
                return !!GetFullScreenElement();
            }
            FullScreen.IsInFullscreen = IsInFullscreen;
            ;
            function IsIframeFullscreenEnabled() {
                /// <summary>
                /// Test if iframe has allowFullscreen attribute
                /// </summary>
                var doc = document;
                return !!(doc.fullscreenEnabled
                    || doc.msFullscreenEnabled
                    || doc.mozFullScreenEnabled
                    || doc.webkitFullscreenEnabled
                    || "webkitIsFullScreen" in doc /*for safari*/);
            }
            FullScreen.IsIframeFullscreenEnabled = IsIframeFullscreenEnabled;
            function IsSupported() {
                if (window.parent) {
                    return !!(cancelFunc && IsIframeFullscreenEnabled());
                }
                else {
                    return !!(cancelFunc);
                }
            }
            FullScreen.IsSupported = IsSupported;
            var chg = ["MSFullscreenChange", "webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange"];
            var err = ["MSFullscreenError", "webkitfullscreenerror", "mozfullscreenerror", "fullscreenerror"];
            var _evChgAssigned = false;
            var _onFsChanged = [];
            function OnFullscreenChanged(handler) {
                if (!_evChgAssigned) {
                    _evChgAssigned = true;
                    var sender = document;
                    chg.ForEach((evName) => Calysto.Event.Attach(sender, evName, (ev) => {
                        // this je originalni element
                        // fullscreen detection _this.IsInFullscreen() doesn't work ok
                        _onFsChanged.ForEach(fn => fn(sender));
                    }));
                }
                _onFsChanged.push(handler);
            }
            FullScreen.OnFullscreenChanged = OnFullscreenChanged;
            var _evErrAssigned = false;
            var _onFsError = [];
            function OnFullscreenError(handler) {
                if (!_evErrAssigned) {
                    _evErrAssigned = true;
                    var sender = document;
                    err.ForEach((evName) => Calysto.Event.Attach(sender, evName, (ev) => {
                        // this is original element
                        // fullscreen detection _this.IsInFullscreen() doesn't work ok
                        _onFsError.ForEach(fn => fn(sender));
                    }));
                }
                _onFsError.push(handler);
            }
            FullScreen.OnFullscreenError = OnFullscreenError;
        })(FullScreen = Utility.FullScreen || (Utility.FullScreen = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        var CalystoTools;
        (function (CalystoTools) {
            function LongToByteArray(longNum, truncateEmptyBytes) {
                /// <summary>
                /// LSB is first
                /// </summary>
                /// <param name="longNum" type="type"></param>
                /// <param name="truncateEmptyBytes" type="Boolean" optional="true">if true, will truncate unused bytes</param>
                /// <returns type=""></returns>
                // we want to represent the input as a n-bytes array
                if (!(longNum > 0 || longNum === 0)) {
                    throw new Error("LongToByteArray argument may not be negative");
                }
                var byteArray = [];
                for (var index = 0; index < 8; index++) {
                    var b1 = longNum & 0xff;
                    if (truncateEmptyBytes && Math.pow(2, index * 8) > longNum) {
                        if (b1 > 0 || byteArray.length == 0)
                            byteArray.push(b1);
                        break;
                    }
                    else {
                        byteArray.push(b1);
                        longNum = (longNum - b1) / 256;
                    }
                }
                return byteArray;
            }
            CalystoTools.LongToByteArray = LongToByteArray;
            function ByteArrayToLong(byteArray) {
                /// <summary>
                /// LSB is first
                /// </summary>
                /// <param name="byteArray" type="type"></param>
                /// <returns type=""></returns>
                var value = 0;
                for (var i = byteArray.length - 1; i >= 0; i--) {
                    value = (value * 256) + byteArray[i];
                }
                return value;
            }
            CalystoTools.ByteArrayToLong = ByteArrayToLong;
        })(CalystoTools = Utility.CalystoTools || (Utility.CalystoTools = {}));
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Graphics;
    (function (Graphics) {
        let ResizeModeEnum;
        (function (ResizeModeEnum) {
            /** Default. Resize image to fit into rectangle without overflowing. Keep AR. */
            ResizeModeEnum[ResizeModeEnum["Fit"] = 0] = "Fit";
            /** Resize image to fit and overflow the rectangle bounds if required. Overflowing part of the image is croped. Keep AR.*/
            ResizeModeEnum[ResizeModeEnum["Crop"] = 1] = "Crop";
            /** Resize image to fit into rectangle without overflowing rectangle dimensions. Add background to create exact width and height. Keep AR */
            ResizeModeEnum[ResizeModeEnum["Exact"] = 2] = "Exact";
            /** Stretch to exact width and height, destroy AR */
            ResizeModeEnum[ResizeModeEnum["Stretch"] = 3] = "Stretch";
        })(ResizeModeEnum = Graphics.ResizeModeEnum || (Graphics.ResizeModeEnum = {}));
        class ImageResize {
            constructor() {
                /** max width */
                this.Width = 500;
                /** max height */
                this.Height = 500;
                this.Mode = "Fit";
                /* Make thumb larger or smaller than canvas. Pozitive number will make thumb larger, negative will make it smaller.*/
                this.Overscan = 0;
            }
            /**
             * Resize image and return dataURL
             */
            Resize(source) {
                var thumbWidth = source.width;
                var thumbHeight = source.height;
                var ar = source.width / source.height;
                var canvasWidth = this.Width;
                var canvasHeight = this.Height;
                if (this.Mode == "Stretch") {
                    thumbWidth = this.Width;
                    thumbHeight = this.Height;
                }
                else if (this.Mode == "Exact" || this.Mode == "Fit") {
                    thumbWidth = this.Width;
                    thumbHeight = thumbWidth / ar;
                    if (thumbHeight > this.Height) {
                        thumbHeight = this.Height;
                        thumbWidth = thumbHeight * ar;
                    }
                    if (this.Mode == "Fit") {
                        canvasWidth = thumbWidth;
                        canvasHeight = thumbHeight;
                    }
                }
                else if (this.Mode == "Crop") {
                    thumbWidth = Math.min(source.width, this.Width);
                    thumbHeight = thumbWidth / ar;
                    if (thumbHeight < this.Height) {
                        thumbHeight = Math.min(source.height, this.Height);
                        thumbWidth = thumbHeight * ar;
                    }
                    canvasWidth = Math.min(thumbWidth, this.Width);
                    canvasHeight = Math.min(thumbHeight, this.Height);
                }
                thumbHeight += this.Overscan;
                thumbWidth += this.Overscan;
                var c22 = document.createElement("canvas");
                var cx22 = c22.getContext("2d");
                if (!cx22) {
                    throw new Error("Can not create 2d context");
                }
                c22.width = canvasWidth;
                c22.height = canvasHeight;
                if (this.BackColor && this.BackColor != "transparent") {
                    cx22.fillStyle = this.BackColor;
                    cx22.fillRect(0, 0, c22.width, c22.height);
                }
                var left1 = (canvasWidth - thumbWidth) / 2;
                var top1 = (canvasHeight - thumbHeight) / 2;
                cx22.drawImage(source, left1, top1, thumbWidth, thumbHeight);
                return c22.toDataURL(this.OutputMime || "image/png");
            }
        }
        Graphics.ImageResize = ImageResize;
    })(Graphics = Calysto.Graphics || (Calysto.Graphics = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class QueryString {
        /**
         * Create new instance from url if provided
         * @param url if provided, parse url
         */
        constructor(urlStr) {
            this.urlStr = urlStr;
            this.items = [];
            if (urlStr)
                this.ParseImpl(urlStr);
        }
        GetInnerUri() {
            return this.uri || (this.uri = new Calysto.Uri());
        }
        ;
        /**
         * Query string prefixed with question
         */
        GetQuery() {
            /// <summary>
            /// Query string prefixed with question
            /// </summary>
            var arr = new Array();
            for (var n = 0; n < this.items.length; n++) {
                var item = this.items[n];
                arr.push(encodeURIComponent(item.name) + "=" + encodeURIComponent(item.value));
            }
            return arr.length > 0 ? ("?" + arr.join("&")) : "";
        }
        ;
        GetUrl() {
            this.uri = this.uri || new Calysto.Uri();
            this.uri.Query = this.GetQuery();
            return this.uri.GetAbsoluteUri();
        }
        Clear() {
            ///<summary>remove query string items</summary>
            this.items = [];
        }
        FindItem(name, caseSensitive = false) {
            /// <summary>
            /// Case non-sensitive search.
            /// </summary>
            /// <param name="name"></param>
            if (caseSensitive) {
                return this.items.Where(o => o.name == name);
            }
            else {
                var lower = name.toLowerCase();
                return this.items.Where(o => o.lowerName == lower);
            }
        }
        /**
         * case non-sensitive name search and add or update if exists
         * @param name
         * @param value
         */
        SetValue(name, value) {
            ///<summary>case non-sensitive name search and add or update if exists</summary>
            if (name) {
                var item = this.FindItem(name).pop();
                var lower = name.toLowerCase();
                if (!item) {
                    item = {
                        lowerName: lower,
                        name: name,
                        value: Calysto.Type.TypeInspector.IsNullOrUndefined(value) ? "" : (value + "")
                    };
                    this.items.push(item);
                }
                else {
                    // update values
                    item.lowerName = lower,
                        item.name = name;
                    item.value = Calysto.Type.TypeInspector.IsNullOrUndefined(value) ? "" : (value + "");
                }
            }
            return this;
        }
        /**
         * case non-sensitive name search and remove
         * @param name
         */
        RemoveValue(name) {
            ///<summary>case non-sensitive name search and remove</summary>
            if (name) {
                var lower = name.toLowerCase();
                this.items = this.items.Where(o => o.lowerName != lower);
            }
            return this;
        }
        /**
         * case non-sensitve name search
         * @param name
         */
        GetValue(name) {
            ///<summary>case non-sensitve name search</summary>
            var item = this.FindItem(name).pop();
            if (item)
                return item.value;
            return null;
        }
        /**
         * Extract query part from url and parse it
         * @param url
         */
        ParseImpl(url) {
            /// <summary>
            /// Extract query part from url and parse it.
            /// </summary>
            /// <param name="url" type="String"></param>
            // accept:
            // 1. /path.aspx?d=43&gg=22#fg
            // 2. d=34&bb=534
            // 3. ?d=gg&dt=443
            this.uri = new Calysto.Uri(url);
            var qstr = (this.uri.Query || "").Trim(['?']);
            if (qstr) {
                // extract query string only
                var pairsArr = qstr.split("&");
                for (var n = 0; n < pairsArr.length; n++) {
                    var pair = pairsArr[n].split('=');
                    var name = decodeURIComponent(pair[0]);
                    var value = decodeURIComponent(pair[1]);
                    this.SetValue(name, value);
                }
            }
            return this;
        }
    }
    Calysto.QueryString = QueryString;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var ScriptLoader;
    (function (ScriptLoader) {
        function ReloadScriptNode(node) {
            let tagName = node.tagName.toLowerCase();
            let s1 = document.createElement(tagName);
            for (let n1 = 0; n1 < node.attributes.length; n1++)
                s1.setAttribute(node.attributes[n1].name, node.attributes[n1].value);
            s1["text"] = s1.textContent = node.textContent || node["text"];
            Calysto.Utility.Dom.ReplaceWith(node, [s1]);
            return s1; // return node
        }
        ScriptLoader.ReloadScriptNode = ReloadScriptNode;
        function LoadJSFile(scriptFileUrl, isAsync) {
            var s = document.createElement("script");
            s.type = "text/javascript";
            s.src = scriptFileUrl;
            s.async = !!isAsync;
            (document.getElementsByTagName("head")[0] || document.body || document.documentElement).appendChild(s);
            return s;
        }
        ScriptLoader.LoadJSFile = LoadJSFile;
        function LoadJS(javascriptCode) {
            ////if (Calysto.Core.IsDebugDefined)
            ////{
            ////	(window["$js$"] = window["$js$"] || []).push(javascriptCode);
            ////	console.log(javascriptCode);
            ////}
            var s = document.createElement("script");
            s.type = "text/javascript";
            s.text = s.textContent = javascriptCode; // ie9 or higher and gecko uses textContent, <=ie8 uses text
            (document.getElementsByTagName("head")[0] || document.body || document.documentElement).appendChild(s);
            return s;
        }
        ScriptLoader.LoadJS = LoadJS;
        function LoadCSSFile(cssFileUrl) {
            var s = document.createElement("link");
            s.rel = "stylesheet";
            s.type = "text/css";
            s.href = cssFileUrl;
            (document.getElementsByTagName("head")[0] || document.body || document.documentElement).appendChild(s);
            return s;
        }
        ScriptLoader.LoadCSSFile = LoadCSSFile;
        function LoadCSS(cssScriptCode) {
            var s = document.createElement("style");
            s.type = "text/css";
            s.text = s.textContent = cssScriptCode; // works with ie 9 or higher and gecko only, <=ie8 is not supported
            (document.getElementsByTagName("head")[0] || document.body || document.documentElement).appendChild(s);
            return s;
        }
        ScriptLoader.LoadCSS = LoadCSS;
    })(ScriptLoader = Calysto.ScriptLoader || (Calysto.ScriptLoader = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class Timer {
        constructor(onTimeout) {
            this.onTimeout = onTimeout;
            this.sleepMs = 0;
            this.items = [];
            if (onTimeout)
                this.OnTimeout(onTimeout);
        }
        IsRunning() {
            return !!this.timeoutId;
        }
        ;
        Abort() {
            if (this.timeoutId) {
                clearTimeout(this.timeoutId);
                this.timeoutId = null;
            }
            return this;
        }
        Start(delayMs) {
            /// <summary>
            /// Start new timeout. Abort previous if exists.
            /// </summary>
            /// <param name="delayMs" optional="true"></param>
            this.Abort();
            // kad se koristi lambda, this se ispravno embeda
            this.timeoutId = setTimeout(() => {
                clearTimeout(this.timeoutId);
                this.timeoutId = null;
                // invoke callback
                for (var n = 0; n < this.items.length; n++) {
                    this.items[n](this);
                }
            }, delayMs > 0 ? delayMs : 0);
            return this;
        }
        OnTimeout(func) {
            /// <summary>
            /// MulticastDelegate. Add callback function(s) to be executed on timeout.
            /// </summary>
            /// <param name="func">function(sender){...}, this inside of function is current Calysto.Timer instance</param>
            this.items.push(func);
            return this;
        }
        ;
    }
    Calysto.Timer = Timer;
    ////export class MouseTimer
    ////{
    ////	private _isBussy = false;
    ////	private _timerId: number;
    ////	constructor()
    ////	{
    ////	}
    ////	/**
    ////	 * Return true if there is another click in less than delayMs time.
    ////	 * @param delayMs If not set, default is 300 ms
    ////	 */
    ////	public IsDoubleclicked(delayMs: number = 300)
    ////	{
    ////		if (this._isBussy)
    ////			return true;
    ////		this._isBussy = true;
    ////		if (this._timerId)
    ////			clearTimeout(this._timerId);
    ////		this._timerId = setTimeout(() => this._isBussy = false, delayMs);
    ////		return false;
    ////	}
    ////}
    class BussyTimer {
        constructor(timeoutMs) {
            this.timeoutMs = timeoutMs;
            this._expires = 0;
        }
        Start() {
            this._expires = Date.now() + this.timeoutMs;
            return this;
        }
        Abort() {
            this._expires = 0;
            return this;
        }
        IsBussy() {
            return this._expires > Date.now();
        }
        /**
         * If timer is already bussy, returns true,
         * Else, set new timeout and return false.
         */
        IsBussyOrStart() {
            if (this.IsBussy()) {
                return true;
            }
            else {
                this.Start();
                return false;
            }
        }
    }
    Calysto.BussyTimer = BussyTimer;
    class MouseTimer {
        /**
         *  Default timeout 300ms.
         * @param timeoutMs default value: 300
         */
        constructor(timeoutMs = 300) {
            this._timer = new BussyTimer(timeoutMs);
        }
        /**
         * If timer is already bussy, returns true,
         * Else, set new timeout and return false.
         */
        IsDoubleclicked() {
            return this._timer.IsBussyOrStart();
        }
    }
    Calysto.MouseTimer = MouseTimer;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    let PartEnum;
    (function (PartEnum) {
        PartEnum[PartEnum["Scheme"] = 0] = "Scheme";
        PartEnum[PartEnum["Host"] = 1] = "Host";
        PartEnum[PartEnum["Port"] = 2] = "Port";
        PartEnum[PartEnum["Path"] = 3] = "Path";
        PartEnum[PartEnum["Query"] = 4] = "Query";
        PartEnum[PartEnum["Hash"] = 5] = "Hash";
    })(PartEnum || (PartEnum = {}));
    class Uri {
        /**
         * Create new instance from url.
         * @param url
         */
        constructor(url) {
            // http, https, ws, etc.
            this.Scheme = "";
            this.Username = "";
            this.Password = "";
            // domain, eg. domain.com
            this.Host = "";
            // port number as string, eg. 21
            this.Port = "";
            // eg. /path1/regs.aspx
            this.Path = "";
            // eg. ?par1=10&par2=3
            this.Query = "";
            // eg. #h1=46
            this.Hash = "";
            if (url)
                this.ParseUrl(url);
        }
        CloneUri(startKind, endKind = PartEnum.Hash) {
            let uri = new Calysto.Uri();
            if (startKind <= PartEnum.Scheme && endKind >= PartEnum.Scheme)
                uri.Scheme = this.Scheme;
            if (startKind <= PartEnum.Host && endKind >= PartEnum.Host) {
                uri.Username = this.Username;
                uri.Password = this.Password;
                uri.Host = this.Host;
            }
            if (startKind <= PartEnum.Port && endKind >= PartEnum.Port)
                uri.Port = this.Port;
            if (startKind <= PartEnum.Path && endKind >= PartEnum.Path)
                uri.Path = this.Path;
            if (startKind <= PartEnum.Query && endKind >= PartEnum.Query)
                uri.Query = this.Query;
            if (startKind <= PartEnum.Hash && endKind >= PartEnum.Hash)
                uri.Hash = this.Hash;
            return uri;
        }
        BuildUri() {
            let sb = [];
            // scheme
            if (!String.IsNullOrEmpty(this.Scheme))
                sb.push(this.Scheme + ":");
            // user, pass, host, port
            if (!String.IsNullOrEmpty(this.Host)) {
                sb.push("//");
                if (!String.IsNullOrEmpty(this.Username)) {
                    sb.push(this.Username);
                    if (!String.IsNullOrEmpty(this.Password))
                        sb.push(":" + this.Password);
                    if (!String.IsNullOrEmpty(this.Username) || !String.IsNullOrEmpty(this.Password))
                        sb.push("@");
                }
                // host
                if (!String.IsNullOrEmpty(this.Host))
                    sb.push(this.Host);
                // port
                if (this.Port)
                    sb.push(":" + this.Port);
            }
            // path
            if (!String.IsNullOrEmpty(this.Path))
                sb.push(this.Path);
            // query
            if (!String.IsNullOrEmpty(this.Query)) {
                if (!this.Query.StartsWith("?")) {
                    sb.push("?");
                }
                sb.push(this.Query);
            }
            // hash
            if (!String.IsNullOrEmpty(this.Hash)) {
                if (!this.Hash.StartsWith("#")) {
                    sb.push("#");
                }
                sb.push(this.Hash);
            }
            return sb.join("");
        }
        /**Create scheme://host:port */
        GetSchemeHost() {
            return this.CloneUri(PartEnum.Scheme, PartEnum.Port).BuildUri();
        }
        /**Create scheme://host:port/path */
        GetSchemeHostPath() {
            return this.CloneUri(PartEnum.Scheme, PartEnum.Path).BuildUri();
        }
        /**Create complete URI with hash. */
        GetAbsoluteUri() {
            return this.CloneUri(PartEnum.Scheme).BuildUri();
        }
        /** Relative url: /path?query#hash */
        GetPathQueryHash() {
            return this.CloneUri(PartEnum.Path).BuildUri();
        }
        ParseUrl(url) {
            /// <summary>
            /// Parse url.
            /// </summary>
            /// <param name="url" type="String"></param>
            // var m = "http://domainname.com:43/some1/some2/dru.aspx?qu=3&gr=3#dd=rel".match(new RegExp("(([\\w]+)\\:)?" + "((//)([^/\\:]+)(:([\\d]+))?)?" + "([^\\?\\#]+)?" + "(\\?[^\\#]+)?" + "(\\#[\\w\\W]+)?"))
            // ["http://domainname.com:43/some1/some2/dru.aspx?qu=3&gr=3#dd=rel", "http:", "http", "//domainname.com:43", "//", "domainname.com", ":43", "43", "/some1/some2/dru.aspx", "?qu=3&gr=3", "#dd=rel"]
            //var m = "http://domaena.com:233/../some2.aspx?a=10&b=22#some2".match(new RegExp("(([\\w]+)\\:)?" + "((//)([^/\\:]+)(:([\\d]+))?)?" + "(([/]?[\\.]{2})?/[^\\?\\#]*)?" + "(\\?[^\\#]+)?" + "(\\#[\\w\\W]+)?"));
            //["http://domaena.com:233/../some2.aspx?a=10&b=22#some2", "http:", "http", "//domaena.com:233", "//", "domaena.com", ":233", "233", "/../some2.aspx", "/..", "?a=10&b=22", "#some2"]
            // host starts with //
            // port starts with : followed by digit
            // path start with / or ../ or /../, path may have / only, and nothing after, eg: http://domain.com/?m=10
            // query starts with ?
            // hash starts with #
            // test:
            //"http://username:password@www.some1.com:1233/mypath/bill.aspx?a=10&b=20#c=3&c=4"
            // ["http://username:password@www.some1.com:1233/mypath/bill.aspx?a=10&b=20#c=3&c=4", "http:", "http", "//username:password@www.some1.com:1233", "//", "username:password@", "username", ":password", "password", "www.some1.com", ":1233", "1233", "/mypath/bill.aspx", "?a=10&b=20", "#c=3&c=4"]
            if (url) {
                var m = url.match(new RegExp("(([\\w]+)\\:)?" // scheme
                    + "((//)(([^\\:@]+)(:([^\\:@]+))?@)?([^/\\:]+)(:([\\d]+))?)?" // user:pass@host:port, all values are optional
                    + "(/[^\\?\\#]*)?" // path
                    + "(\\?[^\\#]+)?" // query
                    + "(\\#[\\w\\W]+)?" // hash
                ));
                if (m) {
                    this.Scheme = m[2] || "";
                    this.Username = m[6] || "";
                    this.Password = m[8] || "";
                    this.Host = m[9] || "";
                    this.Port = m[11] || "";
                    this.Path = m[12] || "";
                    this.Query = m[13] || "";
                    this.Hash = m[14] || "";
                }
            }
        }
    }
    Calysto.Uri = Uri;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Validate;
    (function (Validate) {
        /**
         *  Returns true if str is valid e-mail
         * @param str
         */
        function IsEmail(str) {
            var __emailRegexPattern = Calysto.Constants.AppConstants.EmailRegexPattern;
            str += ""; // convert to string
            return !!(str && str.match(new RegExp(__emailRegexPattern)));
        }
        Validate.IsEmail = IsEmail;
        /**
         * Returns true if str is valid number formated in current culture, eg. - 43.634,634, but not - 43,53 kn (may include -,.0-9, no currency symbol)
         * @param str
         */
        function CanConvertToNumber(str) {
            str += ""; // convert to string
            return !!(str && str.match(new RegExp("^[\\-]*[ ]*[ \\.\\,]?[\\d]+[\\d\\.\\,]*$")));
        }
        Validate.CanConvertToNumber = CanConvertToNumber;
        ;
        /**
         * same as IsNumber()
         * @param str
         */
        function CanConvertToDecimal(str) {
            return CanConvertToNumber(str);
        }
        Validate.CanConvertToDecimal = CanConvertToDecimal;
        /**
         * Returns true if str is valid integer, eg. -34534 (may not include any other symbol)
         * @param str
         */
        function CanConvertToInteger(str) {
            str += ""; // convert to string
            return !!(str && str.match(new RegExp("^[\\- ]?[\\d]+$")));
        }
        Validate.CanConvertToInteger = CanConvertToInteger;
        ;
        /**
         * Returns true if str contains valid number, eg. last - 43.634,634 kn
         * @param str
         */
        function ContainsNumber(str) {
            str += ""; // convert to string
            return !!(str && str.match(new RegExp("[\\- ]?[ \\.\\,]?[\\d]+[\\d\\.\\,]*")));
        }
        Validate.ContainsNumber = ContainsNumber;
        ;
        /**
         * Is valid date formated in current culture.
         * @param str
         * @param format
         */
        function CanConvertToDate(str, format) {
            let refArr = new Calysto.BoxValue();
            return Calysto.DateFormat.TryParseExact(str, format || Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern, refArr);
        }
        Validate.CanConvertToDate = CanConvertToDate;
        ;
        /**
         * Is valid dateTime in current culture.
         * @param str
         * @param format
         */
        function CanConvertToDateTime(str, format) {
            let refArr = new Calysto.BoxValue();
            return Calysto.DateFormat.TryParseExact(str, format || Calysto.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.GeneralLongTimePattern, refArr);
        }
        Validate.CanConvertToDateTime = CanConvertToDateTime;
        ;
        function CanConvertToByte(str) {
            var val = parseFloat(str);
            return (isFinite(val) && val > 0 && val < 256) || val === 0;
        }
        /**
         * Is valid IPv4 address d.d.d.d
         * @param str
         */
        function IsIPv4Address(str) {
            var m = str.match(new RegExp("^([\\d]+)\\.([\\d]+)\\.([\\d]+)\\.([\\d]+)$"));
            return !!(m && CanConvertToByte(m[1]) && CanConvertToByte(m[2]) && CanConvertToByte(m[3]) && CanConvertToByte(m[4]));
        }
        Validate.IsIPv4Address = IsIPv4Address;
    })(Validate = Calysto.Validate || (Calysto.Validate = {}));
})(Calysto || (Calysto = {}));
/*
Modifier	Description
i		Perform case-insensitive matching
g		Perform a global match (find all matches rather than stopping after the first match)
m		Perform multiline matching

Expression	Description
[abc]	Find any character between the brackets
[^abc]	Find any character NOT between the brackets
[0-9]	Find any digit between the brackets
[^0-9]	Find any digit NOT between the brackets
(x|y)	Find any of the alternatives specified

Metacharacter	Description
.		Find a single character, except newline or line terminator
\w	Find a word character
\W	Find a non-word character
\d		Find a digit
\D		Find a non-digit character
\s		Find a whitespace character
\S		Find a non-whitespace character
\b		Find a match at the beginning/end of a word
\B		Find a match not at the beginning/end of a word
\0		Find a NUL character
\n		Find a new line character
\f		Find a form feed character
\r		Find a carriage return character
\t		Find a tab character
\v		Find a vertical tab character
\xxx		Find the character specified by an octal number xxx
\xdd		Find the character specified by a hexadecimal number dd
\uxxxx		Find the Unicode character specified by a hexadecimal number xxxx

Quantifier	Description
n+	Matches any string that contains at least one n
n*	Matches any string that contains zero or more occurrences of n
n?		Matches any string that contains zero or one occurrences of n
n{X}		Matches any string that contains a sequence of X n's
n{X,Y}	Matches any string that contains a sequence of X to Y n's
n{X,}	Matches any string that contains a sequence of at least X n's
n$	Matches any string with n at the end of it
^n	Matches any string with n at the beginning of it
?=n	Matches any string that is followed by a specific string n
?!n	Matches any string that is not followed by a specific string n
*/
var Calysto;
(function (Calysto) {
    class Regex {
        constructor(regexPattern, ignoreCase = false) {
            this.ignoreCase = false;
            this.regexPattern = regexPattern || "";
            this.ignoreCase = ignoreCase;
        }
        /**
         * Escapes a minimal set of characters (\, *, +, ?, |, {, [, (,), ^, $,., #, and white space) and return string with escaped chars.
         * @param str
         */
        static Escape(str) {
            return RegExp.Escape(str);
        }
        CreateRegex(isGlobal = false) {
            return new RegExp(this.regexPattern, (this.ignoreCase ? "i" : "") + (isGlobal ? "g" : ""));
        }
        CreateMatchSegment(currMatch, index, success) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="match" type="Match|String"></param>
            /// <param name="index" type="Int" optional="true"></param>
            /// <param name="success" type="bool" optional="true"></param>
            /// <returns type=""></returns>
            var matchArr;
            if (typeof (currMatch) == "string") {
                matchArr = [currMatch];
                matchArr.index = index || 0;
                matchArr.success = !!success;
            }
            else {
                matchArr = currMatch;
            }
            var str = matchArr[0] || "";
            return ({
                /**[boolean] true if match is successful, else false*/
                Success: !!(arguments.length > 2 ? success : str),
                /**[int] start position in original string*/
                Index: arguments.length > 1 ? index : matchArr ? matchArr.index : -1,
                /**[int] length of match text*/
                Length: str.length,
                /**[string] complete match text value*/
                Value: str,
                /**[string[]] Gropus*/
                Groups: matchArr
            });
        }
        /**
         * Returns true if regex match is found
         * @param {string} inputStr
         * @returns
         */
        IsMatch(inputStr) {
            /// <summary>
            /// Returns true if regex match is found.
            /// </summary>
            /// <param name="inputStr"></param>
            /// <returns type="Boolean"></returns>
            return this.CreateRegex(false).test(inputStr);
        }
        /**
         * Returns IEnumerable of matched items
         * @param {string} inputStr
         * @param {number} startIndex?
         * @param {number} length?
         * @returns
         */
        SelectMatches(inputStr, startIndex, length) {
            /// <summary>
            /// Returns IEnumerable of matched items.
            /// </summary>
            /// <param name="input" type="String"></param>
            /// <param name="startIndex" type="Int" optional="true"></param>
            return new Calysto.CalystoEnumerable(() => {
                if (!!startIndex && startIndex > 0)
                    inputStr = inputStr.substr(startIndex || 0);
                if (!!length && length > 0)
                    inputStr = inputStr.substr(0, length || 0);
                // g flag returns all matches, without g flag, exec returns first match only
                // in while, always use g flag, without g flag, endless loop will occure
                var re = this.CreateRegex(true);
                var m;
                return Calysto.CalystoEnumerator.FromYieldFunc((refYield) => {
                    if ((m = re.exec(inputStr)) && m[0]) {
                        refYield.SetValue(this.CreateMatchSegment(m));
                        return true;
                    }
                    return false;
                });
            });
        }
        /**
         * Returns IEnumerable with matches and unmatches.
         * @param {string} inputStr
         * @param {number} startIndex?
         * @param {number} length?
         * @returns
         */
        SelectSegments(inputStr, startIndex, length) {
            /// <summary>
            /// Returns IEnumerable with matches and unmatches.
            /// </summary>
            /// <param name="input" type="String"></param>
            /// <param name="startIndex" type="Int" optional="true"></param>
            /// <param name="length" type="String" optional="true"></param>
            return new Calysto.CalystoEnumerable(() => {
                if (!!startIndex && startIndex > 0)
                    inputStr = inputStr.substr(startIndex || 0);
                if (!!length && length > 0)
                    inputStr = inputStr.substr(0, length || 0);
                // g flag returns all matches, without g flag, exec returns first match only
                // in while, always use g flag, without g flag, endless loop will occure
                var re = this.CreateRegex(true);
                var m;
                var startPosition = 0;
                var segment;
                var len = 0;
                var stack = [];
                var match;
                return Calysto.CalystoEnumerator.FromYieldFunc((refYield) => {
                    while (stack.length > 0) {
                        refYield.SetValue(stack.shift());
                        return true;
                    }
                    if (startPosition >= inputStr.length)
                        return false;
                    if ((m = re.exec(inputStr)) && m[0]) {
                        match = this.CreateMatchSegment(m);
                        if (match.Index > startPosition) {
                            segment = inputStr.substr(startPosition, match.Index - startPosition);
                            len = segment.length;
                            stack.push(this.CreateMatchSegment(segment, startPosition, false)); // this is un-match
                            // new position:
                            startPosition += len;
                        }
                        stack.push(match);
                        // new position:
                        startPosition = match.Index + match.Length;
                    }
                    while (stack.length > 0) {
                        refYield.SetValue(stack.shift());
                        return true;
                    }
                    // if there is something left
                    segment = inputStr.substr(startPosition);
                    len = segment.length;
                    if (len > 0) {
                        // something has left at the end
                        stack.push(this.CreateMatchSegment(segment, startPosition, false));
                        // new position:
                        startPosition += len;
                    }
                    if (stack.length > 0) {
                        refYield.SetValue(stack.shift());
                        return true;
                    }
                    return false; // no more data
                });
            });
        }
        /**
         * Returns all matches as array.
         * @param {string} inputStr
         * @param {number} startIndex?
         * @param {number} length?
         * @returns
         */
        Matches(inputStr, startIndex, length) {
            /// <summary>
            /// Returns all matches as array.
            /// </summary>
            /// <param name="inputStr" type="string"></param>
            /// <param name="startIndex" type="int" optional="true"></param>
            /// <param name="length" type="int" optional="true"></param>
            return this.SelectMatches(inputStr, startIndex, length).ToArray();
        }
        /**
         * Find and returns first match
         * @param {string} inputStr
         * @param {number} startIndex?
         * @param {number} length?
         * @returns
         */
        Match(inputStr, startIndex, length) {
            /// <summary>
            /// Find and returns first match.
            /// </summary>
            /// <param name="inputStr" type="string"></param>
            /// <param name="startIndex" type="int" optional="true"></param>
            /// <param name="length" type="int" optional="true"></param>
            /*
                new RegExp(...).exec(inputStr) with "g" flag returns all matches, without "g" flag, returns first match only
                match item is array with properties:
                    0: "ante" // full match
                    1: "te"		// first group
                    2: "mb"		// second group
                    index: 0	// position in inputStr
                    input: "anteantefadsantefdsante" // inputStr
                    length: 2	// items in this array
            */
            var m1 = this.CreateRegex(false).exec(inputStr);
            return m1 ? this.CreateMatchSegment(m1) : null;
        }
        Replace(input, replacement) {
            if (!input)
                return input;
            let re1 = this.CreateRegex(true);
            return input.replace(re1, replacement);
        }
    }
    Calysto.Regex = Regex;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class CalystoStyleSheet {
        constructor() {
            this.disabledPrefix = "-calysto-disabled-rule-";
            this.sheets = [];
        }
        Sheets() {
            if (!this.sheets) {
                var s = Calysto.ScriptLoader.LoadCSS("");
                s["disabled"] = true;
                this.sheets = [s.sheet]; // s must be in DOM, else s.sheet is null
            }
            return this.sheets;
        }
        /**
         * Select rules by cssSelector. Will select disabled rules too.
         * @param cssSelector
         */
        SelectRules(cssSelector) {
            /// <summary>
            /// Select rules by cssSelector. Will select disabled rules too.
            /// </summary>
            /// <param name="cssSelector" optional="true" type="string">If not set, will select all rules.</param>
            var dicProp = this.disabledPrefix + (cssSelector == "*" ? "" : cssSelector);
            return this.Sheets().AsEnumerable()
                .SelectMany(sheet => sheet.cssRules)
                .Where(o => !!o.selectorText)
                .Select(rule => {
                if (!rule.selectorArray) {
                    rule.selectorArray = rule.selectorText.split(",").AsEnumerable().Select(o => o.Trim()).ToArray();
                    rule.selectorDic = rule.selectorArray.AsEnumerable().ToDictionary(o => o, o => true);
                }
                return rule;
            })
                .Where(rule => {
                if (cssSelector) {
                    return rule.selectorDic.ContainsKey(cssSelector) || rule.selectorDic.ContainsKey(dicProp);
                }
                else {
                    return true;
                }
            });
        }
        GetIndex(cssRules, rule) {
            for (var n = 0; n < cssRules.length; n++) {
                if (cssRules[n] == rule) {
                    return n;
                }
            }
            return -1;
        }
        DeleteRule(rule) {
            if (rule.parentStyleSheet)
                rule.parentStyleSheet.deleteRule(this.GetIndex(rule.parentStyleSheet.cssRules, rule));
        }
        /**
         * new rule will not have .selectorArray, so new selectorDic will be created to on next .Rules() invocation
         * @param rule
         */
        RecreateRule(rule) {
            /// <summary>
            /// new rule will not have .selectorArray, so new selectorDic will be created to on next .Rules() invocation
            /// </summary>
            /// <param name="rule" type="CSSStyleRule"></param>
            // since selectorText can't be modified on firefox, we have to delete current rule and create new at the same index position
            var sheet = rule.parentStyleSheet;
            if (sheet) {
                var style = rule.style.cssText;
                var index = this.GetIndex(sheet.cssRules, rule);
                var newSelector = rule.selectorArray.join(", ");
                if (newSelector) {
                    sheet.insertRule(newSelector + "{" + style + "}", index);
                }
            }
        }
        /**
         * Split multiple selectors. Create  new rule for each single selector
         * @param cssSelector
         */
        SplitSelectors(cssSelector) {
            /// <summary>
            /// Split multiple selectors. Create  new rule for each single selector.
            /// </summary>
            /// <param name="cssSelector" type="string" optional="true">If not set, will select all rules.</param>
            this.SelectRules(cssSelector).ForEach(rule => {
                rule.selectorArray.AsEnumerable().ForEach(selector => {
                    rule.selectorDic = null;
                    rule.selectorArray = [selector];
                    this.RecreateRule(rule);
                });
                this.DeleteRule(rule);
            });
            return this;
        }
        /**
         * Add new selector to existing rule.
         * @param cssSelector
         * @param newSelector
         */
        AddSelector(cssSelector, newSelector) {
            /// <summary>
            /// Add new selector to existing rule.
            /// </summary>
            /// <param name="cssSelector">rule with existing selector</param>
            /// <param name="newSelector">new selector to be added to rule</param>
            if (newSelector) {
                this.SelectRules()
                    .Where(rule => rule.selectorDic.ContainsKey(cssSelector) && !rule.selectorDic.ContainsKey(newSelector))
                    .ForEach(rule => {
                    rule.selectorArray.push(newSelector);
                    // since selectorText can't be modified on FF, we have to replace current rule with new one with different selector
                    this.RecreateRule(rule);
                    this.DeleteRule(rule);
                });
            }
            return this;
        }
        /**
         * Remove cssSelector from rule, but leave rule with other selectors. If there is not more selectors left, will delete rule too.
         * @param cssSelector
         */
        RemoveSelector(cssSelector) {
            /// <summary>
            /// Remove cssSelector from rule, but leave rule with other selectors. If there is not more selectors left, will delete rule too.
            /// </summary>
            /// <param name="cssSelector"></param>
            this.SelectRules(cssSelector)
                .ForEach(rule => {
                rule.selectorArray = rule.selectorArray.Where(k => k != cssSelector);
                // since selectorText can't be modified on FF, we have to replace current rule with new one with different selector
                this.RecreateRule(rule);
                this.DeleteRule(rule);
            });
            return this;
        }
        AddRule(cssSelector, style) {
            /// <summary>
            /// Create new rule and add to rules.
            /// </summary>
            /// <param name="cssSelector"></param>
            /// <param name="style"></param>
            var sheets = this.Sheets();
            var current = sheets[sheets.length - 1];
            if (current.addRule) {
                current.addRule(cssSelector, style);
            }
            else if (current.insertRule) {
                // firefox specific
                // myStyle.insertRule(css, index);
                // myStyle.insertRule("#blanc { color: white }", 0);
                current.insertRule(cssSelector + "{" + style + "}", current.cssRules.length); // add to the end
            }
            return this;
        }
        RemoveRules(cssSelector) {
            /// <summary>
            /// Remove complete rule from sheet where cssSelector exists.
            /// </summary>
            /// <param name="cssSelector"></param>
            this.SelectRules(cssSelector).ForEach(rule => {
                if (rule.parentStyleSheet)
                    rule.parentStyleSheet.deleteRule(this.GetIndex(rule.parentStyleSheet.cssRules, rule));
            });
            return this;
        }
        DisableRules(cssSelector) {
            /// <summary>
            /// Disable rules by cssSelector.
            /// </summary>
            /// <param name="cssSelector" optional="true" type="string">If not set, will disable all rules.</param>
            this.SelectRules(cssSelector).ForEach(rule => {
                rule.selectorArray = rule.selectorArray.Select(k => {
                    if (!cssSelector || k == cssSelector) {
                        if (k.indexOf(this.disabledPrefix) == 0) {
                            return k;
                        }
                        else {
                            // * at the end is not acceptable for .selectorText, use prefix only
                            return this.disabledPrefix + (k == "*" ? "" : k);
                        }
                    }
                    else {
                        return k;
                    }
                });
                this.RecreateRule(rule);
                this.DeleteRule(rule);
            });
            return this;
        }
        ;
        EnableRules(cssSelector) {
            var dicProp = this.disabledPrefix + (cssSelector == "*" ? "" : cssSelector);
            this.SelectRules(cssSelector).ForEach(rule => {
                rule.selectorArray = rule.selectorArray.Select(k => {
                    if (!cssSelector) {
                        return k.replace(this.disabledPrefix, "") || "*";
                    }
                    else if (k == dicProp) {
                        return cssSelector;
                    }
                    else {
                        return k;
                    }
                });
                this.RecreateRule(rule);
                this.DeleteRule(rule);
            });
            return this;
        }
        ToCssText(separator) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="separator" type="string"></param>
            return this.SelectRules().Select(o => o.cssText).ToStringJoined(separator || "");
        }
        /**
         * Get all sheets from current document
         */
        static GetCurrent() {
            if (document.styleSheets.length == 0) {
                Calysto.ScriptLoader.LoadCSS("");
            }
            var ss = new CalystoStyleSheet();
            ss.sheets = [];
            for (let n = 0; n < document.styleSheets.length; n++) {
                ss.sheets.push(document.styleSheets[n]);
            }
            return ss;
        }
    }
    Calysto.CalystoStyleSheet = CalystoStyleSheet;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json) {
        var Infrastructure;
        (function (Infrastructure) {
            // clone from C#: Calysto.Serialization.Json.Core.Converters.CalystoBlobConverter.JsonBlob
            class JsonBlob {
                constructor() {
                    /** string */
                    this.__calystotype = "Calysto_Blob";
                }
            }
            Infrastructure.JsonBlob = JsonBlob;
            // clone from C#: Calysto.Serialization.Json.Core.Converters.DateTimeConverter.JsonDateTime
            class JsonDateTime {
                constructor() {
                    /** string */
                    this.__calystotype = "Calysto_Date";
                }
            }
            Infrastructure.JsonDateTime = JsonDateTime;
            class JsonFunction {
                constructor() {
                    this.__calystotype = "Calysto_Function";
                }
            }
            Infrastructure.JsonFunction = JsonFunction;
            Infrastructure.escapeeChars = {
                "\b": '\\b',
                "\t": '\\t',
                "\n": '\\n',
                "\f": '\\f',
                "\r": '\\r',
                '"': '\\"',
                "\\": '\\\\'
            };
        })(Infrastructure = Json.Infrastructure || (Json.Infrastructure = {}));
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
/// <reference path="Json.Infrastructure.ts" />
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json) {
        var Infrastructure;
        (function (Infrastructure) {
            class CalystoJsonSerializer {
                constructor(isAsync = false) {
                    this.parts = [];
                    this.blobs = [];
                    this.indexes = [];
                    this.isAsync = false;
                    this.escapee = Infrastructure.escapeeChars;
                    this.SerializeFunctions = false;
                    this.parts = [];
                    this.blobs = [];
                    this.indexes = [];
                    this.isAsync = !!isAsync;
                }
                Write(str) { this.parts.push(str); }
                isArray(v) { return v && typeof v.pop == 'function'; }
                isDate(v) { return v && typeof v.getFullYear == 'function'; }
                encodeString(s) {
                    var s1 = s.replace(new RegExp('([\\\\\x00-\x1f\\"])', 'g'), (a, b) => {
                        var c = this.escapee[b];
                        if (c) {
                            return c;
                        }
                        c = b.charCodeAt();
                        return "\\u00" +
                            Math.floor(c / 16).toString(16) +
                            (c % 16).toString(16);
                    });
                    this.Write('"' + s1 + '"');
                }
                encodeArray(o, recursionLeft) {
                    this.Write("[");
                    var addComma, n, len = o.length, val, vtype;
                    for (n = 0; n < len; n++) {
                        val = o[n];
                        vtype = typeof val;
                        if (vtype == "undefined") {
                            // nothing
                        }
                        else if (vtype == "function" && !this.SerializeFunctions) {
                            // nothing
                        }
                        else {
                            if (addComma) {
                                this.Write(",");
                            }
                            if (val === null) {
                                this.Write("null");
                            }
                            else {
                                this.serializeWithCalysto(val, recursionLeft - 1);
                            }
                            addComma = true;
                        }
                    }
                    this.Write("]");
                }
                createJsonDateTime(o) {
                    var obj = new Infrastructure.JsonDateTime();
                    obj.Date = Date.ToLocalISOTString(o);
                    return obj;
                }
                serializeDate(o) {
                    // use current date, without time zone info, we add Z, but time zone is ignored
                    // this way we send exact date and time as it is visible to user, ignoring client time zone, this way values are presented in GUI
                    this.Write(new CalystoJsonSerializer().Serialize(this.createJsonDateTime(o)));
                }
                createJsonFunction(o) {
                    let obj = new Infrastructure.JsonFunction();
                    obj.Function = o + "";
                    return obj;
                }
                serializeFunction(o) {
                    this.Write(new CalystoJsonSerializer().Serialize(this.createJsonFunction(o)));
                }
                createBlob(o) {
                    if (!this.isAsync) {
                        throw new Error("Blob type serialization requires async serializer mode");
                    }
                    // must generate numeric placeholder, when used JSON.stringify, this value is serialized into string, so avoid serializing into string with quotes "...", use number
                    var uid = (this.blobs.length + 100 + Math.random()) + ""; // add prefix to make sure the value is changing if random fails :)
                    this.blobs.push({ UID: uid, BLOB: o }); // UID is used later in .replace(), so we need string
                    return uid;
                }
                serializeBlob(o) {
                    this.Write(this.createBlob(o));
                }
                asyncSerializeBlobs(stateObj) {
                    var item1;
                    if (stateObj.blobsCopy && stateObj.blobsCopy.length > 0 && (item1 = stateObj.blobsCopy[++stateObj.currentIndex])) {
                        var obj = new Infrastructure.JsonBlob();
                        ////obj.DataUrl = null;
                        ////obj.BlobIndex = null;
                        obj.FileName = item1.BLOB.name || item1.BLOB.filename || "";
                        obj.MimeType = item1.BLOB.type;
                        obj.Size = item1.BLOB.size;
                        if (stateObj.useBlobIndex) {
                            obj.BlobIndex = stateObj.currentIndex;
                            stateObj.json = stateObj.json.replace(item1.UID, new CalystoJsonSerializer().Serialize(obj));
                            this.asyncSerializeBlobs(stateObj);
                        }
                        else {
                            // converting to dataUrl has to be done async
                            // encode Blob to dataURL base64
                            Calysto.Utility.Blob.BlobToDataUrlAsync(item1.BLOB, (dataUrl) => {
                                obj.DataUrl = dataUrl;
                                stateObj.json = stateObj.json.replace(item1.UID, new CalystoJsonSerializer().Serialize(obj));
                                this.asyncSerializeBlobs(stateObj);
                            });
                        }
                    }
                    else {
                        // complete
                        stateObj.onComplete(stateObj.json, stateObj.pureBlobs);
                    }
                }
                serializeWithJsonStringify(objectToSerialize) {
                    var _reDate = new RegExp("^[\\d]{4}[\\-][\\d]{2}[\\-][\\d]{2}T[\\d]{2}[\\:][\\d]{2}[\\:][\\d]{2}[\\.][\\d]{3}Z$");
                    return JSON.stringify(objectToSerialize, (key, value) => {
                        let vtype = typeof value;
                        if (vtype == "undefined" || value == null) {
                            return null;
                        }
                        else if (vtype == "function") {
                            if (this.SerializeFunctions) {
                                return this.createJsonFunction(value);
                            }
                            else {
                                return value;
                            }
                        }
                        else if (value.constructor == window.FileList) // VS intellisense doesn't work with instanceof
                         {
                            var arr = [];
                            for (var n1 = 0; n1 < value.length; n1++) {
                                arr.push(value[n1]);
                            }
                            return arr;
                        }
                        else if (value.constructor == window.File) {
                            return this.createBlob(value);
                        }
                        else if (value.constructor == window.Blob) {
                            return this.createBlob(value);
                        }
                        else if (value.constructor == Calysto.DateTime) {
                            return this.createJsonDateTime(value.ToSystemDate());
                        }
                        else if (this.isDate(value)) {
                            // stringify doesn't send Date object, but string instead: "2016-07-02T11:08:25.244Z"
                            // so, it will never come here
                            return this.createJsonDateTime(value);
                        }
                        else if (typeof (value) == "string" && _reDate.test(value)) {
                            // stringify doesn't send Date object, but string instead: "2016-07-02T11:08:25.244Z"
                            return this.createJsonDateTime(new Date(value));
                        }
                        else if (typeof value == "number") {
                            return isFinite(value) ? value : null;
                        }
                        else if (this.isArray(value)) {
                            return value;
                        }
                        else if (value && value["ToArray"]) {
                            return value.ToArray();
                        }
                        else {
                            return value;
                        }
                    });
                }
                serializeWithCalysto(objectToSerialize, recursionLeft) {
                    ///<summary>Serialize object to JSON string.</summary>
                    ///<param name="objectToSerialize" type="Object|String">Object to serialize</param>
                    ///<returns type="String|Null">JSON string</returns>
                    var o = objectToSerialize;
                    let vtype = typeof o;
                    if (vtype == "undefined" || o === null) {
                        return this.Write("null");
                    }
                    else if (this.isArray(o)) {
                        if (recursionLeft < 1) {
                            return this.Write("[...]");
                        }
                        return this.encodeArray(o, recursionLeft - 1);
                    }
                    else if (o.constructor == Calysto.DateTime) {
                        return this.serializeDate(o.ToSystemDate());
                    }
                    else if (o.constructor == window.FileList) // VS intellisense doesn't work with instanceof
                     {
                        this.encodeArray(o, recursionLeft - 1);
                    }
                    else if (o.constructor == window.File) {
                        return this.serializeBlob(o);
                    }
                    else if (o.constructor == window.Blob) {
                        return this.serializeBlob(o);
                    }
                    else if (this.isDate(o)) {
                        return this.serializeDate(o);
                    }
                    else if (vtype == "function") {
                        if (this.SerializeFunctions) {
                            return this.serializeFunction(o);
                        }
                        else {
                            return null;
                        }
                    }
                    else if (typeof o == "string") {
                        return this.encodeString(o);
                    }
                    else if (typeof o == "number") {
                        return this.Write(isFinite(o) ? String(o) : "null");
                    }
                    else if (typeof o == "boolean") {
                        return this.Write(String(o));
                    }
                    else if ("ToArray" in o) {
                        return this.serializeWithCalysto(o.ToArray(), recursionLeft - 1);
                    }
                    else {
                        if (recursionLeft < 1) {
                            return this.Write("{...}");
                        }
                        this.Write("{");
                        var addComma, propName, value;
                        for (propName in o) {
                            try {
                                if (!o.hasOwnProperty(propName))
                                    continue;
                                // must be in try-catch
                                // Failed to read the 'responseXML' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'document' (was 'text').
                                value = o[propName];
                            }
                            catch (e111) {
                                continue;
                            }
                            if (typeof value == "function" && !this.SerializeFunctions) {
                                // ignore
                            }
                            else {
                                if (addComma) {
                                    this.Write(',');
                                }
                                this.serializeWithCalysto(propName, recursionLeft - 1);
                                this.Write(":");
                                if (value === null || typeof (value) == "undefined" || value == NaN) {
                                    this.Write("null");
                                }
                                else {
                                    this.serializeWithCalysto(value, recursionLeft - 1);
                                }
                                addComma = true;
                            }
                        }
                        return this.Write("}");
                    }
                }
                serializeObject(objectToSerialize, recursionLimit) {
                    // stringify doesn't have recursion limit
                    if (window.JSON && !recursionLimit) {
                        return this.serializeWithJsonStringify(objectToSerialize);
                    }
                    else // use Calysto serializer
                     {
                        this.serializeWithCalysto(objectToSerialize, recursionLimit);
                        return this.parts.join("");
                    }
                }
                SerializeAsync(objectToSerialize, recursionLimit, useBlobIndex, onComplete) {
                    /// <summary>
                    /// Serialize Blobs
                    /// </summary>
                    /// <param name="objectToSerialize" type="Object"></param>
                    /// <param name="recursionLimit" type="Number"></param>
                    /// <param name="useBlobIndex" type="Boolean">true to create blob indexex inside JSON, false to create dataURL-s for blobs inside JSON</param>
                    /// <param name="onComplete" type="Function">function(json, blobsArray){....}</param>
                    var json = this.serializeObject(objectToSerialize, recursionLimit);
                    // serialize blobs if there is any
                    var arr1 = [];
                    if (useBlobIndex && this.blobs.length > 0) {
                        Calysto.Collections.ForEach(this.blobs, (item, index) => arr1.push(item.BLOB));
                    }
                    this.asyncSerializeBlobs(({
                        currentIndex: -1,
                        json: json,
                        pureBlobs: arr1,
                        blobsCopy: this.blobs.slice(0),
                        useBlobIndex: useBlobIndex,
                        onComplete: onComplete
                    }));
                }
                ;
                Serialize(objectToSerialize, recursionLimit = 100) {
                    /// <summary>
                    /// Serialize sync, Blobs are not serialized
                    /// </summary>
                    /// <param name="objectToSerialize" type="Object"></param>
                    /// <param name="recursionLimit" type="Number"></param>
                    return this.serializeObject(objectToSerialize, recursionLimit);
                }
            }
            Infrastructure.CalystoJsonSerializer = CalystoJsonSerializer;
        })(Infrastructure = Json.Infrastructure || (Json.Infrastructure = {}));
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
/// <reference path="Json.Infrastructure.ts" />
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json) {
        var Infrastructure;
        (function (Infrastructure) {
            class CalystoJsonReader {
                // JsonReader used if window.JSON is not supported in browser
                constructor(json, blobsArray) {
                    this.json = json;
                    this.blobsArray = blobsArray;
                    this.index = -1; // The index of the current character
                    this.escapee = Infrastructure.escapeeChars;
                }
                Error(m) {
                    // must use throw to stop execution, otherwise, it would throw at least 2 exceptions
                    throw new Error("JSON Error: " + m + ", position: " + this.index + ", json: " + this.json);
                }
                Next(c1) {
                    // If a c parameter is provided, verify that it matches the current character.
                    if (c1 && c1 !== this.currchar) {
                        this.Error("Expected '" + c1 + "' instead of '" + this.currchar + "'");
                    }
                    // Get the next character. When there are no more characters,
                    // return the empty string.
                    this.currchar = this.json.charAt(this.index);
                    this.index++;
                    return this.currchar;
                }
                Number() {
                    // Parse a number value.
                    let str1 = "";
                    if (this.currchar == "-") {
                        str1 = "-";
                        this.Next("-");
                    }
                    while (this.currchar >= "0" && this.currchar <= "9") {
                        str1 += this.currchar;
                        this.Next();
                    }
                    if (this.currchar == ".") {
                        str1 += ".";
                        while (this.Next() && this.currchar >= "0" && this.currchar <= "9") {
                            str1 += this.currchar;
                        }
                    }
                    if ((this.currchar == "e") || (this.currchar == "E")) {
                        str1 += this.currchar;
                        this.Next();
                        if (this.currchar == "-" || this.currchar == "+") {
                            str1 += this.currchar;
                            this.Next();
                        }
                        while (this.currchar >= "0" && this.currchar <= "9") {
                            str1 += this.currchar;
                            this.Next();
                        }
                    }
                    let value = (+(str1)); /// parse string into number
                    if (!isFinite(value)) {
                        this.Error("Bad number");
                        return null;
                    }
                    else {
                        return value;
                    }
                }
                String() {
                    // Parse a string value.
                    var hex;
                    var i;
                    var value = "";
                    var uffff;
                    // When parsing for string values, we must look for " and \ characters.
                    if (this.currchar == "\"") {
                        while (this.Next()) {
                            if (this.currchar == "\"") {
                                this.Next();
                                return value;
                            }
                            if (this.currchar == "\\") {
                                this.Next();
                                if (this.currchar == "u") {
                                    uffff = 0;
                                    for (i = 0; i < 4; i += 1) {
                                        hex = parseInt(this.Next(), 16);
                                        if (!isFinite(hex)) {
                                            break;
                                        }
                                        uffff = uffff * 16 + hex;
                                    }
                                    value += String.fromCharCode(uffff);
                                }
                                else if (this.currchar && typeof this.escapee[this.currchar] == "string") {
                                    value += this.escapee[this.currchar];
                                }
                                else {
                                    break;
                                }
                            }
                            else {
                                value += this.currchar;
                            }
                        }
                    }
                    this.Error("Bad string");
                    return;
                }
                White() {
                    // Skip whitespace.
                    while (this.currchar && this.currchar <= " ") {
                        this.Next();
                    }
                }
                Word() {
                    // true, false, or null.
                    switch (this.currchar) {
                        case "t":
                            this.Next("t");
                            this.Next("r");
                            this.Next("u");
                            this.Next("e");
                            return true;
                        case "f":
                            this.Next("f");
                            this.Next("a");
                            this.Next("l");
                            this.Next("s");
                            this.Next("e");
                            return false;
                        case "n":
                            this.Next("n");
                            this.Next("u");
                            this.Next("l");
                            this.Next("l");
                            return null;
                    }
                    this.Error("Unexpected '" + this.currchar + "'");
                    return;
                }
                Array() {
                    // Parse an array value.
                    let arr = [];
                    if (this.currchar == '[') {
                        this.Next("[");
                        this.White();
                        if (this.currchar == "]") {
                            this.Next("]");
                            return arr; // empty array
                        }
                        while (this.currchar) {
                            arr.push(this.Value());
                            this.White();
                            if (this.currchar == "]") {
                                this.Next("]");
                                return arr;
                            }
                            this.Next(",");
                            this.White();
                        }
                    }
                    this.Error("Bad array");
                    return;
                }
                Object() {
                    // Parse an object value.
                    var key;
                    var obj = {};
                    if (this.currchar == "{") {
                        this.Next("{");
                        this.White();
                        if (this.currchar == "}") {
                            this.Next("}");
                            return obj; // empty object
                        }
                        while (this.currchar) {
                            key = this.String();
                            this.White();
                            this.Next(":");
                            if (Object.hasOwnProperty.call(obj, key)) {
                                this.Error("Duplicate key '" + key + "'");
                            }
                            obj[key] = this.Value();
                            this.White();
                            if (this.currchar == "}") {
                                this.Next("}");
                                return obj;
                            }
                            this.Next(",");
                            this.White();
                        }
                    }
                    this.Error("Bad object");
                    return;
                }
                Value() {
                    // Parse a JSON value. It could be an object, an array, a string, a number,
                    // or a word.
                    this.White();
                    switch (this.currchar) {
                        case "{":
                            {
                                var obj1 = this.Object();
                                // run object conveter for Calysto objects
                                obj1 = Json.fnJsonPostConvertObject(obj1, this.blobsArray);
                                return obj1;
                            }
                        case "[":
                            return this.Array();
                        case "\"":
                            return this.String();
                        case "-":
                            return this.Number();
                        default:
                            return (this.currchar >= "0" && this.currchar <= "9")
                                ? this.Number()
                                : this.Word();
                    }
                }
                Parse() {
                    var result;
                    this.index = 0;
                    this.currchar = " ";
                    result = this.Value();
                    this.White();
                    if (this.currchar) {
                        this.Error("Syntax error");
                    }
                    return result;
                }
            }
            Infrastructure.CalystoJsonReader = CalystoJsonReader;
        })(Infrastructure = Json.Infrastructure || (Json.Infrastructure = {}));
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
/// <reference path="Json.Infrastructure.ts" />
/// <reference path="json.infrastructure.calystojsonserializer.ts" />
/// <reference path="json.infrastructure.calystojsonreader.ts" />
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json) {
        /*
        // // "2014-02-01T09:28:56.321Z", Z: UTC
        // "2014-02-01T09:28:56.321-01:00", time zone -1h
        // "2015-04-25T11:37:32.323Z" // when T or Z exists, new Date("2015-04-25T11:37:32.323Z") convert to utc time (9:37) + time zone if local time zone is +02:00
        // "2015-04-25 11:37:32.323" // without T and Z, new Date("2015-04-25 11:37:32.323") convert to exact time (11:37) + time zone
        */
        // Calysto.JSON.Deserialize
        function fnJsonDeserialize(jsonString, blobsArray) {
            ///<summary>Deserialize JSON string into object.</summary>
            ///<param name="jsonString" type="String">Valid JSON string</param>
            /// <param name="blobsArray" type="BlobsArrayCtor" optional="true"></param>
            ///<returns type="Object|Array|Null">JS object</returns>
            if (typeof (jsonString) == "string" && !!jsonString) {
                if (window.JSON) {
                    return JSON.parse(jsonString, (key, value) => {
                        return value ? fnJsonPostConvertObject(value, blobsArray) : value;
                    });
                }
                else {
                    return new Json.Infrastructure.CalystoJsonReader(jsonString, blobsArray).Parse();
                }
            }
            // will return undefined
        }
        //public method: Calysto.JSON.PostConvertObject is used in DateTimeConverter.cs
        function fnJsonPostConvertObject(obj, blobsArray) {
            /// <param name="blobsArray" type="BlobsArrayCtor" optional="true"></param>
            if (!obj)
                return obj;
            switch (obj.__calystotype) {
                case "Calysto_Date":
                    return Date.FromLocalISOTString(obj.Date);
                case "Calysto_Blob":
                    let blob = obj;
                    if (blob.DataUrl) {
                        return Calysto.Utility.Blob.DataUrlToBlob(blob.DataUrl, blob.FileName);
                    }
                    else if (blob.BlobIndex === 0 || blob.BlobIndex > 0) {
                        var data1 = (blobsArray || []).Where(o => o.blobIndex == blob.BlobIndex).pop(); // must return single item
                        if (!data1)
                            throw new Error("Blob not found at index: " + blob.BlobIndex);
                        return data1;
                    }
                    return blob;
                case "Calysto_Function":
                    return Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(obj.Function);
                default:
                    return obj;
            }
        }
        Json.fnJsonPostConvertObject = fnJsonPostConvertObject;
        // global function, used in DateTimeConverter
        Calysto.Core.ExportGlobal(fnJsonPostConvertObject, "fnJsonPostConvertObject");
        function SerializeAsync(objectToSerialize, recursionLimit, useBlobIndex, onComplete) {
            /// <summary>
            /// Serialize Blobs
            /// </summary>
            /// <param name="objectToSerialize" type="Object"></param>
            /// <param name="recursionLimit" type="Number"></param>
            /// <param name="useBlobIndex" type="Boolean">true to create blob indexes inside JSON, false to create dataURL-s for blobs inside JSON</param>
            /// <param name="onComplete" type="Function">function(json, blobsArray){....}</param>
            new Json.Infrastructure.CalystoJsonSerializer(true).SerializeAsync(objectToSerialize, recursionLimit, useBlobIndex, onComplete);
        }
        Json.SerializeAsync = SerializeAsync;
        function Serialize(objectToSerialize, recursionLimit = 100) {
            /// <summary>
            /// Serialize sync, Blobs are not serialized
            /// </summary>
            /// <param name="objectToSerialize" type="Object"></param>
            /// <param name="recursionLimit" type="Number"></param>
            return new Json.Infrastructure.CalystoJsonSerializer(false).Serialize(objectToSerialize, recursionLimit);
        }
        Json.Serialize = Serialize;
        ;
        function Deserialize(jsonString, blobsArray) {
            ///<summary>Deserialize JSON string into object.</summary>
            ///<param name="jsonString" type="String">Valid JSON string</param>
            /// <param name="blobsArray" type="BlobsArrayCtor" optional="true"></param>
            ///<returns type="Object|Array|Null">JS object</returns>
            return fnJsonDeserialize(jsonString, blobsArray);
        }
        Json.Deserialize = Deserialize;
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json) {
        let NodeTypeEnum;
        (function (NodeTypeEnum) {
            NodeTypeEnum[NodeTypeEnum["PrimitiveValue"] = 1] = "PrimitiveValue";
            NodeTypeEnum[NodeTypeEnum["KeyValue"] = 2] = "KeyValue";
            NodeTypeEnum[NodeTypeEnum["ArrayValue"] = 3] = "ArrayValue";
        })(NodeTypeEnum = Json.NodeTypeEnum || (Json.NodeTypeEnum = {}));
        const ROOT_PROPERTY = "@";
        const _reNum = new RegExp("^[\\d]+$");
        class JsonNode {
            constructor(value, parent, propertyOrIndex) {
                if (typeof (propertyOrIndex) == "number") {
                    this.Index = propertyOrIndex;
                    this.Property = propertyOrIndex + ""; // need for SelectChain traversing
                }
                else if (typeof (propertyOrIndex) == "string")
                    this.Property = propertyOrIndex;
                else
                    this.Property = ROOT_PROPERTY;
                if (parent)
                    this.Level = parent.Level + 1;
                else
                    this.Level = 0;
                this.Type = this.ResolveType(value);
                this.Value = value;
                if (parent)
                    this.Parent = parent;
            }
            ResolveType(item) {
                let vtype = typeof item;
                if (vtype == "undefined" || item === null || vtype == "function" || vtype == "string" || vtype == "number" || vtype == "boolean")
                    return NodeTypeEnum.PrimitiveValue;
                else if ((item && typeof item.pop == 'function') || "ToArray" in item)
                    return NodeTypeEnum.ArrayValue;
                else
                    return NodeTypeEnum.KeyValue;
            }
            Children(includeCurrent = false) {
                return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(function* (__this) {
                    if (includeCurrent)
                        yield __this;
                    if (__this.Type == NodeTypeEnum.ArrayValue) {
                        let index1 = -1;
                        while (++index1 < __this.Value.length)
                            yield (new JsonNode(__this.Value[index1], __this, index1));
                    }
                    else if (__this.Type == NodeTypeEnum.KeyValue) {
                        let index1 = -1;
                        let props1 = Calysto.Collections.GetOwnProperties(__this.Value);
                        while (++index1 < props1.length)
                            yield (new JsonNode(__this.Value[props1[index1]], __this, props1[index1]));
                    }
                }(this)));
            }
            Descendants(includeCurrent = false) {
                return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(function* (__this) {
                    if (includeCurrent)
                        yield __this;
                    for (let child1 of __this.Children().AsIterableIterator()) {
                        yield child1;
                        for (let child2 of child1.Descendants().AsIterableIterator())
                            yield child2;
                    }
                }(this)));
            }
            Ancestors(includeCurrent = false) {
                return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(function* (__this) {
                    if (includeCurrent)
                        yield __this;
                    let current1 = __this;
                    while (!!(current1 = current1.Parent))
                        yield current1;
                }(this)));
            }
            Root() {
                let curr1 = this;
                while (curr1.Parent && (curr1 = curr1.Parent)) { }
                return curr1;
            }
            /**
             * Select all nodes ih path.
             * Relative: prop2.prop3
             * Absolute: (at).prop1.prop2.prop3
             * @param path
             */
            SelectChain(path) {
                return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(function* (__this) {
                    let properties = path.split('.');
                    let node = __this;
                    let prop;
                    while (!!(prop = properties.shift())) {
                        if (!node) {
                            // previously returned null, there is no where to go
                            break;
                        }
                        else if (prop == ROOT_PROPERTY) {
                            node = node.Root();
                            yield node;
                        }
                        else if (prop === "") // .. means parent
                         {
                            node = node.Parent;
                            if (!!node)
                                yield node;
                            else
                                break;
                        }
                        else {
                            node = node.Children().Where(o => o.Property == prop).FirstOrDefault();
                            if (!!node)
                                yield node;
                            else
                                break;
                        }
                    }
                }(this)));
            }
        }
        Json.JsonNode = JsonNode;
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Json;
    (function (Json_1) {
        var BinaryFrame;
        (function (BinaryFrame) {
            //type TocItemType = ({
            //	// int?
            //	Size: number,
            //	// string
            //	FileName?: string,
            //	// int?
            //	BlobIndex?: number,
            //	// string
            //	MimeType: string,
            //	// bool
            //	IsJson: boolean
            //});
            //type BinaryTocType = ({
            //	Items: TocItemType[]
            //});
            //type BlobsArrayType = [Blob];//[Calysto.Utility.Blob.CreateBlob([[1]], "image/png")];
            var _headerSizeBytes = 4;
            function DeserializeWorker(arrayBuffer, onComplete) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="arrayBuffer" type="ArrayBuffer"></param>
                /// <param name="onComplete" type="Function"></param>
                // IE11 doesn't have Uint8Array.prototype.slice, so, use slice on ArrayBuffer
                var tocLength = Calysto.Utility.CalystoTools.ByteArrayToLong(new Uint8Array(arrayBuffer.slice(0, _headerSizeBytes))); // header size is always 4 bytes (_headerSizeBytes)
                var tocJson = Calysto.Utility.Encoding.UTF8.GetString(new Uint8Array(arrayBuffer.slice(_headerSizeBytes, _headerSizeBytes + tocLength)));
                var toc = Calysto.Json.Deserialize(tocJson);
                var mainJson = "";
                var blobsArray = [];
                var offsetStart = _headerSizeBytes + tocLength;
                for (var n1 = 0; n1 < toc.Items.length; n1++) {
                    var item = toc.Items[n1];
                    var data = new Uint8Array(arrayBuffer.slice(offsetStart, offsetStart + item.Size));
                    if (item.IsJson) {
                        mainJson = Calysto.Utility.Encoding.UTF8.GetString(data);
                    }
                    else {
                        var blob = Calysto.Utility.Blob.CreateBlob([data], item.MimeType);
                        blob.filename = item.FileName;
                        blob.blobIndex = item.BlobIndex;
                        blobsArray.push(blob);
                    }
                    offsetStart += item.Size;
                }
                onComplete(Calysto.Json.Deserialize(mainJson, blobsArray));
            }
            function DeserializeAsync(binaryData, onComplete) {
                /// <summary>
                /// Async deserialize from binary data or json string, depending if binaryData is string or blob.<br/>
                /// Return deserialized object.
                /// </summary>
                /// <param name="binaryData" type="Blob|String">binary data or json string</param>
                /// <param name="onComplete" type="Function">function(finalObj){...}</param>
                // block:
                // "header size": 1 byte, its value says the length of bytes in header that follows
                // "header" : contains "header size" bytes, its value represents "data lenght" that follows
                // "data": contains "data length" bytes
                // block
                // "header size": 1 byte, its value says the length of bytes in header that follows
                // "header" : contains "header size" bytes, its value represents "data lenght" that follows
                // "data": contains "data length" bytes
                // next block....
                if (binaryData && window.ArrayBuffer && binaryData.constructor == ArrayBuffer) {
                    DeserializeWorker(binaryData, onComplete); // binaryData is ArrayBuffer
                }
                else if (typeof (binaryData) == "string") {
                    onComplete(Calysto.Json.Deserialize(binaryData));
                }
                else if (binaryData && window.Blob && binaryData.constructor == Blob) {
                    var rr = new FileReader();
                    rr.onload = function (res) {
                        DeserializeWorker(res.currentTarget.result, onComplete); // result is ArrayBuffer
                    };
                    rr.readAsArrayBuffer(binaryData);
                }
                else {
                    throw new Error("Current binaryData type is not supported");
                }
            }
            BinaryFrame.DeserializeAsync = DeserializeAsync;
            ;
            function CreateBinaryFrame(json, blobsArray) {
                /// <summary>
                /// json has to be created using SerializeAsync first with blobIndex option
                /// </summary>
                /// <param name="json" type="String"></param>
                /// <param name="blobsArray" type="Array"></param>
                // first 4 bytes contains TOC size
                // then follows TOC, it is JSON encoded into binary stream
                // then follows data, blobs described in TOC
                var toc = {
                    Items: []
                };
                blobsArray = blobsArray || []; // if there is no blobs, set [] to prevent from throwing null exception
                for (var n1 = 0; n1 < blobsArray.length; n1++) {
                    var blob = blobsArray[n1];
                    toc.Items.push({
                        Size: blob.size,
                        FileName: blob.filename,
                        MimeType: blob.type,
                        BlobIndex: blob.blobIndex || n1,
                        IsJson: false
                    });
                }
                // main JSON will be added at the end as last blob
                var jsonData = Calysto.Utility.Encoding.UTF8.GetBytes(json);
                toc.Items.push({
                    Size: jsonData.length,
                    FileName: null,
                    MimeType: "application/json",
                    BlobIndex: null,
                    IsJson: true
                });
                var tocJson = Calysto.Json.Serialize(toc);
                var tocBytes = Calysto.Utility.Encoding.UTF8.GetBytes(tocJson);
                // TOC length writtent into 4 bytes
                var tocLengthBytes = Calysto.Utility.CalystoTools.LongToByteArray(tocBytes.length).slice(0, 4);
                // create complete single ArrayBuffer
                var finalArr = [];
                finalArr.push(new Uint8Array(tocLengthBytes)); // array, 4 bytes containing TOC size
                finalArr.push(new Uint8Array(tocBytes)); // array with TOC content
                // write blobs
                for (var n1 = 0; n1 < blobsArray.length; n1++) {
                    finalArr.push(blobsArray[n1]);
                }
                // write main JSON
                finalArr.push(new Uint8Array(jsonData));
                // single large blob
                // we have to create Blob since we already have blobs in blobsArray, it can not be converted into ArrayBuffer without FileReader
                var finalBlob = Calysto.Utility.Blob.CreateBlob(finalArr, "application/octet-stream");
                return finalBlob;
            }
            function SerializeAsync(obj, onComplete) {
                /// <summary>
                /// Async serialize obj and return BinaryFrame instance.
                /// </summary>
                /// <param name="obj" type="type"></param>
                /// <param name="onComplete" type="function">function(BinaryFrame){...}</param>
                Calysto.Json.SerializeAsync(obj, 100, true, (json, blobsArray) => {
                    onComplete(new BinaryFrameItem(json || "", blobsArray || []));
                });
            }
            BinaryFrame.SerializeAsync = SerializeAsync;
            class BinaryFrameItem {
                constructor(Json, Blobs) {
                    this.Json = Json;
                    this.Blobs = Blobs;
                }
                /**
                 * Pack json and blobs into single binary data as Blob
                 */
                ToBinaryData() {
                    /// <summary>
                    /// Pack json and blobs into single binary data as Blob
                    /// </summary>
                    /// <returns type=""></returns>
                    return CreateBinaryFrame(this.Json, this.Blobs);
                }
            }
            BinaryFrame.BinaryFrameItem = BinaryFrameItem;
        })(BinaryFrame = Json_1.BinaryFrame || (Json_1.BinaryFrame = {}));
    })(Json = Calysto.Json || (Calysto.Json = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    let CloseMode;
    (function (CloseMode) {
        CloseMode["destroy"] = "destroy";
        CloseMode["hide"] = "hide";
    })(CloseMode = Calysto.CloseMode || (Calysto.CloseMode = {}));
    let DialogButton;
    (function (DialogButton) {
        DialogButton["XClose"] = "XClose";
        DialogButton["Yes"] = "Yes";
        DialogButton["No"] = "No";
        DialogButton["Cancel"] = "Cancel";
        DialogButton["Close"] = "Close";
    })(DialogButton = Calysto.DialogButton || (Calysto.DialogButton = {}));
    let DesingModeEnum;
    (function (DesingModeEnum) {
        DesingModeEnum[DesingModeEnum["Windows"] = 0] = "Windows";
        DesingModeEnum[DesingModeEnum["Modern"] = 1] = "Modern";
    })(DesingModeEnum || (DesingModeEnum = {}));
    // transform: translateX(-50%) translateY(-20%)
    // calystoDialogBox width:auto to override css from  web template
    // td: padding:0;border:none override css from web template
    // it has to be modal always because calystoDialogBoxContainer is stretched over the whole page anyway
    let _html = (`<div class="themeAero calystoDialogControl calystoDialogModal">
	<div class="calystoDialogMask"></div>
	<div class="calystoDialogBoxContainer">
		<div class="calystoDialogBox">
				
			<div class="calystoWindow">
				<div class="calystoWindowTitle">
					
					<div class="calystoWindowTitleText element1">Alert</div>

					<label class="calystoWindowXMark fa fa-close" style="display: none;">
						<button class="calystoXCloseButton" calysto_button_name="${DialogButton.XClose}" style="position: absolute; width: 1px; height: 1px; opacity: 0;"></button>
					</label>
				</div>
				<div class="calystoTopContainer element2" style="display:none">
					<div class="calystoWindowTd1">
						<div class="calystoWindowIcon fa fa-info-circle" style="display:none"></div>
					</div>
					<div class="calystoWindowTitleText">Alert</div>
				</div>
				<div class="calystoWindowContent" style="min-width: 250px; min-height: 50px;">
					<table class="calystoWindowTable1 calystoWindowInnerContent" cellpadding="0" cellspacing="0">
						<tbody>
							<tr>
								<td class="calystoWindowTd1 element3">
									<div class="calystoWindowIcon fa fa-info-circle" style="display:none"></div>
								</td>
								<td class="calystoWindowTd2">
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="calystoWindowButtons calystoThemeContainer" style="display:none"></div>
			</div>
		
		</div>
	</div>
</div>`);
    let OverflowHelper;
    (function (OverflowHelper) {
        let _calystoOverflowHidden = "calystoOverflowHidden";
        let _hasOverflow = false;
        let _paddings;
        function GetScrollElement() {
            for (let el of [document.documentElement, document.body]) {
                if (el.scrollHeight > el.clientHeight)
                    return el;
                if (el.scrollWidth > el.clientWidth)
                    return el;
            }
            return undefined;
        }
        function CreateOverflow() {
            if (_hasOverflow)
                return;
            else
                _hasOverflow = true;
            $$calysto(document.body).RemoveClass(_calystoOverflowHidden);
            _paddings = null;
            let el = GetScrollElement();
            if (!el)
                return;
            _paddings = {};
            let w1 = el.clientWidth;
            let h1 = el.clientHeight;
            // overflow class must be added to body, not to html element, for all browsers
            $$calysto(document.body).AddClass(_calystoOverflowHidden);
            let w2 = el.clientWidth;
            let h2 = el.clientHeight;
            if (w2 > w1) {
                // save original padding
                _paddings.paddingRight = document.body.style.paddingRight || "";
                document.body.style.paddingRight = (w2 - w1) + "px";
            }
            if (h2 > h1) {
                // save original padding
                _paddings.paddingBottom = document.body.style.paddingBottom || "";
                document.body.style.paddingBottom = (h2 - h1) + "px";
            }
        }
        OverflowHelper.CreateOverflow = CreateOverflow;
        function RemoveOverflow() {
            _hasOverflow = false;
            if (!_paddings)
                return;
            $$calysto(document.body).RemoveClass(_calystoOverflowHidden);
            document.body.style.paddingRight = _paddings.paddingRight || "";
            document.body.style.paddingBottom = _paddings.paddingBottom || "";
        }
        OverflowHelper.RemoveOverflow = RemoveOverflow;
    })(OverflowHelper || (OverflowHelper = {}));
    let DialogIcon;
    (function (DialogIcon) {
        DialogIcon["info"] = "info";
        DialogIcon["error"] = "error";
        DialogIcon["warning"] = "warning";
        DialogIcon["question"] = "question";
        DialogIcon["success"] = "success";
        DialogIcon["none"] = "none";
    })(DialogIcon = Calysto.DialogIcon || (Calysto.DialogIcon = {}));
    ;
    let DialogMode;
    (function (DialogMode) {
        /** default */
        DialogMode[DialogMode["Alert"] = 0] = "Alert";
        /** similar to bootstrap modal: hides page scrollbar and create scrollbar for dialog at the window right-most*/
        DialogMode[DialogMode["Panel"] = 1] = "Panel";
    })(DialogMode = Calysto.DialogMode || (Calysto.DialogMode = {}));
    /**
     * Get window title based on icon.
     * @param iconName
     */
    function GetTitle(iconName) {
        switch (iconName) {
            case "error": return Calysto.Resources.CalystoLang.Error;
            case "warning": return Calysto.Resources.CalystoLang.Warning;
            case "info": return Calysto.Resources.CalystoLang.Information;
            case "question": return Calysto.Resources.CalystoLang.Question;
            case "success": return Calysto.Resources.CalystoLang.Success;
            default: return Calysto.Resources.CalystoLang.Message;
        }
    }
    /**
     * Font Awesome icon.
     * @param iconName
     */
    function GetFAIconClass(iconName) {
        switch (iconName) {
            case "success": return "fa-check-circle";
            case "error": return "fa-times-circle";
            case "warning": return "fa-exclamation-triangle";
            case "info": return "fa-info-circle";
            case "question": return "fa-question-circle";
            default: return "";
        }
    }
    Calysto.GetFAIconClass = GetFAIconClass;
    /**
     * Get window icon in color.
     * @param iconName
     */
    function GetWindowIconClass(iconName) {
        switch (iconName) {
            case "success": return "calystoWindowIconGreen";
            case "error": return "calystoWindowIconRed";
            case "warning": return "calystoWindowIconOrange";
            case "info": return "calystoWindowIconBlue";
            case "question": return "calystoWindowIconOrange";
            default: return "";
        }
    }
    /**
     * global z-index, ever new dialog instace will increase as _zIndex++
     */
    let _zIndex = 1000000; // global z-index, every new dialog increases _zIndex++
    /**
     * global dialogls stack
     */
    let _dialogsStack = [];
    /**
     * global test if OnEsc event is assigned
     */
    let _hasEscEvent = false;
    class Dialog {
        /**
         * creates new instance and append it to document body
         */
        constructor() {
            this._closeMode = "destroy";
            this._viewMode = DialogMode.Alert;
            this._designMode = DesingModeEnum.Windows;
            /**
            * Assign single callback, overwrite previous callback.
             * this inside fn is current Calysto.Dialog instance
             * @param {(buttonEl} fn
             * @param {string} buttonName
             * @param {function} ev
             * @returns
             */
            this.OnButtonClick = new Calysto.MulticastDelegate().AsFunc(this);
            /**
             * Assign single callback, overwrite previous callback.
             * Invoked when dialog is shown.
             * @param fn
             */
            this.OnShown = new Calysto.MulticastDelegate().AsFunc(this);
            /**
             * Assign single callback, overwrite previous callback.
             * Invoked when dialog close is started.
            *	If action returns false, will abort closing action
             * @param fn
             */
            this.OnClosing = new Calysto.MulticastDelegate().AsFunc(this);
            /**
             * Assign single callback, overwrite previous callback.
             * Invoked when dialog is removed from DOM.
             * @param fn
             */
            this.OnClosed = new Calysto.MulticastDelegate().AsFunc(this);
            this._buttons = [];
            this.Initialize();
        }
        Initialize() {
            var el = document.createElement("div");
            el.innerHTML = _html;
            this._dialogControlEl = el.childNodes[0];
            // container with Calysto.Dialog instance
            this._dialogControlEl["__calystoDialog"] = this;
            var $$dialogEl = $$calysto(this._dialogControlEl);
            this._dialogControlEl.style.zIndex = (_zIndex++) + "";
            this._maskEl = $$dialogEl.Query("//.calystoDialogMask").First();
            this._dialogBoxContainerEl = $$dialogEl.Query("//.calystoDialogBoxContainer").First();
            this._dialogBoxEl = $$dialogEl.Query("//.calystoDialogBox").First(); // must have display:inline-block for scroll to work
            this._windowEl = $$dialogEl.Query("//.calystoWindow").First();
            let $windowEl = $$calysto(this._windowEl);
            this._xButtonEl = $windowEl.Query("//.calystoWindowXMark").First();
            this._titleEl = $windowEl.Query("//.calystoWindowTitle").First();
            this._contentEl = $windowEl.Query("//.calystoWindowContent").First();
            this._innerContentEl = $windowEl.Query("//.calystoWindowInnerContent").First();
            this._tdContentEl = $windowEl.Query("//.calystoWindowTd2").First();
            this._buttonsEl = $windowEl.Query("//.calystoWindowButtons").First();
            this._topContainer = $windowEl.Query("//.calystoTopContainer").First();
        }
        GetDialogEl() {
            return this._dialogControlEl;
        }
        GetContentEl() {
            return this._contentEl;
        }
        /**
         * Apply dialog width 100% and max-width:prefferedWidth in px
         * @param prefferedWidth
         */
        PrefferedWidth(prefferedWidth) {
            $$calysto(this._dialogBoxEl).ApplyStyle(`width:100%;max-width:${prefferedWidth}px;`);
            return this;
        }
        Set(cb) {
            cb(this);
            return this;
        }
        DesignMode(mode) {
            this._designMode = mode;
            $$calysto(this._windowEl).AddClass("calystoWindow2", mode == DesingModeEnum.Modern);
            return this;
        }
        RenderTitle(title) {
            // u Modern designu prikazujemo samo custom title text, ne i tekst koji se dobije iz ikone
            // u Windows designu prikazujemo ili custom title tekst, a ako nije setiran, onda tekst dekodiran iz ikone
            let showTitle = false;
            if (this._viewMode == DialogMode.Panel)
                showTitle = false;
            else if (this._designMode == DesingModeEnum.Windows)
                showTitle = !String.IsNullOrWhiteSpace(title);
            else if (this._designMode == DesingModeEnum.Modern)
                showTitle = !String.IsNullOrWhiteSpace(this._titleText);
            // don't allow empty title, use text depending on icon text
            $$calysto(this._dialogControlEl).Query("//.calystoWindowTitleText")
                .SetProperty("innerHTML", title || "")
                .SetVisible(showTitle);
            return this;
        }
        Title(title) {
            this._titleText = title; // title won't change if icon is changed using this.Icon(name)
            return this.RenderTitle(title);
        }
        Icon(iconName) {
            this._iconName = iconName;
            if (!this._titleText)
                this.RenderTitle(GetTitle(iconName)); // use text based on icon
            let showIcon = !!this._iconName && this._iconName != "none";
            $$calysto(this._windowEl).AddClass("calystoShowIcon", showIcon);
            let cls1 = "calystoWindowIcon fa " + GetFAIconClass(this._iconName) + " " + GetWindowIconClass(this._iconName);
            $$calysto(this._windowEl).Query("//.calystoWindowTd1/div").SetVisible(showIcon).SetClass(cls1);
            return this;
        }
        CloseMode(mode) {
            this._closeMode = mode;
            return this;
        }
        fnButtonClickHandler(sender, ev) {
            let name = (typeof sender == "string" ? sender : sender.getAttribute("calysto_button_name"));
            if (name == DialogButton.XClose)
                this.Close();
            else
                this.OnButtonClick.Invoke(f => f(this, name, ev));
        }
        /**
         * Hide all buttons, including X button
         */
        HideButtons() {
            $$calysto([this._buttonsEl, this._xButtonEl]).SetVisible(false);
            return this;
        }
        ButtonXClose() {
            return this.Button(DialogButton.XClose);
        }
        /**
         * XClose, OK, CANCEL, ...
         * @param name XClose, OK, CANCEL, ...
         * @param isDefault if true, focus button
         */
        Button(name, isDefault) {
            let item = {
                name: name,
                isDefault: !!isDefault,
                isRendered: false
            };
            this._buttons.push(item);
            item.isRendered = true;
            let btnEl;
            if (item.name == DialogButton.XClose) {
                btnEl = $$calysto(this._dialogControlEl).Query("//.calystoWindowXMark").SetVisible(true).Query("/button").First();
            }
            else {
                $$calysto(this._buttonsEl).SetVisible(true).AddChildren(btnEl = Calysto.DomQuery.CreateElement("button")
                    .AddClass("calystoBtn")
                    .SetAttribute("calysto_button_name", item.name)
                    .SetInnerHtml(item.name)
                    .First());
            }
            if (item.isDefault)
                this._focusButtonEl = btnEl;
            $$calysto(btnEl).OnClick((s, e) => this.fnButtonClickHandler(s, e)); // use lambda to keep scope
            return this;
        }
        /**
         * Append content
         * @param content
         */
        AppendContent(content) {
            if ((content && content["nodeType"] > 0) // DOM element
                // html closing tag becuase it may contain generic <IList> which is not html indicator
                // selfclosing tag: <meta.../> 
                // ending tag: </div>
                || (typeof content == "string" && content.match(new RegExp("(<[^>/\\s]+/>)|(</[^>/\\s]+>)")))) {
                $$calysto(this._tdContentEl).AddChildren(content);
            }
            else {
                // pure text, encapsulate into pre element, respecting new lines in text	
                // text has to be html encoded because <null> is understood as html tag an not shown unless it is encoded as &lt;null&gt;
                $$calysto(this._tdContentEl).AddChildren(Calysto.DomQuery.CreateElement("pre")
                    .AddClass("calystoWindowPre")
                    .SetInnerHtml(Calysto.Utility.Html.HtmlEncodeSimple(content)));
            }
            return this;
        }
        /**
         * Set content. Remove previous content.
         * @param content
         */
        Content(content) {
            this._tdContentEl.innerHTML = "";
            return this.AppendContent(content);
        }
        ;
        /**
         * Set mask opacity (0.0 - 1.0), 1.0: full visibility
         * @param value 0.0 - 1.0 (full visibility = 1.0)
         */
        MaskOpacity(value) {
            $$calysto(this._maskEl).SetOpacity(value);
            return this;
        }
        Background(value) {
            $$calysto(this._windowEl).ApplyStyle("background", value);
            return this;
        }
        Close() {
            this.OnClosing.Invoke(f => f(this));
            if (this._intervalId) {
                clearInterval(this._intervalId);
                this._intervalId = null;
            }
            _dialogsStack.Remove(this);
            ////this._dialogBoxContainerEl.style.top = 0 + "px"; // to animate up while fading out
            $$calysto(this._dialogControlEl).RemoveClass("showDialog").Sleep(400, q => {
                q.SetVisible(false);
                if (this._closeMode == "destroy")
                    q.RemoveFromDom();
                this.OnClosed.Invoke(f => f(this));
                if (!_dialogsStack.Any() && this._viewMode == DialogMode.Panel) {
                    OverflowHelper.RemoveOverflow();
                }
            });
        }
        AutoClose(delayMs) {
            if (delayMs > 0)
                setTimeout(() => this.Close(), delayMs);
            return this;
        }
        fnFixPosition() {
            if (this._viewMode == DialogMode.Panel) {
            }
            else if (this._viewMode == DialogMode.Alert) {
                var margin = 10;
                // max-height has to be set on calystoWindowContent for scroll:overflow to work, while width works fine anyway
                var viewport = Calysto.Utility.Dom.GetViewportDiv();
                var maxContentWidth = viewport.clientWidth - margin * 2;
                var minContentWidth = Math.min(maxContentWidth, 400);
                var maxContentHeight = viewport.clientHeight - margin * 2 - this._titleEl.offsetHeight - this._buttonsEl.offsetHeight - this._topContainer.offsetHeight;
                // element height with overflow:auto has to be limited for scroll to show
                this._contentEl.style.overflowX = this._innerContentEl.offsetWidth > maxContentWidth ? "scroll" : "";
                this._contentEl.style.overflowY = this._innerContentEl.offsetHeight > maxContentHeight ? "scroll" : "";
                this._contentEl.style.maxWidth = maxContentWidth + "px";
                this._contentEl.style.maxHeight = maxContentHeight + "px";
                this._contentEl.style.minWidth = minContentWidth + "px";
                this._windowEl.style.maxWidth = maxContentWidth + "px";
                // table can be centered with margin:auto, it works for table only
                // don't use css transform because letters are blured
                // horizontaly is centered with left:50% and margin-left:-50% in child element
                // verticaly can't be centered with css, without transform
                var hspace = Math.round((viewport.clientHeight - 2 * margin - this._dialogBoxEl.offsetHeight) * 0.2);
                if (!(hspace > margin))
                    hspace = margin;
                this._dialogBoxEl.style.top = hspace + "px";
            }
        }
        fnFirstTimeInit() {
            if (this._initDone)
                return;
            this._initDone = true;
            (document.body || document.documentElement).appendChild(this._dialogControlEl);
            if (this._viewMode == DialogMode.Panel) {
                $$calysto(this._titleEl).SetVisible(false);
                this._topContainer.style.display = "none";
                this._dialogBoxEl.style.padding = "20px 5px";
                this._dialogBoxContainerEl.style.overflowY = "scroll"; // always show, prevent from moving popup left-right when scrollbar is shown/hidden
                this._dialogBoxContainerEl.style.overflowX = "auto";
                this._dialogBoxContainerEl.style.bottom = "0";
                setTimeout(() => {
                    this._dialogBoxContainerEl.scrollTop = 0;
                    this._dialogBoxContainerEl.scrollLeft = 0;
                }, 1);
            }
            else if (this._viewMode == DialogMode.Alert) {
                var handler = new Calysto.Utility.Dom.ScrollHandler();
                $$calysto([this._dialogBoxContainerEl]).On(["scroll", "mousewheel", "wheel", "DOMMouseScroll"], (sender, ev) => {
                    handler.HandleScroll(this._contentEl, ev);
                    return false; // disable scroll propagation to page because we want to scroll _innerContentEl
                });
            }
        }
        fnShowWorker() {
            this.fnFirstTimeInit();
            if (!this._intervalId && this._viewMode == DialogMode.Alert) {
                // periodic position fix
                this._intervalId = setInterval(() => this.fnFixPosition(), 1000);
            }
            // element has to be visible in order to be able to measure dimensions and transform
            $$calysto(this._dialogControlEl).SetVisible(true);
            // za IE treba pokrenuti visibility iz novog threada da bi radila animacija sa transition ispravno
            setTimeout(() => $$calysto(this._dialogControlEl).AddClass("showDialog"), 5);
            // dialog height is changing while translating into view, translation duration is 300 ms, so let's fix position regularly up to 400 ms
            let dtStart1 = Date.now();
            let interval1 = setInterval(() => {
                this.fnFixPosition();
                if (Date.now() - dtStart1 > 400)
                    clearInterval(interval1);
            }, 10);
            if (this._focusButtonEl)
                this._focusButtonEl.focus();
            this.OnShown.Invoke(f => f(this));
        }
        CloseOnMaskClick() {
            if (this._closeOnMaskAssigned)
                return this;
            this._closeOnMaskAssigned = true;
            // let's close panel dialog on click on mask
            // we have to use OnMouseDown, not OnClick because OnClick is triggered when mouse button is released on mask, but pressed on panel
            $$calysto([this._maskEl, this._dialogBoxContainerEl, this._windowEl]).OnMouseDown((sender, ev) => {
                if (Calysto.Event.IsLeftMouseButton(ev) && Calysto.Event.GetTarget(ev) == sender) {
                    this.fnButtonClickHandler(DialogButton.XClose, ev);
                    return false; // stop propagation
                }
                return undefined;
            });
            return this;
        }
        CloseOnEscKey() {
            this._closeOnEscKey = true;
            return this;
        }
        ViewMode(mode) {
            this._viewMode = mode;
            return this;
        }
        /**
         * Show dialog in Calysto manner
         */
        Show() {
            if (!_hasEscEvent) {
                _hasEscEvent = true;
                Calysto.Page.OnEscKey(() => {
                    // esc key should not close information dialog without buttons:
                    let dd = _dialogsStack[_dialogsStack.length - 1];
                    if (dd && dd._closeOnEscKey) {
                        dd.fnButtonClickHandler(DialogButton.XClose, {});
                    }
                });
            }
            this.fnShowWorker();
            _dialogsStack.push(this);
            if (this._viewMode == DialogMode.Panel) {
                OverflowHelper.CreateOverflow();
            }
            return this;
        }
    }
    Calysto.Dialog = Dialog;
})(Calysto || (Calysto = {}));
//#region static methods
//*******************************************************************
// static methods
//*******************************************************************
(function (Calysto) {
    var Dialog;
    (function (Dialog) {
        /**
         * Find Calysto.Dialog instance containing childElement
         * @param childEl
         */
        function FindDialog(childEl) {
            return $$calysto(childEl).AncestorNodes().Select(o => o["__calystoDialog"]).Where(o => !!o).FirstOrDefault();
        }
        Dialog.FindDialog = FindDialog;
        function ShowVersionExpired() {
            if (Calysto.Page.IsPageReloading || Calysto.Page.IsVersionExpiredVisible)
                return;
            Calysto.Page.IsVersionExpiredVisible = true;
            return new Calysto.Dialog()
                .Content(Calysto.Resources.CalystoLang.JavascriptEngineIsOutdatedInformation)
                .Icon("warning")
                .Button(Calysto.Resources.CalystoLang.Reload)
                .Button(Calysto.Resources.CalystoLang.Cancel)
                .ButtonXClose()
                .OnButtonClick((dialog, name) => {
                Calysto.Page.IsVersionExpiredVisible = false;
                dialog.Close();
                if (name == Calysto.Resources.CalystoLang.Reload) {
                    document.documentElement.className += ' calystoAjaxLoading'; // show wait cursor
                    new Calysto.Dialog().Content(Calysto.Resources.CalystoLang.PageIsReloadingPleaseWait).Icon("info").Show();
                    Calysto.Page.IsPageReloading = true;
                    setTimeout(() => window.location.reload(true), 1);
                }
            }).Show();
        }
        Dialog.ShowVersionExpired = ShowVersionExpired;
        function CreateInformation(msg, title) {
            return new Calysto.Dialog()
                .Title(title) // title has to be set before icon
                .Icon("info") // if title is empty, will set title based on icon
                .Content(msg)
                .ButtonXClose()
                .CloseOnEscKey();
        }
        Dialog.CreateInformation = CreateInformation;
        function CreateDialogImpl(msg, iconName, title, addXClose) {
            /// <summary>
            /// Show alert() message.
            /// </summary>
            /// <param name="msg"></param>
            /// <param name="iconName" type="string"> info, warning, error, question, success </param>
            return new Calysto.Dialog()
                .Title(title)
                .Icon(iconName || "info")
                .Content(msg)
                .ButtonXClose()
                .Button(Calysto.Resources.CalystoLang.Close)
                .CloseOnEscKey()
                .OnButtonClick((dialog, buttonName, ev) => {
                dialog.Close();
            });
        }
        ;
        /**
         * Buttons have to be added. OnButtonClick has to be added. Show is already invoked.
         * @param msg
         * @param title
         */
        function CreateConfirm(msg, title) {
            return new Calysto.Dialog()
                .Title(title)
                .Icon("question")
                .Content(msg)
                .ButtonXClose()
                .CloseOnEscKey()
                .CloseOnMaskClick();
            ////.Button("Close") // no buttons, they should be added from user code, e.g.: YES, NO
            ////.OnClick((dialog, buttonName, ev)=>
            ////{
            ////	dialog.Close();
            ////})
            ////.Show();
        }
        Dialog.CreateConfirm = CreateConfirm;
        ;
        function CreateAlert(msg, iconName, title) {
            /// <summary>
            /// Show alert() message.
            /// </summary>
            /// <param name="msg"></param>
            /// <param name="iconName" type="string"> info, warning, error, question, success </param>
            return CreateDialogImpl(msg, iconName, title);
        }
        Dialog.CreateAlert = CreateAlert;
        function CreateError(msg, title) {
            return CreateDialogImpl(msg, "error", title);
        }
        Dialog.CreateError = CreateError;
        ;
        function CreateWarning(msg, title) {
            return CreateDialogImpl(msg, "warning", title);
        }
        Dialog.CreateWarning = CreateWarning;
        ;
        function CreateSuccess(msg, title) {
            return CreateDialogImpl(msg, "success", title);
        }
        Dialog.CreateSuccess = CreateSuccess;
        ;
        function CreatePanel() {
            return new Calysto.Dialog()
                .CloseOnEscKey()
                .CloseOnMaskClick()
                .ViewMode(Calysto.DialogMode.Panel);
        }
        Dialog.CreatePanel = CreatePanel;
        ;
    })(Dialog = Calysto.Dialog || (Calysto.Dialog = {}));
})(Calysto || (Calysto = {}));
//#endregion
//#region usage example
/*******************************************************************
function ShowDialog()
{
    new Calysto.Dialog()
    .Title("Warning")
    .Content("Carefull what are you doing!")
    .Button("Yes")
    .Button("No")
    .ButtonXClose()
    .Modal(true)
    .Icon("warning")
    .OnClick(function (dialog, buttonName)
    {
        if (buttonName == "XClose") dialog.Close();
        console.log("clicked: " + buttonName);
    })
    .Show();
}
*******************************************************************/
//#endregion
var Calysto;
(function (Calysto) {
    let NotifyHPosition;
    (function (NotifyHPosition) {
        NotifyHPosition["center"] = "center";
        NotifyHPosition["right"] = "right";
        NotifyHPosition["left"] = "left";
    })(NotifyHPosition = Calysto.NotifyHPosition || (Calysto.NotifyHPosition = {}));
    let NotifyVPosition;
    (function (NotifyVPosition) {
        NotifyVPosition["bottom"] = "bottom";
        NotifyVPosition["top"] = "top";
    })(NotifyVPosition = Calysto.NotifyVPosition || (Calysto.NotifyVPosition = {}));
    let _zIndex = 2000000;
    class Notification {
        constructor(text) {
            this.VPosition = "top";
            this.HPosition = "center";
            this.Icon = "info";
            this.PrefferedWidth = 500;
            this.AutoCloseMs = 3000;
            this._template = `<div class= 'calystoNotify2 hiddeNotifBox' >
	<div class='calystoNotifyInner'>
		<div class='calystoNotifyContent'>
			<table cellpadding='0' cellspacing='0'>
				<tr>
					<td class='tdIcon'><span class='calystoNotifyIcon'></span></td>
					<td class='calystoTextContent' style='width:100%'></td>
					<td class='tdBtnClose'><span class='calystoCloseBtn fa fa-times'></span></td>
				</tr>
			</table>
		</div>
	</div>
</div>`;
            this.Text = text;
        }
        Set(fn) {
            fn(this);
            return this;
        }
        EnsureContainer() {
            let selector = ".calystoNotifyContainer." + this.VPosition + "." + this.HPosition;
            this._containerEl = $$calysto(selector).FirstOrDefault();
            if (this._containerEl)
                return;
            // create container
            let class1 = selector.ReplaceAll(".", " ").Trim();
            this._containerEl = Calysto.DomQuery.CreateElement("div").AddClass(class1).AddAsChildrenTo(document.body).FirstOrDefault();
            this._containerEl.style.zIndex = _zIndex + "";
        }
        EnsureNotif() {
            if (!this._notifBoxEl) {
                let $$ = Calysto.DomQuery.FromHtml(this._template);
                this._notifBoxEl = $$.FirstOrDefault();
                this._notifInnerEl = $$.Query("//.calystoNotifyInner").FirstOrDefault();
                this._notifContentEl = $$.Query("//.calystoNotifyContent").AddClass(this.Icon).FirstOrDefault();
                this._notifTextEl = $$.Query("//.calystoTextContent").FirstOrDefault();
                let iconCls = "fa " + Calysto.GetFAIconClass(this.Icon);
                this._notifIconEl = $$.Query("//.calystoNotifyIcon").AddClass(iconCls).FirstOrDefault();
                this._notifCloseBtnEl = $$.Query("//.calystoCloseBtn").FirstOrDefault();
                this._notifCloseBtnEl.onclick = () => this.Hide();
            }
        }
        Show() {
            setTimeout(() => {
                this.EnsureContainer();
                this.EnsureNotif();
                this._containerEl.style.maxWidth = this.PrefferedWidth + "px";
                this._notifTextEl.innerHTML = this.Text;
                if (this.VPosition == "top")
                    $$calysto(this._containerEl).InsertChildren(this._notifBoxEl);
                else if (this.VPosition == "bottom")
                    $$calysto(this._containerEl).AddChildren(this._notifBoxEl);
                this._notifBoxEl.style.height = "1px"; // da moze mjeriti dimenzije
                $$calysto(this._notifBoxEl).RemoveClass("hiddeNotifBox");
                this._notifBoxEl.style.height = this._notifInnerEl.offsetHeight + "px";
                if (this.AutoCloseMs > 0)
                    setTimeout(() => this.Hide(), this.AutoCloseMs);
            }, 1);
            return this;
        }
        Hide() {
            setTimeout(() => {
                $$calysto(this._notifBoxEl).AddClass("hiddeNotifBox").Sleep(1500, sender => sender.RemoveFromDom());
            }, 1);
        }
        //*******************************************************************
        // static methods
        //*******************************************************************
        static Create(text, icon = "info", autoCloseMs = 3000, vPosition = "top", hPosition = "center") {
            return new Calysto.Notification(text)
                .Set(n => n.Icon = icon)
                .Set(n => n.AutoCloseMs = autoCloseMs)
                .Set(n => n.VPosition = vPosition)
                .Set(n => n.HPosition = hPosition);
        }
    }
    Calysto.Notification = Notification;
})(Calysto || (Calysto = {}));
//let _cnt = 0;
//export function Notify(vPosition: NotifyVPosition, hPosition: NotifyHPosition)
//{
//	let nn = new Notification("ovo je sadrzajovo  " + (_cnt++));
//	nn.VPosition = vPosition;
//	nn.HPosition = hPosition;
//	nn.Icon = <Calysto.DialogIcon>["error", "success", "warning", "info"][Math.round(Math.random() * 3)];
//	nn.Show().AutoHide(4000);
//}
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        //
        // Summary:
        //     Contains the values of status codes defined for HTTP.
        let HttpStatusCode;
        (function (HttpStatusCode) {
            //
            // Summary:
            //     Equivalent to HTTP status 100. System.Net.HttpStatusCode.Continue indicates that
            //     the client can continue with its request.
            HttpStatusCode[HttpStatusCode["Continue"] = 100] = "Continue";
            //
            // Summary:
            //     Equivalent to HTTP status 101. System.Net.HttpStatusCode.SwitchingProtocols indicates
            //     that the protocol version or protocol is being changed.
            HttpStatusCode[HttpStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
            //
            // Summary:
            //     Equivalent to HTTP status 102. System.Net.HttpStatusCode.Processing indicates
            //     that the server has accepted the complete request but hasn't completed it yet.
            HttpStatusCode[HttpStatusCode["Processing"] = 102] = "Processing";
            //
            // Summary:
            //     Equivalent to HTTP status 103. System.Net.HttpStatusCode.EarlyHints indicates
            //     to the client that the server is likely to send a final response with the header
            //     fields included in the informational response.
            HttpStatusCode[HttpStatusCode["EarlyHints"] = 103] = "EarlyHints";
            //
            // Summary:
            //     Equivalent to HTTP status 200. System.Net.HttpStatusCode.OK indicates that the
            //     request succeeded and that the requested information is in the response. This
            //     is the most common status code to receive.
            HttpStatusCode[HttpStatusCode["OK"] = 200] = "OK";
            //
            // Summary:
            //     Equivalent to HTTP status 201. System.Net.HttpStatusCode.Created indicates that
            //     the request resulted in a new resource created before the response was sent.
            HttpStatusCode[HttpStatusCode["Created"] = 201] = "Created";
            //
            // Summary:
            //     Equivalent to HTTP status 202. System.Net.HttpStatusCode.Accepted indicates that
            //     the request has been accepted for further processing.
            HttpStatusCode[HttpStatusCode["Accepted"] = 202] = "Accepted";
            //
            // Summary:
            //     Equivalent to HTTP status 203. System.Net.HttpStatusCode.NonAuthoritativeInformation
            //     indicates that the returned metainformation is from a cached copy instead of
            //     the origin server and therefore may be incorrect.
            HttpStatusCode[HttpStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
            //
            // Summary:
            //     Equivalent to HTTP status 204. System.Net.HttpStatusCode.NoContent indicates
            //     that the request has been successfully processed and that the response is intentionally
            //     blank.
            HttpStatusCode[HttpStatusCode["NoContent"] = 204] = "NoContent";
            //
            // Summary:
            //     Equivalent to HTTP status 205. System.Net.HttpStatusCode.ResetContent indicates
            //     that the client should reset (not reload) the current resource.
            HttpStatusCode[HttpStatusCode["ResetContent"] = 205] = "ResetContent";
            //
            // Summary:
            //     Equivalent to HTTP status 206. System.Net.HttpStatusCode.PartialContent indicates
            //     that the response is a partial response as requested by a GET request that includes
            //     a byte range.
            HttpStatusCode[HttpStatusCode["PartialContent"] = 206] = "PartialContent";
            //
            // Summary:
            //     Equivalent to HTTP status 207. System.Net.HttpStatusCode.MultiStatus indicates
            //     multiple status codes for a single response during a Web Distributed Authoring
            //     and Versioning (WebDAV) operation. The response body contains XML that describes
            //     the status codes.
            HttpStatusCode[HttpStatusCode["MultiStatus"] = 207] = "MultiStatus";
            //
            // Summary:
            //     Equivalent to HTTP status 208. System.Net.HttpStatusCode.AlreadyReported indicates
            //     that the members of a WebDAV binding have already been enumerated in a preceding
            //     part of the multistatus response, and are not being included again.
            HttpStatusCode[HttpStatusCode["AlreadyReported"] = 208] = "AlreadyReported";
            //
            // Summary:
            //     Equivalent to HTTP status 226. System.Net.HttpStatusCode.IMUsed indicates that
            //     the server has fulfilled a request for the resource, and the response is a representation
            //     of the result of one or more instance-manipulations applied to the current instance.
            HttpStatusCode[HttpStatusCode["IMUsed"] = 226] = "IMUsed";
            //
            // Summary:
            //     Equivalent to HTTP status 300. System.Net.HttpStatusCode.Ambiguous indicates
            //     that the requested information has multiple representations. The default action
            //     is to treat this status as a redirect and follow the contents of the Location
            //     header associated with this response. Ambiguous is a synonym for MultipleChoices.
            HttpStatusCode[HttpStatusCode["Ambiguous"] = 300] = "Ambiguous";
            //
            // Summary:
            //     Equivalent to HTTP status 300. System.Net.HttpStatusCode.MultipleChoices indicates
            //     that the requested information has multiple representations. The default action
            //     is to treat this status as a redirect and follow the contents of the Location
            //     header associated with this response. MultipleChoices is a synonym for Ambiguous.
            HttpStatusCode[HttpStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
            //
            // Summary:
            //     Equivalent to HTTP status 301. System.Net.HttpStatusCode.Moved indicates that
            //     the requested information has been moved to the URI specified in the Location
            //     header. The default action when this status is received is to follow the Location
            //     header associated with the response. When the original request method was POST,
            //     the redirected request will use the GET method. Moved is a synonym for MovedPermanently.
            HttpStatusCode[HttpStatusCode["Moved"] = 301] = "Moved";
            //
            // Summary:
            //     Equivalent to HTTP status 301. System.Net.HttpStatusCode.MovedPermanently indicates
            //     that the requested information has been moved to the URI specified in the Location
            //     header. The default action when this status is received is to follow the Location
            //     header associated with the response. MovedPermanently is a synonym for Moved.
            HttpStatusCode[HttpStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
            //
            // Summary:
            //     Equivalent to HTTP status 302. System.Net.HttpStatusCode.Found indicates that
            //     the requested information is located at the URI specified in the Location header.
            //     The default action when this status is received is to follow the Location header
            //     associated with the response. When the original request method was POST, the
            //     redirected request will use the GET method. Found is a synonym for Redirect.
            HttpStatusCode[HttpStatusCode["Found"] = 302] = "Found";
            //
            // Summary:
            //     Equivalent to HTTP status 302. System.Net.HttpStatusCode.Redirect indicates that
            //     the requested information is located at the URI specified in the Location header.
            //     The default action when this status is received is to follow the Location header
            //     associated with the response. When the original request method was POST, the
            //     redirected request will use the GET method. Redirect is a synonym for Found.
            HttpStatusCode[HttpStatusCode["Redirect"] = 302] = "Redirect";
            //
            // Summary:
            //     Equivalent to HTTP status 303. System.Net.HttpStatusCode.RedirectMethod automatically
            //     redirects the client to the URI specified in the Location header as the result
            //     of a POST. The request to the resource specified by the Location header will
            //     be made with a GET. RedirectMethod is a synonym for SeeOther.
            HttpStatusCode[HttpStatusCode["RedirectMethod"] = 303] = "RedirectMethod";
            //
            // Summary:
            //     Equivalent to HTTP status 303. System.Net.HttpStatusCode.SeeOther automatically
            //     redirects the client to the URI specified in the Location header as the result
            //     of a POST. The request to the resource specified by the Location header will
            //     be made with a GET. SeeOther is a synonym for RedirectMethod
            HttpStatusCode[HttpStatusCode["SeeOther"] = 303] = "SeeOther";
            //
            // Summary:
            //     Equivalent to HTTP status 304. System.Net.HttpStatusCode.NotModified indicates
            //     that the client's cached copy is up to date. The contents of the resource are
            //     not transferred.
            HttpStatusCode[HttpStatusCode["NotModified"] = 304] = "NotModified";
            //
            // Summary:
            //     Equivalent to HTTP status 305. System.Net.HttpStatusCode.UseProxy indicates that
            //     the request should use the proxy server at the URI specified in the Location
            //     header.
            HttpStatusCode[HttpStatusCode["UseProxy"] = 305] = "UseProxy";
            //
            // Summary:
            //     Equivalent to HTTP status 306. System.Net.HttpStatusCode.Unused is a proposed
            //     extension to the HTTP/1.1 specification that is not fully specified.
            HttpStatusCode[HttpStatusCode["Unused"] = 306] = "Unused";
            //
            // Summary:
            //     Equivalent to HTTP status 307. System.Net.HttpStatusCode.RedirectKeepVerb indicates
            //     that the request information is located at the URI specified in the Location
            //     header. The default action when this status is received is to follow the Location
            //     header associated with the response. When the original request method was POST,
            //     the redirected request will also use the POST method. RedirectKeepVerb is a synonym
            //     for TemporaryRedirect.
            HttpStatusCode[HttpStatusCode["RedirectKeepVerb"] = 307] = "RedirectKeepVerb";
            //
            // Summary:
            //     Equivalent to HTTP status 307. System.Net.HttpStatusCode.TemporaryRedirect indicates
            //     that the request information is located at the URI specified in the Location
            //     header. The default action when this status is received is to follow the Location
            //     header associated with the response. When the original request method was POST,
            //     the redirected request will also use the POST method. TemporaryRedirect is a
            //     synonym for RedirectKeepVerb.
            HttpStatusCode[HttpStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
            //
            // Summary:
            //     Equivalent to HTTP status 308. System.Net.HttpStatusCode.PermanentRedirect indicates
            //     that the request information is located at the URI specified in the Location
            //     header. The default action when this status is received is to follow the Location
            //     header associated with the response. When the original request method was POST,
            //     the redirected request will also use the POST method.
            HttpStatusCode[HttpStatusCode["PermanentRedirect"] = 308] = "PermanentRedirect";
            //
            // Summary:
            //     Equivalent to HTTP status 400. System.Net.HttpStatusCode.BadRequest indicates
            //     that the request could not be understood by the server. System.Net.HttpStatusCode.BadRequest
            //     is sent when no other error is applicable, or if the exact error is unknown or
            //     does not have its own error code.
            HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
            //
            // Summary:
            //     Equivalent to HTTP status 401. System.Net.HttpStatusCode.Unauthorized indicates
            //     that the requested resource requires authentication. The WWW-Authenticate header
            //     contains the details of how to perform the authentication.
            HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
            //
            // Summary:
            //     Equivalent to HTTP status 402. System.Net.HttpStatusCode.PaymentRequired is reserved
            //     for future use.
            HttpStatusCode[HttpStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
            //
            // Summary:
            //     Equivalent to HTTP status 403. System.Net.HttpStatusCode.Forbidden indicates
            //     that the server refuses to fulfill the request.
            HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
            //
            // Summary:
            //     Equivalent to HTTP status 404. System.Net.HttpStatusCode.NotFound indicates that
            //     the requested resource does not exist on the server.
            HttpStatusCode[HttpStatusCode["NotFound"] = 404] = "NotFound";
            //
            // Summary:
            //     Equivalent to HTTP status 405. System.Net.HttpStatusCode.MethodNotAllowed indicates
            //     that the request method (POST or GET) is not allowed on the requested resource.
            HttpStatusCode[HttpStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
            //
            // Summary:
            //     Equivalent to HTTP status 406. System.Net.HttpStatusCode.NotAcceptable indicates
            //     that the client has indicated with Accept headers that it will not accept any
            //     of the available representations of the resource.
            HttpStatusCode[HttpStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
            //
            // Summary:
            //     Equivalent to HTTP status 407. System.Net.HttpStatusCode.ProxyAuthenticationRequired
            //     indicates that the requested proxy requires authentication. The Proxy-authenticate
            //     header contains the details of how to perform the authentication.
            HttpStatusCode[HttpStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
            //
            // Summary:
            //     Equivalent to HTTP status 408. System.Net.HttpStatusCode.RequestTimeout indicates
            //     that the client did not send a request within the time the server was expecting
            //     the request.
            HttpStatusCode[HttpStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
            //
            // Summary:
            //     Equivalent to HTTP status 409. System.Net.HttpStatusCode.Conflict indicates that
            //     the request could not be carried out because of a conflict on the server.
            HttpStatusCode[HttpStatusCode["Conflict"] = 409] = "Conflict";
            //
            // Summary:
            //     Equivalent to HTTP status 410. System.Net.HttpStatusCode.Gone indicates that
            //     the requested resource is no longer available.
            HttpStatusCode[HttpStatusCode["Gone"] = 410] = "Gone";
            //
            // Summary:
            //     Equivalent to HTTP status 411. System.Net.HttpStatusCode.LengthRequired indicates
            //     that the required Content-length header is missing.
            HttpStatusCode[HttpStatusCode["LengthRequired"] = 411] = "LengthRequired";
            //
            // Summary:
            //     Equivalent to HTTP status 412. System.Net.HttpStatusCode.PreconditionFailed indicates
            //     that a condition set for this request failed, and the request cannot be carried
            //     out. Conditions are set with conditional request headers like If-Match, If-None-Match,
            //     or If-Unmodified-Since.
            HttpStatusCode[HttpStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
            //
            // Summary:
            //     Equivalent to HTTP status 413. System.Net.HttpStatusCode.RequestEntityTooLarge
            //     indicates that the request is too large for the server to process.
            HttpStatusCode[HttpStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
            //
            // Summary:
            //     Equivalent to HTTP status 414. System.Net.HttpStatusCode.RequestUriTooLong indicates
            //     that the URI is too long.
            HttpStatusCode[HttpStatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
            //
            // Summary:
            //     Equivalent to HTTP status 415. System.Net.HttpStatusCode.UnsupportedMediaType
            //     indicates that the request is an unsupported type.
            HttpStatusCode[HttpStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
            //
            // Summary:
            //     Equivalent to HTTP status 416. System.Net.HttpStatusCode.RequestedRangeNotSatisfiable
            //     indicates that the range of data requested from the resource cannot be returned,
            //     either because the beginning of the range is before the beginning of the resource,
            //     or the end of the range is after the end of the resource.
            HttpStatusCode[HttpStatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
            //
            // Summary:
            //     Equivalent to HTTP status 417. System.Net.HttpStatusCode.ExpectationFailed indicates
            //     that an expectation given in an Expect header could not be met by the server.
            HttpStatusCode[HttpStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
            //
            // Summary:
            //     Equivalent to HTTP status 421. System.Net.HttpStatusCode.MisdirectedRequest indicates
            //     that the request was directed at a server that is not able to produce a response.
            HttpStatusCode[HttpStatusCode["MisdirectedRequest"] = 421] = "MisdirectedRequest";
            //
            // Summary:
            //     Equivalent to HTTP status 422. System.Net.HttpStatusCode.UnprocessableEntity
            //     indicates that the request was well-formed but was unable to be followed due
            //     to semantic errors.
            HttpStatusCode[HttpStatusCode["UnprocessableEntity"] = 422] = "UnprocessableEntity";
            //
            // Summary:
            //     Equivalent to HTTP status 423. System.Net.HttpStatusCode.Locked indicates that
            //     the source or destination resource is locked.
            HttpStatusCode[HttpStatusCode["Locked"] = 423] = "Locked";
            //
            // Summary:
            //     Equivalent to HTTP status 424. System.Net.HttpStatusCode.FailedDependency indicates
            //     that the method couldn't be performed on the resource because the requested action
            //     depended on another action and that action failed.
            HttpStatusCode[HttpStatusCode["FailedDependency"] = 424] = "FailedDependency";
            //
            // Summary:
            //     Equivalent to HTTP status 426. System.Net.HttpStatusCode.UpgradeRequired indicates
            //     that the client should switch to a different protocol such as TLS/1.0.
            HttpStatusCode[HttpStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
            //
            // Summary:
            //     Equivalent to HTTP status 428. System.Net.HttpStatusCode.PreconditionRequired
            //     indicates that the server requires the request to be conditional.
            HttpStatusCode[HttpStatusCode["PreconditionRequired"] = 428] = "PreconditionRequired";
            //
            // Summary:
            //     Equivalent to HTTP status 429. System.Net.HttpStatusCode.TooManyRequests indicates
            //     that the user has sent too many requests in a given amount of time.
            HttpStatusCode[HttpStatusCode["TooManyRequests"] = 429] = "TooManyRequests";
            //
            // Summary:
            //     Equivalent to HTTP status 431. System.Net.HttpStatusCode.RequestHeaderFieldsTooLarge
            //     indicates that the server is unwilling to process the request because its header
            //     fields (either an individual header field or all the header fields collectively)
            //     are too large.
            HttpStatusCode[HttpStatusCode["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
            //
            // Summary:
            //     Equivalent to HTTP status 451. System.Net.HttpStatusCode.UnavailableForLegalReasons
            //     indicates that the server is denying access to the resource as a consequence
            //     of a legal demand.
            HttpStatusCode[HttpStatusCode["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
            //
            // Summary:
            //     Equivalent to HTTP status 500. System.Net.HttpStatusCode.InternalServerError
            //     indicates that a generic error has occurred on the server.
            HttpStatusCode[HttpStatusCode["InternalServerError"] = 500] = "InternalServerError";
            //
            // Summary:
            //     Equivalent to HTTP status 501. System.Net.HttpStatusCode.NotImplemented indicates
            //     that the server does not support the requested function.
            HttpStatusCode[HttpStatusCode["NotImplemented"] = 501] = "NotImplemented";
            //
            // Summary:
            //     Equivalent to HTTP status 502. System.Net.HttpStatusCode.BadGateway indicates
            //     that an intermediate proxy server received a bad response from another proxy
            //     or the origin server.
            HttpStatusCode[HttpStatusCode["BadGateway"] = 502] = "BadGateway";
            //
            // Summary:
            //     Equivalent to HTTP status 503. System.Net.HttpStatusCode.ServiceUnavailable indicates
            //     that the server is temporarily unavailable, usually due to high load or maintenance.
            HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
            //
            // Summary:
            //     Equivalent to HTTP status 504. System.Net.HttpStatusCode.GatewayTimeout indicates
            //     that an intermediate proxy server timed out while waiting for a response from
            //     another proxy or the origin server.
            HttpStatusCode[HttpStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
            //
            // Summary:
            //     Equivalent to HTTP status 505. System.Net.HttpStatusCode.HttpVersionNotSupported
            //     indicates that the requested HTTP version is not supported by the server.
            HttpStatusCode[HttpStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
            //
            // Summary:
            //     Equivalent to HTTP status 506. System.Net.HttpStatusCode.VariantAlsoNegotiates
            //     indicates that the chosen variant resource is configured to engage in transparent
            //     content negotiation itself and, therefore, isn't a proper endpoint in the negotiation
            //     process.
            HttpStatusCode[HttpStatusCode["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
            //
            // Summary:
            //     Equivalent to HTTP status 507. System.Net.HttpStatusCode.InsufficientStorage
            //     indicates that the server is unable to store the representation needed to complete
            //     the request.
            HttpStatusCode[HttpStatusCode["InsufficientStorage"] = 507] = "InsufficientStorage";
            //
            // Summary:
            //     Equivalent to HTTP status 508. System.Net.HttpStatusCode.LoopDetected indicates
            //     that the server terminated an operation because it encountered an infinite loop
            //     while processing a WebDAV request with "Depth: infinity". This status code is
            //     meant for backward compatibility with clients not aware of the 208 status code
            //     System.Net.HttpStatusCode.AlreadyReported appearing in multistatus response bodies.
            HttpStatusCode[HttpStatusCode["LoopDetected"] = 508] = "LoopDetected";
            //
            // Summary:
            //     Equivalent to HTTP status 510. System.Net.HttpStatusCode.NotExtended indicates
            //     that further extensions to the request are required for the server to fulfill
            //     it.
            HttpStatusCode[HttpStatusCode["NotExtended"] = 510] = "NotExtended";
            //
            // Summary:
            //     Equivalent to HTTP status 511. System.Net.HttpStatusCode.NetworkAuthenticationRequired
            //     indicates that the client needs to authenticate to gain network access; it's
            //     intended for use by intercepting proxies used to control access to the network.
            HttpStatusCode[HttpStatusCode["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
        })(HttpStatusCode = Net.HttpStatusCode || (Net.HttpStatusCode = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="HttpStatusCode.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        class WebClient {
            constructor(url) {
                this.url = url;
                this.timeoutMs = 90000;
                this.responseType = "text";
                this.async = true;
                if (Calysto.Core.Constants.WebClientGlobalTimeout > 0)
                    this.timeoutMs = Calysto.Core.Constants.WebClientGlobalTimeout;
            }
            static IsCrossdomain(url) {
                if (url) {
                    if (url.indexOf("//") == 0) {
                        url = location.protocol + url; // add http: in front
                    }
                    if (url.indexOf("http") == 0) {
                        var origin = location.protocol + "//" + location.hostname; // hostname includes port (this is origin for crossdomain requests)
                        return url.indexOf(origin) != 0; // url is absolute and don't starts with httpRoot (origin)
                    }
                }
                return false;
            }
            static GetXMLHttpRequest(url) {
                /// <summary>
                /// Static method to get XMLHTTP object
                /// </summary>
                /// <param name="url" optional="true">if url is provided, and host is different than current host, will use XDomainRequest on IE8 and IE9 </param>
                /// <returns type="XMLHttpRequest"></returns>
                if (window.XMLHttpRequest) {
                    // Mozilla, Safari, ...
                    // XMLHttpRequest can be used for crossdomain request too
                    // server has to return headers:
                    //Access-Control-Allow-Origin: *
                    //Access-Control-Allow-Headers: X-MYRESPONSEHEADER
                    //Access-Control-Allow-Methods: POST
                    //Access-Control-Allow-Methods: GET
                    return new XMLHttpRequest();
                }
                else if (WebClient.IsCrossdomain(url) && window.XDomainRequest) {
                    // ie8, ie9 ? // custom headers can not be set in XDomainRequest
                    return new window.XDomainRequest();
                }
                else if (window.ActiveXObject) // IE < version 8
                 {
                    var axO = ['Microsoft.XMLHTTP', 'Msxml2.XMLHTTP', 'Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.4.0', 'Msxml2.XMLHTTP.3.0'];
                    for (var i = 0; i < axO.length; i++) {
                        try {
                            return new window.ActiveXObject(axO[i]);
                        }
                        catch (e) { }
                    }
                }
                ////alert("Your browser doesn't support AJAX. Please use the latest version of Internet Explorer, Firefox, Chrome, Safari, Opera etc.");
                return null;
            }
            SetTimeout(timeoutMs) {
                this.timeoutMs = timeoutMs;
                return this;
            }
            SetUrl(url) {
                this.url = url;
                return this;
            }
            SetAsync(isAsync) {
                this.async = !!isAsync;
            }
            CreateData(httpMethod, content, uploadType, fileName) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="httpMethod" type="string">GET or POST</param>
                /// <param name="content" type="string|object|json|File"></param>
                /// <param name="uploadType" type="string">application/x-www-form-urlencoded or text/plain or application/json or multipart/form-data</param>
                /// <param name="fileName" type="string" optional="true">save as filename on server</param>
                return {
                    content: content,
                    fileName: fileName,
                    uploadType: uploadType || "text/plain",
                    httpMethod: httpMethod || "GET",
                    formData: false
                };
            }
            CreateNameValue(name, value) {
                return {
                    name: name + "",
                    value: value + ""
                };
            }
            UploadDictionary(dic) {
                var arr = [];
                Calysto.Collections.ForEachOwnProperties(dic, (name, value, index) => arr.push(encodeURIComponent(name + "") + "=" + encodeURIComponent(value + "")));
                this.data = this.CreateData("POST", arr.join("&"), "application/x-www-form-urlencoded");
                return this;
            }
            ;
            UploadString(str) {
                this.data = this.CreateData("POST", str, "text/plain");
                return this;
            }
            ;
            UploadJson(json) {
                this.data = this.CreateData("POST", json, "application/json");
                return this;
            }
            ;
            UploadData(data) {
                this.data = this.CreateData("POST", data, "multipart/form-data");
                this.data.formData = true;
                return this;
            }
            UploadHtmlForm(form, appendKeys) {
                if (window.FormData) {
                    let f1 = new FormData(form);
                    if (appendKeys) {
                        for (let kv of appendKeys) {
                            f1.append(kv.Key, kv.Value);
                        }
                    }
                    this.data = this.CreateData(form.method, f1, form.enctype);
                    this.data.formData = true;
                }
                else {
                    // IE<=9
                    // works on asp.net core mvc
                    let dic1 = Calysto.Forms.FormSerialize(form);
                    if (appendKeys) {
                        for (let kv of appendKeys) {
                            dic1[kv.Key] = kv.Value;
                        }
                    }
                    this.UploadDictionary(dic1);
                }
                return this;
            }
            UploadFile(file, fileName) {
                this.data = this.CreateData("POST", file, "multipart/form-data", fileName || file.name);
                return this;
            }
            /**
             * Set response type
             * @param typeString possible values:  "", "text", "arraybuffer", "blob", "document", "json", if not set, default is "text"
             */
            SetResponseType(typeString) {
                /// <summary>
                /// Set response type.
                /// </summary>
                /// <param name="typeString" type="String"> "", "text", "arraybuffer", "blob", "document", "json"</param>
                /// <returns type=""></returns>
                this.responseType = typeString || "";
                return this;
            }
            AddRequestHeader(name, value) {
                if (!this.headers)
                    this.headers = [];
                this.headers.push(this.CreateNameValue(name, value));
                return this;
            }
            Abort() {
                this.isAborted = true;
                if (this.xhr) {
                    this.xhr.abort();
                    this.xhr = null;
                }
                return this;
            }
            Start() {
                if (this.isAborted)
                    return this;
                if (this.isStarted)
                    return this;
                this.isStarted = true;
                this.xhr = WebClient.GetXMLHttpRequest(this.url);
                var _safeThis = this;
                this.xhr.onabort = function (ev) {
                    console.log({ abort: _safeThis.xhr.getAllResponseHeaders() });
                };
                var timeoutId = NaN;
                var isComplete = false;
                if (this.timeoutMs > 0) {
                    timeoutId = setTimeout(() => {
                        if (!isComplete) {
                            isComplete = true;
                            // timeout occures before readyState == 4
                            _safeThis.xhr.abort();
                            var ss = _safeThis.GetLiistenersItem("OnTimeout");
                            if (ss)
                                ss.callbacks.ForEach(fn => fn(_safeThis, { type: "timeout", bubles: false }));
                        }
                    }, this.timeoutMs);
                }
                // response is ok if: 	if(sender.config.xhr.status >= 200 && sender.config.xhr.status < 300)
                // status code has to be read onload
                // use "onload", because "onloadend" doesn't work on IE<=9 and some old browsers
                Calysto.Collections.ForEachOwnProperties(this.listeners, (name, obj, index) => {
                    var xhrOrUpload = obj.isUpload ? _safeThis.xhr.upload : _safeThis.xhr;
                    if (xhrOrUpload) {
                        //console.log("assign: " + obj.eventName);
                        // da bi radilo na starom IE8, jer nema "onload" event
                        if (obj.fullName == "OnLoad") {
                            xhrOrUpload.onreadystatechange = (ev) => {
                                if (xhrOrUpload.readyState == 4 && !isComplete) {
                                    ev = ev || { type: "load" }; // required for IE where ev.type = ""
                                    isComplete = true;
                                    clearTimeout(timeoutId);
                                    var ss = _safeThis.GetLiistenersItem("OnLoad");
                                    if (ss)
                                        ss.callbacks.ForEach(fn => fn(_safeThis, ev));
                                }
                            };
                        }
                        else {
                            xhrOrUpload["on" + obj.eventName] = (ev) => {
                                if (!isComplete) {
                                    ev = ev || { type: obj.eventName }; // required for IE where ev.type = ""
                                    if (ev.type == "abort" || ev.type == "error" || ev.type == "timeout") {
                                        isComplete = true;
                                    }
                                    var ss = _safeThis.GetLiistenersItem(obj.fullName);
                                    if (ss)
                                        ss.callbacks.ForEach(fn => fn(_safeThis, ev));
                                }
                            };
                        }
                    }
                });
                var data = this.data || {};
                if (data.formSubmit) {
                    data.formSubmit.action = this.url;
                    data.formSubmit.submit();
                    return this;
                }
                this.xhr.open(data.httpMethod || "GET", this.url, this.async);
                this.xhr.timeout = this.timeoutMs; // on IE, timeout may be set after .open() is invoked
                // IE8, IE9 XDomainRequest doesn't support setRequestHeader and it ads Origin header by itself
                if (data.uploadType) {
                    if (window.FormData) {
                        // IE10,11, Chrome and all other have to use property:
                        // it won't send content-type header unless property is set
                        this.xhr.contentType = data.uploadType;
                    }
                    else {
                        // IE9 must use setRequestHeaer()
                        // it won't send content-type header unless setRequestHeader() is used
                        this.xhr.setRequestHeader('Content-Type', data.uploadType);
                    }
                }
                if (data.fileName) {
                    this.xhr.setRequestHeader("x-calysto-filename", data.fileName);
                }
                if (this.responseType) {
                    this.xhr.responseType = this.responseType;
                }
                if (this.headers) {
                    this.headers.ForEach(item => this.xhr.setRequestHeader(item.name, item.value));
                }
                if ("content" in data) {
                    let content = data.content;
                    if (typeof content == "function")
                        content = content();
                    this.xhr.send(content);
                }
                else {
                    this.xhr.send();
                }
                return this;
            }
            GetResponseText() {
                if (this.xhr) {
                    return this.xhr.responseText;
                }
                return "";
            }
            GetResponse() {
                if (this.xhr) {
                    return this.xhr.response;
                }
                return;
            }
            GetLiistenersItem(fullName) {
                return this.listeners[fullName];
            }
            AddCallback(fullName, func) {
                if (this.isStarted)
                    throw new Error("Request started, can't assign callback: " + fullName);
                if (!this.listeners)
                    this.listeners = {};
                var item = this.GetLiistenersItem(fullName);
                // create new if doesn't exist
                if (!item) {
                    var isUpload = fullName.StartsWith("OnUpload");
                    var evName = isUpload ? fullName.substr(8).toLowerCase() : fullName.substr(2).toLowerCase();
                    item = { isUpload: isUpload, eventName: evName, fullName: fullName, callbacks: [] };
                    this.listeners[fullName] = item;
                }
                // push func callback
                item.callbacks.push(func);
                return this;
            }
            //#region Upload events
            OnUploadAbort(func) {
                /// <summary>
                /// Upload aborted.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnUploadAbort", func);
            }
            OnUploadError(func) {
                /// <summary>
                /// Upload error.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnUploadError", func);
            }
            OnUploadLoad(func) {
                /// <summary>
                /// Upload complete.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnUploadLoad", func);
            }
            ;
            ////this.OnUploadLoadEnd = function (func)
            ////{
            ////	/// <summary>
            ////	/// implements all three events: abort, loadend, error
            ////	/// </summary>
            ////	/// <param name="func">function(sender, e){...}</param>
            ////	return AddCallback.call(this, "OnUploadLoadEnd", func);
            ////};
            ////this.OnUploadLoadStart = function (func)
            ////{
            ////	/// <summary>
            ////	/// Upload start.
            ////	/// </summary>
            ////	/// <param name="func">function(sender, e){...}</param>
            ////	return AddCallback.call(this, "OnUploadLoadStart", func);
            ////};
            OnUploadProgress(func) {
                /// <summary>
                /// Use e.loaded and e.total<br/>
                /// Property 'e.position' is deprecated. Please use 'e.loaded' instead.<br/>
                /// Property 'e.totalSize' is deprecated. Please use 'e.total' instead.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnUploadProgress", func);
            }
            OnUploadTimeout(func) {
                /// <summary>
                /// Upload timeout.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnUploadTimeout", func);
            }
            ;
            //#endregion
            //#region Download events
            OnReadyStateChange(func) {
                /// <summary>
                /// Ready state change.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnReadyStateChange", func);
            }
            OnAbort(func) {
                /// <summary>
                /// Download abort.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnAbort", func);
            }
            OnError(func) {
                /// <summary>
                /// Download error.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnError", func);
            }
            // success ne postoji
            ////this.OnSuccess = function (func)
            ////{
            ////	/// <summary>
            ////	/// Download complete, status code between 200 and 300.
            ////	/// </summary>
            ////	/// <param name="func">function(sender, e){...}</param>
            ////	return AddCallback.call(this, "OnSuccess", func);
            ////};
            OnLoad(func) {
                /// <summary>
                /// Download complete, any status code, successful or error.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnLoad", func);
            }
            ////this.OnLoadEnd = function (func)
            ////{
            ////	/// <summary>
            ////	/// Download, implements all three events: abort, load, error (doesn't work on IE 9 and older)
            ////	/// </summary>
            ////	/// <param name="func">function(sender, e){...}</param>
            ////	return AddCallback.call(this, "OnLoadEnd", func);
            ////};
            ////this.OnLoadStart = function (func)
            ////{
            ////	/// <summary>
            ////	/// Download load start.
            ////	/// </summary>
            ////	/// <param name="func">function(sender, e){...}</param>
            ////	return AddCallback.call(this, "OnLoadStart", func);
            ////};
            OnProgress(func) {
                /// <summary>
                /// Download progress<br/>
                /// Use e.loaded and e.total<br/>
                /// Property 'e.position' is deprecated. Please use 'e.loaded' instead.<br/>
                /// Property 'e.totalSize' is deprecated. Please use 'e.total' instead.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnProgress", func);
            }
            OnTimeout(func) {
                /// <summary>
                /// Download timeout.
                /// </summary>
                /// <param name="func">function(sender, e){...}</param>
                return this.AddCallback("OnTimeout", func);
            }
        }
        Net.WebClient = WebClient;
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        function Log(msg) {
            console.log(Date.now(), msg);
        }
        class CalystoWebSocket {
            constructor(
            /** eg. /files/path.aspx */
            virtualPath) {
                this.virtualPath = virtualPath;
                /** Add new callback after socket opened. */
                this.OnOpen = new Calysto.MulticastDelegate().AsFunc(this);
                /** Callback after socket closed */
                this.OnClose = new Calysto.MulticastDelegate().AsFunc(this);
                this.OnError = new Calysto.MulticastDelegate().AsFunc(this);
                /** Callback on message received*/
                this.OnMessage = new Calysto.MulticastDelegate().AsFunc(this);
                this.isSending = false;
            }
            //WebSocket.CLOSED = 3;
            //WebSocket.CLOSING = 2;
            //WebSocket.CONNECTING = 0;
            //WebSocket.OPEN = 1
            Open(callbackOpened) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined)
                    Log("#WebSocket: " + (this.ws ? this.ws.readyState : "not initialized"));
                //#endif
                if (this.ws && this.ws.readyState == WebSocket.OPEN) {
                    if (callbackOpened)
                        callbackOpened(this);
                }
                else if (this.ws && this.ws.readyState == WebSocket.CONNECTING) {
                    // do nothing, already in connecting state, callbackOpened will be invoked from this.ws.onopen()
                }
                else {
                    var url = this.virtualPath;
                    if (!(url.indexOf("//") > 0)) {
                        url = (window.location.protocol == "https:" ? "wss:" : "ws:") + "//" + window.location.host + this.virtualPath;
                    }
                    try {
                        // this invokes handshake with server and may throw internal error - in Chrome, error is written to console
                        // the rest of JS continues to execute and cfg.ws.onerror is invoked after fn is assigned
                        // tricky: error is created before, but onerror is defined later and invoked with error which is created before the onerror is defined
                        // this can not be caught in try-catch, because it doesn't throw JS exception
                        this.ws = new WebSocket(url); // instantinate and open socket
                        this.ws.binaryType = "arraybuffer"; // if not specified, default is Blob
                    }
                    catch (ex1) {
                    }
                    // this.ws.on... event listerens are Promise like, so don't worry if data arrives before the event is assigned
                    this.ws.onmessage = (ev) => {
                        if (ev.data && this.OnMessage.Any()) {
                            // ev.data is defined in cfg.ws.binaryType
                            Calysto.Json.BinaryFrame.DeserializeAsync(ev.data, (obj) => {
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    Log({ "#SOCKET_RECEIVED": obj });
                                //#endif
                                this.OnMessage.Invoke(item => item(obj));
                            });
                        }
                    };
                    this.ws.onclose = () => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined)
                            Log("#WebSocket closed");
                        //#endif
                        this.OnClose.Invoke(item => item());
                    };
                    this.ws.onerror = () => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined)
                            Log("#WebSocket error");
                        //#endif
                        this.OnError.Invoke(item => item("#WebSocket error"));
                    };
                    this.ws.onopen = () => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined)
                            Log("#WebSocket opened");
                        //#endif
                        this.OnOpen.Invoke(item => item());
                        // invoke callback:
                        if (callbackOpened)
                            callbackOpened(this);
                    };
                }
            }
            ;
            SendWorker() {
                var obj;
                if (this.sendQueue && (obj = this.sendQueue.shift())) {
                    this.isSending = true;
                    Calysto.Json.BinaryFrame.SerializeAsync(obj, (binaryFrame) => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined)
                            Log({ "#SOCKET_SEND": obj });
                        //#endif
                        var finalBlob = binaryFrame.ToBinaryData();
                        this.ws.send(finalBlob);
                        // send next item:
                        this.SendWorker();
                    });
                }
                else {
                    this.isSending = false;
                }
            }
            Send(obj) {
                if (!this.sendQueue)
                    this.sendQueue = [];
                this.sendQueue.push(obj);
                if (!this.isSending) {
                    this.Open((sender) => this.SendWorker());
                }
                return this;
            }
            IsOpened() {
                return !!(this.ws && this.ws.readyState == WebSocket.OPEN);
            }
            ;
            Close() {
                if (this.ws) {
                    this.ws.close();
                }
                return this;
            }
        }
        Net.CalystoWebSocket = CalystoWebSocket;
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="webtypes.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            class AjaxServiceClientBase {
                constructor() {
                    this.OnAbort = new Calysto.MulticastDelegate()
                        .OnInvoke(msg => { this.SetValue("OnAbort", msg); })
                        .OnAdd(fn => this.TryInvokeValue("OnAbort", fn))
                        .AsFunc(this);
                    /**promisse, callback on error response received*/
                    this.OnError = new Calysto.MulticastDelegate()
                        .OnInvoke(err => { this.SetValue("OnError", err); })
                        .OnAdd(fn => this.TryInvokeValue("OnError", fn))
                        .AsFunc(this);
                    /**promisse, callback on upload or download progress changed*/
                    this.OnProgress = new Calysto.MulticastDelegate()
                        .OnInvoke(ev => { this.SetValue("OnProgress", ev); })
                        .OnAdd(fn => this.TryInvokeValue("OnProgress", fn))
                        .AsFunc(this);
                    /**promisse, callback on ajax request is complete, after all other events are triggered*/
                    this.OnEnd = new Calysto.MulticastDelegate()
                        .OnInvoke(() => { this.SetValue("OnEnd", true); })
                        .OnAdd(fn => this.TryInvokeValue("OnEnd", fn))
                        .AsFunc(this);
                    this._values = {};
                }
                /**Abort request */
                Abort() {
                    this.OnAbort.Invoke(f => f("abort"));
                    return this;
                }
                /**
                 * Add value to cache and invoke delegate.
                 * @param name
                 * @param value
                 */
                SetValue(name, value) {
                    this._values[name] = value;
                }
                /**
                 *  If value already exists, invoke delegate.
                 * @param name
                 * @param fn
                 */
                TryInvokeValue(name, fn) {
                    if (name in this._values) {
                        fn(this._values[name]);
                    }
                }
            }
            WebService.AjaxServiceClientBase = AjaxServiceClientBase;
            class AjaxServiceClientVoid extends AjaxServiceClientBase {
                constructor() {
                    super(...arguments);
                    /**promisse, callback on successful response received*/
                    this.OnSuccess = new Calysto.MulticastDelegate()
                        .OnInvoke(() => { this.SetValue("OnSuccess", true); })
                        .OnAdd(fn => this.TryInvokeValue("OnSuccess", fn))
                        .AsFunc(this);
                    /**invoke before any other event, if set PreventDefault==true, will invoke OnEnd and prevent any other event from executing*/
                    this.OnResponse = new Calysto.MulticastDelegate()
                        .OnInvoke(container => { this.SetValue("OnResponse", container); })
                        .OnAdd(fn => this.TryInvokeValue("OnResponse", fn))
                        .AsFunc(this);
                }
            }
            WebService.AjaxServiceClientVoid = AjaxServiceClientVoid;
            class AjaxServiceClientWithReturn extends AjaxServiceClientBase {
                constructor() {
                    super(...arguments);
                    /**promisse, callback on successful response received*/
                    this.OnSuccess = new Calysto.MulticastDelegate()
                        .OnInvoke(resp => { this.SetValue("OnSuccess", resp); })
                        .OnAdd(fn => this.TryInvokeValue("OnSuccess", fn))
                        .AsFunc(this);
                    /**invoke before any other event, if set PreventDefault==true, will invoke OnEnd and prevent any other event from executing*/
                    this.OnResponse = new Calysto.MulticastDelegate()
                        .OnInvoke(container => { this.SetValue("OnResponse", container); })
                        .OnAdd(fn => this.TryInvokeValue("OnResponse", fn))
                        .AsFunc(this);
                }
            }
            WebService.AjaxServiceClientWithReturn = AjaxServiceClientWithReturn;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            ;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            class WebSocketSession {
                constructor(
                /**settings is unique per method*/
                settings, 
                /** socket instance may be shared among methods*/
                Socket) {
                    this.settings = settings;
                    this.Socket = Socket;
                    this.OnBroadcastMessage = new Calysto.MulticastDelegate().AsFunc(this);
                    this.OnError = new Calysto.MulticastDelegate().AsFunc(this);
                    this._pendingCallbacks = new Calysto.Dictionary();
                    // implement message receiver for socket instance:
                    this.Socket.OnMessage(responseContainer => this.HandleSocketMessage(responseContainer));
                }
                HandleSocketMessage(responseContainer) {
                    let isBroadcast = responseContainer.Method == Calysto.Constants.AppConstants.BroadcastMethodName;
                    let context = null;
                    if (!isBroadcast && responseContainer.ReferenceGuid) {
                        let refOut = new Calysto.BoxValue();
                        if (this._pendingCallbacks.TryGetValue(responseContainer.ReferenceGuid, refOut)) {
                            this._pendingCallbacks.RemoveKey(responseContainer.ReferenceGuid);
                            context = refOut.GetValue();
                        }
                    }
                    let isHandled = this.ProcessResponse(context, responseContainer);
                    if (!isHandled) {
                        if (responseContainer.JavaScriptLO && !responseContainer.IsJavaScriptLODone) {
                            responseContainer.IsJavaScriptLODone = true;
                            let nodeLo = Calysto.ScriptLoader.LoadJS(responseContainer.JavaScriptLO);
                            setTimeout(() => nodeLo.parentNode.removeChild(nodeLo), 200); // remove from dom immediately
                        }
                        if (isBroadcast) {
                            this.OnBroadcastMessage.Invoke(fn => fn(responseContainer.ReturnedValue));
                        }
                        if (context) {
                            context.OnResponse.Invoke(f => f(responseContainer));
                            context.OnSuccess.Invoke(f => f(responseContainer.ReturnedValue));
                            context.OnEnd.Invoke();
                        }
                    }
                }
                ProcessResponse(context, responseContainer) {
                    if (responseContainer.IsEngineExpired) {
                        this.Socket.Close(); // socket has to be closed from client
                        WebService.EngineExpired();
                        return true;
                    }
                    if (Calysto.Page.IsPageReloading) {
                        // do not execute the rest of the code because it would throw exception only
                        return true;
                    }
                    if (responseContainer.EchoMsg == "EchoServerRequest") {
                        //return response
                        this.Socket.Send({
                            ReferenceGuid: responseContainer.ReferenceGuid,
                            EchoMsg: "EchoClientResponse"
                        });
                        return true;
                    }
                    // exception can not be handled in OnSolicitedMessage if there is not method name or guid, so handle it here
                    if (responseContainer.ExceptionMessage && !responseContainer.IsExceptionMessageDone) {
                        responseContainer.IsExceptionMessageDone = true;
                        if (context === null || context === void 0 ? void 0 : context.OnError.Any()) {
                            context.OnError.Invoke(f => f(responseContainer.ExceptionMessage));
                            //#if DEBUG
                            if (Calysto.Core.IsDebugDefined)
                                throw new Error("Socket Error: " + responseContainer.ExceptionMessage).AppendErrorDetails(responseContainer.ExceptionDetails, true);
                            //#endif
                        }
                        else if (this.OnError.Any()) {
                            this.OnError.Invoke(f => f(responseContainer.ExceptionMessage));
                            //#if DEBUG
                            if (Calysto.Core.IsDebugDefined)
                                throw new Error("Socket Error: " + responseContainer.ExceptionMessage).AppendErrorDetails(responseContainer.ExceptionDetails, true);
                            //#endif
                        }
                        else {
                            // unhandled exception on server
                            throw new Error(responseContainer.ExceptionMessage).AppendErrorDetails(responseContainer.ExceptionDetails, true);
                        }
                        return true;
                    }
                    // not handled
                    return false;
                }
                OnMethodReturn(requestGuid, context) {
                    this._pendingCallbacks.Add(requestGuid, context);
                }
            }
            WebService.WebSocketSession = WebSocketSession;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="ajaxserviceclientbase.ts" />
/// <reference path="icalystoprogressevent.ts" />
/// <reference path="isocketservicerequestcontainer.ts" />
/// <reference path="isocketwebrequestarguments.ts" />
/// <reference path="iwebserviceresponsecontainer.ts" />
/// <reference path="iwebserviceresponsecontainerwithreturn.ts" />
/// <reference path="iwebservicesettings.ts" />
/// <reference path="webtypes.ts" />
/// <reference path="websocketsession.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            function Log(msg) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined)
                    console.log(Date.now(), msg);
                //#endif
            }
            WebService.Log = Log;
            function EngineExpired() {
                if (Calysto.Page && Calysto.Page.OnVersionExpired && Calysto.Page.OnVersionExpired.Any && Calysto.Page.OnVersionExpired.Any()) {
                    Calysto.Page.OnVersionExpired.Invoke(f => f());
                }
                else if (!Calysto.Page.IsPageReloading) {
                    document.documentElement.className += ' calystoAjaxLoading';
                    Calysto.Page.IsPageReloading = true;
                    Calysto.Notification.Create(Calysto.Resources.CalystoLang.NewVersionFoundPageIsReloading, "warning", NaN, "top", "center").Show();
                    setTimeout(() => window.location.reload(true), 1000); // make delay if something brakes down, prevent too many page refreshs
                }
            }
            WebService.EngineExpired = EngineExpired;
            function CreateUrl(vpath, settings) {
                // path + query, important: exclude # hash
                return (vpath || "")
                    .replace("__calysto_method_name__", settings.method || "")
                    .replace("__calysto_ss__", settings.sstate ? "1" : "0")
                    .replace("__calysto_culture__", Calysto.Globalization.CultureInfo.CurrentCulture.Name)
                    .replace("__calysto_current_url__", Calysto.Utility.Encoding.Base64RndEncoder.EncodeToBase64String(window.location.pathname + window.location.search));
            }
            WebService.CreateUrl = CreateUrl;
            function CreateArgsObj(methodName, argsValues, argNames) {
                var obj = {};
                for (var n = 0; n < argNames.length; n++) {
                    var val = argsValues[n];
                    if (typeof (val) == "undefined") {
                        val = null; // convert "undefined" to null value
                    }
                    else if (typeof (val) == "function") {
                        throw new Error("Argument " + argNames[n] + " can not be an function in " + methodName + "(" + argNames.join(", ") + ")");
                    }
                    obj[argNames[n]] = val;
                }
                return obj;
            }
            WebService.CreateArgsObj = CreateArgsObj;
            /**test if event is triggered by user action */
            function IsTriggeredByUserAction() {
                if (window.event && "isTrusted" in window.event) {
                    // firefox doesn't have "event" in window
                    // isTrusted==true says that event is triggered by user action
                    if (event && event.isTrusted && (event.target || event.srcElement)) {
                        // ok, event is triggered by user action
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            console.log("web service method invoked by user event: " + event.type);
                        }
                        //#endif
                        return true;
                    }
                    else {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            throw new Error("Event is null, not invoked in user event.");
                        }
                        //#endif
                        //return servclient; // da ne baca exception na chain metode koje se invokaju kasnije
                        //return false;
                    }
                }
                return false;
            }
            WebService.IsTriggeredByUserAction = IsTriggeredByUserAction;
            function CreateFullStateObj(sender, state) {
                let xhr = sender.xhr;
                // LET'S THROW EXCEPTION IF NOT SUPPORTED, nothing else will work anyway
                // XDomainRequest doesn't support getResponseHeader
                // getResponseHeader throws excetpion in few browsers: "An attempt was made to use an object that is not, or is no longer, usable"
                let contentType = "";
                try {
                    contentType = xhr.getResponseHeader("Content-type");
                }
                catch (ex11) { }
                if (!contentType)
                    contentType = xhr["contentType"] || (xhr.response || {}).type || "";
                var calystoType = xhr.getResponseHeader(Calysto.Constants.WsjsHeaderConstants.XTypeHeaderKey);
                var state2 = Object.assign(Object.assign({}, state), { isErrorStatus: (xhr.status < 200 || xhr.status >= 300), contentType: contentType, isHtml: (contentType || "").indexOf("text/html") >= 0, isJson: (contentType || "").indexOf("application/json") >= 0, calystoType: calystoType });
                switch (xhr.responseType) {
                    case "arraybuffer":
                        state2.arrayBuffer = xhr.response;
                        break;
                    case "blob":
                        state2.blob = xhr.response;
                        break;
                    case "":
                    case "text":
                        state2.respTxt = xhr.responseText;
                        break;
                    default:
                        throw new Error("ResponseType not supported: " + xhr.responseType);
                }
                return state2;
            }
            WebService.CreateFullStateObj = CreateFullStateObj;
            function ReadArrayBuffer(state, onComplete) {
                if (state.calystoType == Calysto.Constants.WsjsHeaderConstants.XTypeHeaderBinaryFrameValue) {
                    Calysto.Json.BinaryFrame.DeserializeAsync(state.arrayBuffer, (finalObj) => {
                        state.responseContainer = finalObj;
                        // finalObj contains complete object including CalystoBlobs inside
                        onComplete();
                    });
                }
                else {
                    // exception handled on server, response http status is 200 and we probably have JSON sent from server
                    // if exception occured on server, we probably have JSON (calysto-json object) or text (html generated on server)
                    // eg, we're expecing Blob, but server didn't return CalystoBlob, exception was thrown on server and now we're getting error page html
                    state.respTxt = Calysto.Utility.Encoding.UTF8.GetString(new Uint8Array(state.arrayBuffer));
                    if (state.isHtml) {
                        state.errorText = "Blob download failed";
                        state.errorHtml = state.respTxt;
                        onComplete();
                    }
                    else if (state.isJson) {
                        // we have Calysto exception response, handle it as classic ajax response
                        try {
                            state.responseContainer = Calysto.Json.Deserialize(state.respTxt);
                        }
                        catch (e1) {
                            state.errorText = "Blob download failed";
                            state.errorDescription = state.respTxt;
                        }
                        onComplete();
                    }
                    else {
                        state.errorText = "Blob download failed";
                        state.errorDescription = state.respTxt;
                        onComplete();
                    }
                }
            }
            WebService.ReadArrayBuffer = ReadArrayBuffer;
            ;
            function ProcessResponseContainer(responseContainer, state) {
                // JS has to be executed before OnComplete is invoked
                // eg.if js contains version invalidation code, it must execute before OnComplete because in OnComplete may throw exception if argument is null
                state.fnResponseContainerCallback(responseContainer);
                if (responseContainer.IsEngineExpired) {
                    state.fnResponseEndCallback(); // to hide loading spinner
                    EngineExpired();
                    return;
                }
                if (Calysto.Page.IsPageReloading) {
                    // do not execute the rest of the code because it would throw exception only
                    state.fnResponseEndCallback(); // to hide loading spinner
                    return;
                }
                if (responseContainer.ExceptionMessage && !responseContainer.IsExceptionMessageDone) {
                    responseContainer.IsExceptionMessageDone = true;
                    // this is exception thrown on server
                    state.fnResponseEndCallback();
                    state.fnErrorCallback(responseContainer.ExceptionMessage, responseContainer.ExceptionDetails, true);
                    return;
                }
                if (responseContainer.JavaScriptLO && !responseContainer.IsJavaScriptLODone) {
                    responseContainer.IsJavaScriptLODone = true;
                    ////eval("(" + state.respJsObj.JavaScript + ")"); // doesn't work if there is html inside
                    // when state.respJsObj is deserialized, state.respJsObj.JavaScript contains real javascript, not string any more, so load it as javascript, not using eval
                    let nodeLo = Calysto.ScriptLoader.LoadJS(responseContainer.JavaScriptLO);
                    setTimeout(() => nodeLo.parentNode.removeChild(nodeLo), 200); // remove from dom immediately
                }
                if (responseContainer.IsSuccessful) {
                    // don't use new thread, this way we have stack trace if something breaks
                    state.fnReturnValueCallback(responseContainer.ReturnedValue);
                }
                // at the end call response end, it will hide loading spinner
                state.fnResponseEndCallback();
            }
            WebService.ProcessResponseContainer = ProcessResponseContainer;
            function ProcessResponse(state) {
                if (Calysto.Core.IsDebugDefined)
                    Log({ AJAX_RESPONSE: state.responseContainer });
                if (state.errorText) {
                    state.fnResponseEndCallback();
                    state.fnErrorCallback(state.errorText, { errorDescription: state.errorDescription, errorHtml: state.errorHtml }, false);
                }
                else if (state.responseContainer && state.responseContainer.Type == "IWebServiceResponseContainer") {
                    ProcessResponseContainer(state.responseContainer, state);
                }
                else {
                    // at the end call response end
                    state.fnResponseEndCallback();
                    // not CalystoWebServiceResponse, but it is json object
                    state.fnReturnValueCallback(state.responseContainer || state.errorText);
                }
            }
            WebService.ProcessResponse = ProcessResponse;
            function AjaxResponseReceivedHandler(wclient, state1) {
                if (wclient.xhr.status == 0) {
                    // browser disconnected or aborted request, do nothing
                    state1.fnResponseEndCallback();
                    return;
                }
                let loc1 = wclient.xhr.getResponseHeader("location");
                if (loc1) {
                    location.assign(loc1);
                    return;
                }
                var state = CreateFullStateObj(wclient, state1);
                if (state.isErrorStatus) {
                    state.errorText = "Ajax response error #2 - error status received";
                    state.errorDescription = "xhr.status: " + wclient.xhr.status
                        + "\r\nxhr.statusText: " + wclient.xhr.statusText
                        + "\r\nxhr.resposeText:\r\n";
                    var fnProcess11 = function () {
                        if (state.isHtml) {
                            state.errorHtml = state.respTxt;
                        }
                        else {
                            state.errorDescription += state.respTxt;
                        }
                        ProcessResponse(state);
                    };
                    if (state.respTxt) {
                        fnProcess11();
                    }
                    else if (state.arrayBuffer) {
                        state.respTxt = Calysto.Utility.Encoding.UTF8.GetString(new Uint8Array(state.arrayBuffer));
                        fnProcess11();
                    }
                    else if (state.blob) {
                        var rr = new FileReader();
                        rr.onload = function (res) {
                            state.respTxt = Calysto.Utility.Encoding.UTF8.GetString(new Uint8Array(res.currentTarget.result));
                            fnProcess11();
                        };
                        rr.readAsArrayBuffer(state.blob);
                    }
                }
                else if (state.arrayBuffer) {
                    ReadArrayBuffer(state, function () {
                        ProcessResponse(state);
                    });
                }
                else if (state.blob) {
                    var rr = new FileReader();
                    rr.onload = function (res) {
                        state.arrayBuffer = res.currentTarget.result;
                        ReadArrayBuffer(state, function () {
                            ProcessResponse(state);
                        });
                    };
                    rr.readAsArrayBuffer(state.blob);
                }
                else {
                    try {
                        if (state.isJson) {
                            state.responseContainer = Calysto.Json.Deserialize(state.respTxt);
                        }
                    }
                    catch (ex) {
                        state.errorText = "Ajax response error #1 - invalid JSON string";
                        state.errorDescription = ex + "\r\nRESPONSE:\r\n" + state.respTxt;
                    }
                    ProcessResponse(state);
                }
            }
            WebService.AjaxResponseReceivedHandler = AjaxResponseReceivedHandler;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="webinfrastructure.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            class WebAjaxServiceHelper {
                constructor(
                /**complete service namespace including C# class name*/
                namespace, 
                /**service url*/
                url) {
                    this.namespace = namespace;
                    this.vpath = Calysto.Utility.Encoding.Base64RndEncoder.DecodeBase64StringToString(url);
                    this.ns = Calysto.DataBinder.GetValue(window, namespace);
                    if (this.ns)
                        throw new Error("Ajax namespace is already registered: " + namespace);
                    // namespace has to be object {}
                    this.ns = {};
                    // methods must be placed into global namespace to be invokable from anywhere
                    Calysto.DataBinder.SetValue(window, namespace, this.ns);
                }
                RegisterAjaxMethod(settings) {
                    if (this.ns[settings.method])
                        throw new Error("Ajax method is already registered: " + settings.method);
                    let _safeThis = this;
                    let ajaxMethod = function ( /*arguments*/) {
                        let funcSendArgs = arguments;
                        let servclient = new WebService.AjaxServiceClientWithReturn();
                        if (settings.reque && !WebService.IsTriggeredByUserAction()) {
                            return servclient; // da ne baca exception na chain metode koje se invokaju kasnije
                        }
                        // *************************************************
                        // if comes here, all verifications went well
                        // *************************************************
                        // get service method parameters: [argVal0, argVal1, argVal2...] or strongParams: {arg0: argVal0, arg1: argVal1, ...}
                        let jsObject = WebService.CreateArgsObj(settings.method, funcSendArgs, settings.argNames || []);
                        let isAbortRequested = false;
                        servclient.OnAbort(msg => {
                            isAbortRequested = true;
                        });
                        ////let useSocketWebClient = !!settings.ajaxSocket;
                        ////useSocketWebClient = true; // for debuging with web socket
                        // *************************************************
                        // common code
                        // *************************************************
                        // add OnEndResponse event last to be invoked at the end
                        // IMPORTANT: OnEndResponse has to be invoked at the end, alfter ResponseReceivedHandler which manipulates html
                        // OnEndResponse is used for hiding loading mask and for post processing
                        // since blob response is decoded async, we have to call async OnEndResponse at the end:
                        let isInvokedOnce = false;
                        /** hide loading spinner */
                        let fnResponseEndCallback = function () {
                            if (isInvokedOnce)
                                return; // osigurac da se izvrsi samo jednom;
                            isInvokedOnce = true;
                            // hide loading mask at the end
                            if (!settings.silent)
                                Calysto.Page.OnEndResponse.Invoke(f => f());
                            servclient.OnEnd.Invoke();
                        };
                        /** show loading spinner if not silent request */
                        let fnRequestStart = function () {
                            // show loading progress or spinner
                            if (!settings.silent)
                                Calysto.Page.OnBeginRequest.Invoke(f => f());
                        };
                        let fnReturnValueCallback = (value) => servclient.OnSuccess.Invoke(f => f(value));
                        let fnResponseContainerCallback = (container) => servclient.OnResponse.Invoke(f => f(container));
                        let fnErrorCallback = (errMsg, errDetails, isServerError) => {
                            if (servclient.OnError.Any()) {
                                servclient.OnError.Invoke(f => f(errMsg));
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    throw new Error(errMsg).AppendErrorDetails(errDetails, isServerError);
                                //#endif
                            }
                            else {
                                throw new Error(errMsg).AppendErrorDetails(errDetails, isServerError);
                            }
                        };
                        // *************************************************
                        // specific code per web client
                        // *************************************************
                        // code branching depending if webclient or socketwebclient is required
                        if (isAbortRequested) {
                            // nothing
                        }
                        else {
                            // we have to serialize async to serialize Blobs
                            Calysto.Json.BinaryFrame.SerializeAsync(jsObject, (binaryFrame) => {
                                if (Calysto.Core.IsDebugDefined) {
                                    WebService.Log({
                                        AJAX_SEND: binaryFrame.Json,
                                        BLOBS: binaryFrame.Blobs,
                                        method: settings.method + "(" + (settings.argNames || []).join(", ") + ")",
                                        jsObject: jsObject
                                    });
                                }
                                if (isAbortRequested)
                                    return;
                                let wclient = new Calysto.Net.WebClient("");
                                servclient.OnAbort(msg => wclient.Abort());
                                let url = WebService.CreateUrl(_safeThis.vpath, settings);
                                if (settings.post || binaryFrame.Blobs.length > 0 || binaryFrame.Json.length > 1000) {
                                    url = url.replace("__calysto_json_arg__", "");
                                    wclient.AddRequestHeader(Calysto.Constants.WsjsHeaderConstants.XTypeHeaderKey, Calysto.Constants.WsjsHeaderConstants.XTypeHeaderBinaryFrameValue);
                                    let blob1 = binaryFrame.ToBinaryData();
                                    if (blob1 && blob1.size > 0) {
                                        wclient.UploadData(blob1);
                                    }
                                    else {
                                        throw Error("Invalid blob, can not continue.");
                                    }
                                }
                                else {
                                    // use base64 instead of escaping, this way we may send anything, including <>?%^&$# etc.
                                    let enc = Calysto.Utility.Encoding.Base64RndEncoder.EncodeToBase64String(binaryFrame.Json);
                                    url = url.replace("__calysto_json_arg__", "&" + Calysto.Constants.CalystoAjaxHandlerConstants.AjaxGetParamName + "=" + enc);
                                }
                                wclient.url = url;
                                wclient.timeoutMs = settings.timeoutMs || wclient.timeoutMs; // timeout may be set in .cs using CalystoWebMethod(Timeout=...)
                                wclient.AddRequestHeader(Calysto.Constants.WsjsHeaderConstants.XAjaxHeaderKey, Calysto.Constants.WsjsHeaderConstants.XAjaxHeaderValue);
                                // we're always expecting blob, so there is no need to set anything on the server 
                                // arraybuffer is better because it may be sync converted into arra: new Uint8Array(arrayBuffer)
                                // blob has to be read async using FileReader... readAsArrayBuffer(blob)
                                wclient.responseType = typeof (ArrayBuffer) != "undefined" ? "arraybuffer" : "text"; // to work with IE <= 9
                                let fnWebClientLoadEnd = (sender, ev) => {
                                    if (ev.type == "timeout") {
                                        fnResponseEndCallback();
                                        fnErrorCallback("Ajax request timeout.");
                                        return;
                                    }
                                    // this function must not throw exception - all exceptions must be handled inside
                                    // we have to invoke Calysto.Page.OnEndResponse.Invoke(); later to hide loading mask
                                    // must send null if there is no listener, this way it will invoke throw new Exception(...) which will invoke Calysto.Page.OnUnhandledException(...)
                                    WebService.AjaxResponseReceivedHandler(wclient, {
                                        fnResponseContainerCallback,
                                        fnReturnValueCallback,
                                        fnErrorCallback,
                                        fnResponseEndCallback
                                    });
                                };
                                let fnSendProgressEv = (sender, ev, isUpload) => {
                                    let pp = {};
                                    pp.IsComputable = !!ev.lengthComputable;
                                    pp.IsUpload = !!isUpload;
                                    pp.Loaded = ev.loaded;
                                    pp.Total = ev.total;
                                    if (ev.total > 0) {
                                        pp.Percent = ev.loaded / ev.total * 100;
                                        if (pp.Percent > 100) {
                                            pp.Percent = 100;
                                        }
                                        // if there is no download length set, e.total = 0, so we have devide by zero
                                        servclient.OnProgress.Invoke(f => f(pp));
                                    }
                                };
                                let fnWebClientOnProgress = (sender, ev) => fnSendProgressEv(sender, ev, false);
                                let fnWebClientOnUploadProgress = (sender, ev) => fnSendProgressEv(sender, ev, true);
                                // on IE <= 8 doesn't work, it doesn't have events, it has readystate only
                                ////wclient.OnLoadEnd(fnWebClientLoadEnd); // doesn't work on IE <= 9
                                wclient.OnLoad(fnWebClientLoadEnd); // works on IE <= 9
                                wclient.OnError(fnWebClientLoadEnd);
                                wclient.OnTimeout(fnWebClientLoadEnd);
                                wclient.OnAbort(fnWebClientLoadEnd);
                                wclient.OnProgress(fnWebClientOnProgress);
                                wclient.OnUploadProgress(fnWebClientOnUploadProgress);
                                if (isAbortRequested)
                                    return;
                                fnRequestStart();
                                if (!wclient.async)
                                    throw new Error("Sync ajax request is not supported for web service");
                                // make delay for the rest of the code to finish assigning callbacks before invoking of the ajax request starts
                                //setTimeout(() => wclient.Start(), 1);
                                // since we have BoxValueObservable for OnError and OnSuccess, we don't need delay start any more
                                wclient.Start();
                            });
                        }
                        return servclient;
                    };
                    if (settings.method in _safeThis.ns) {
                        throw new Error("WebService error, method " + settings.method + " already exists in destination object.");
                    }
                    else {
                        _safeThis.ns[settings.method] = ajaxMethod;
                    }
                    return this;
                }
            }
            WebService.WebAjaxServiceHelper = WebAjaxServiceHelper;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="webinfrastructure.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            class WebSocketSessionHelper {
                constructor(
                /**complete service namespace including C# class name*/
                namespace, 
                /**service url*/
                url) {
                    this.namespace = namespace;
                    this.methods = [];
                    this.ns = Calysto.DataBinder.GetValue(window, namespace);
                    if (this.ns)
                        throw new Error("Socket session type is already registered: " + namespace);
                    this.vpath = Calysto.Utility.Encoding.Base64RndEncoder.DecodeBase64StringToString(url);
                    let _safeThis = this;
                    // namespace has to be function
                    // ns function is will be invoked as ctor when constructing new session instance
                    this.ns = function () {
                        let socket1 = new Calysto.Net.CalystoWebSocket(WebService.CreateUrl(_safeThis.vpath, { method: "$" }).replace("__calysto_json_arg__", ""));
                        let wss = new WebService.WebSocketSession({ method: "RequestReceived" }, socket1);
                        // register socket methods which may be used to send & receive data, the same as ajax methods
                        for (let sett of _safeThis.methods) {
                            wss[sett.method] = CreateSocketMethod(_safeThis, sett, wss, _safeThis.vpath);
                        }
                        return wss;
                    };
                    // methods must be placed into global namespace to be invocable from anywhere
                    Calysto.DataBinder.SetValue(window, namespace, this.ns);
                }
                RegisterSocketMethod(settings) {
                    this.methods.push(settings);
                    return this;
                }
            }
            WebService.WebSocketSessionHelper = WebSocketSessionHelper;
            function CreateSocketMethod(_safeThis, settings, wss, vpath) {
                return function ( /*arguments*/) {
                    let funcSendArgs = arguments;
                    if (settings.reque && !WebService.IsTriggeredByUserAction()) {
                        // don't send message
                        return null;
                    }
                    else {
                        // get service method parameters: [argVal0, argVal1, argVal2...] or strongParams: {arg0: argVal0, arg1: argVal1, ...}
                        let jsObject = WebService.CreateArgsObj(settings.method, funcSendArgs, settings.argNames || []);
                        let requestGuid = Calysto.Mathm.NewGuid();
                        let url = WebService.CreateUrl(vpath, settings).replace("__calysto_json_arg__", "");
                        let context = new WebService.AjaxServiceClientWithReturn();
                        wss.OnMethodReturn(requestGuid, context);
                        // jsObject treba zapakirati da se zna url, method name, typename..., sve sto se salje ajaxom inace
                        wss.Socket.Send({
                            Method: settings.method,
                            ReferenceGuid: requestGuid,
                            RequestObj: {
                                IsSocketWebClient: true,
                                AjaxQueryString: url,
                                AjaxArgs: jsObject
                            }
                        });
                        return context;
                    }
                };
            }
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
/// <reference path="infrastructure/webajaxservicehelper.ts" />
/// <reference path="infrastructure/websocketsessionhelper.ts" />
var Calysto;
(function (Calysto) {
    var Net;
    (function (Net) {
        var WebService;
        (function (WebService) {
            function CreateAjax(namespace, url) {
                return new WebService.WebAjaxServiceHelper(namespace, url);
            }
            WebService.CreateAjax = CreateAjax;
            function CreateSocket(namespace, url) {
                return new WebService.WebSocketSessionHelper(namespace, url);
            }
            WebService.CreateSocket = CreateSocket;
        })(WebService = Net.WebService || (Net.WebService = {}));
    })(Net = Calysto.Net || (Calysto.Net = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    class CallbackItem {
        ForRemoval() { return this.doCountExecutions && this.executedCount >= this.executionsMax; }
    }
    /**
     * TFunc example: (ime: string, age: number)=>void
     */
    class MulticastDelegate {
        constructor() {
            this._asFuncCached = new Map();
            this.items = [];
            this.onAddHandlers = [];
            this.onInvokeHandlers = [];
        }
        /**
         * Invode after every Add() invoked
         * @param func
         */
        OnAdd(func) {
            this.onAddHandlers.push(func);
            return this;
        }
        /**
         * Invoke after every Invoke() invocation
         * @param func
         */
        OnInvoke(func) {
            this.onInvokeHandlers.push(func);
            return this;
        }
        /**
         *
         * @param delegate
         * @param executionsMax maximum times to be executed, than ignore it
         */
        Add(delegate, executionsMax) {
            var item = new CallbackItem();
            item.delegate = delegate;
            item.executedCount = 0;
            if (executionsMax && executionsMax > 0) {
                item.doCountExecutions = true;
                item.executionsMax = executionsMax;
            }
            this.items.push(item);
            // invoke callback on add
            this.onAddHandlers.ForEach(f => f(delegate));
            return this;
        }
        /**
         * Remove items by delegate.
         * @param delegate
         */
        Remove(delegate) {
            let remove = this.items.Where(o => o.delegate == delegate);
            remove.ForEach(o => this.items.Remove(o));
            return this;
        }
        /**
         * Will invoke delegate only once.
         * @param delegate
         */
        AddOnce(delegate) {
            return this.Add(delegate, 1);
        }
        /**
         * Will invoke delegate executionsMax times.
         * @param executionsMax
         * @param delegate
         */
        AddCount(executionsMax, delegate) {
            return this.Add(delegate, executionsMax);
        }
        /**
         * invoke every delegate with parameters, e.g. f=>f(1,2,3);
         * @param action
         */
        Invoke(action) {
            for (let fn of this.onInvokeHandlers) {
                if (!action)
                    fn();
                else
                    action(fn);
            }
            let doRemove = false;
            for (let item of this.items) {
                if (item.ForRemoval()) {
                    doRemove = true;
                }
                else {
                    if (!action) // compatiblitiy if there is no argumets passed with .Add() or OnPageLoad(()=>{}), e.g. Calysto.Page.OnVersionExpired.Invoke()
                        item.delegate();
                    else
                        action(item.delegate);
                    item.executedCount++;
                }
            }
            if (doRemove) {
                this.items = this.items.Where(o => !o.ForRemoval());
            }
        }
        Any() {
            return this.items.Any();
        }
        Count() {
            return this.items.length;
        }
        Clear() {
            this.items.Clear();
            return this;
        }
        /**
         * encapsulate and return Add function, instead mc.Add(()=>{}), than we may left out .Add and use md(()=>{})
         * shorthand method md(()=>{}) returns owner instance, instead of MulticastDelegate instance
         * feature is used in ajax callbacks .OnSuccess().OnError()... () returns TOwner
         * encapsulated () returns owner
         * @returns owner
         */
        AsFunc(owner) {
            if (!this._asFuncCached.has(owner)) {
                var _safeThis = this;
                var fnAdd = function (fnDelgate) {
                    _safeThis.Add(fnDelgate);
                    return owner;
                };
                let prop1 = "MCD";
                Object.defineProperty(fnAdd, prop1, {
                    get: () => _safeThis,
                });
                this.CopyFunction(fnAdd, "Invoke");
                this.CopyFunction(fnAdd, "Any");
                this._asFuncCached.set(owner, fnAdd);
            }
            return this._asFuncCached.get(owner);
        }
        CopyFunction(dest, name) {
            dest[name] = this[name].BindContext(this);
        }
    }
    Calysto.MulticastDelegate = MulticastDelegate;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        let ReadyStateEnum;
        (function (ReadyStateEnum) {
            ReadyStateEnum[ReadyStateEnum["Loading"] = 2] = "Loading";
            ReadyStateEnum[ReadyStateEnum["Interactive"] = 3] = "Interactive";
            ReadyStateEnum[ReadyStateEnum["Complete"] = 4] = "Complete";
        })(ReadyStateEnum || (ReadyStateEnum = {}));
        class PendingItem {
        }
        var _items = [];
        //#region page events engine
        function ExecuteByEnumState(currState) {
            for (let item of _items) {
                if (!item.IsExecuted && item.MinReadyState <= currState) {
                    item.IsExecuted = true;
                    item.Func();
                }
            }
        }
        // IE and Safari requires additional delay on interactive to process window variables
        // this way we may test if dom is really ready
        let _timeoutid;
        let delay = window.FormData ? 10 : 200; // old browsers need more delay
        function CheckReadyState() {
            //////#if DEBUG
            ////if (Calysto.Core.IsDebugDefined)
            ////{
            ////	console.log("DOM not ready #1");
            ////}
            //////#endif
            if (window.document && document.body) {
                switch (document.readyState) {
                    case "loading":
                        // let's fall to the end and invoke new setTimeout(...)
                        break;
                    case "interactive":
                        {
                            // jQuery is testing !!document.body, but it is not ok since DOM is not ready yet
                            // we have to test readyState==interactive, interactive is set later when dom is ready
                            setTimeout(() => ExecuteByEnumState(ReadyStateEnum.Interactive), delay);
                            // let's fall to the end and invoke new setTimeout(...)
                            break;
                        }
                    case "complete":
                        {
                            // execute all
                            // IE and Safari requires additional delay on interactive to process window variables
                            setTimeout(() => ExecuteByEnumState(ReadyStateEnum.Complete), delay);
                            return; // must exits, don't set timeout any more
                        }
                }
            }
            // continue waiting for complete
            clearTimeout(_timeoutid); // to make sure there is only 1 alive timeout
            _timeoutid = setTimeout(CheckReadyState, delay);
        }
        function AddEvent(func, readyStateKind) {
            var item = new PendingItem();
            item.Func = func;
            item.MinReadyState = readyStateKind;
            _items.push(item);
            // must be sorted: to invoke callbacks in correct order if it comes to "complete" without coming to "interactive": "interactive", "complete"
            _items = _items.OrderBy(o => o.MinReadyState);
            CheckReadyState();
        }
        //#endregion
        // *******************************************************************
        Page.IsPageReloading = false;
        Page.IsVersionExpiredVisible = false;
        // *******************************************************************
        /**
         * Execute once at window.onload event (or document.readyState=='complete'). Includes clasic page load only.
         */
        Page.OnLoadComplete = new Calysto.MulticastDelegate().OnAdd((func) => {
            AddEvent(func, ReadyStateEnum.Complete);
        }).AsFunc(Calysto.Page);
        // *******************************************************************
        /**
            Executes on:
            1. Page unload by navigating to different url
            2. MS classic postback start
            3. MS ajax postback start
            4. Calysto ajax start request
         */
        Page.OnLoading = new Calysto.MulticastDelegate().AsFunc(Calysto.Page);
        // *******************************************************************
        // Begin request & End request
        var _aliveRequests = 0;
        /**
            Executes on:
            1. Page unload by navigating to different url
            2. MS classic postback start
            3. MS ajax postback start
            4. Calysto ajax start request
         */
        Page.OnBeginRequest = new Calysto.MulticastDelegate().Add(() => {
            if (++_aliveRequests == 1) {
                Page.OnLoading.Invoke(f => f(true));
            }
            ////console.log("begin _aliveRequests: " + _aliveRequests);
        }).AsFunc(Calysto.Page);
        /**
            Executes on:
            1. Page load or interactive
            2. MS classic postback end response
            3. MS ajax end response
            4. Calysto ajax end response
         */
        Page.OnEndResponse = new Calysto.MulticastDelegate().Add(() => {
            if (--_aliveRequests < 1) {
                _aliveRequests = 0;
                Page.OnLoading.Invoke(f => f(false));
            }
        }).AsFunc(Calysto.Page);
        // *******************************************************************
        /**
         * Execute once on document.readyState=='interactive' or page load. It is as soon as html is interactive, but all other resources may not be loaded (eg. images)
         * @param func
         */
        Page.OnInteractive = new Calysto.MulticastDelegate().OnAdd((func) => {
            AddEvent(func, ReadyStateEnum.Interactive);
        }).Add(() => {
            // register with MS Ajax EndRequest
            var _sys = window.Sys;
            if (typeof (_sys) != "undefined" && _sys.WebForms && _sys.WebForms.PageRequestManager) {
                _sys.WebForms.PageRequestManager.getInstance().add_beginRequest(() => Page.OnBeginRequest.Invoke(f => f()));
                _sys.WebForms.PageRequestManager.getInstance().add_endRequest(() => Page.OnEndResponse.Invoke(f => f()));
            }
            Page.OnEndResponse.Invoke(f => f());
        }).AsFunc(Calysto.Page);
        // *******************************************************************
        ///**
        // * MS ASP.NET or AJAX.NET Specific. Add func which will be executed before page MS postback submit or MS Ajax submit
        // */
        //export const OnBeforeSubmit = new Calysto.MulticastDelegate<() => void>().AsFunc(Calysto.Page);
        //// export as global function
        //Calysto.Core.ExportGlobal(Calysto.Page.OnBeforeSubmit.Invoke.BindContext(Calysto.Page.OnBeforeSubmit), "fnOnBeforeSubmitInvoke");
        /*
        insert to page html:
        must return true, otherwise MS postback will not work
        function WebForm_OnSubmit() {
            if(typeof(Calysto) != 'undefined'){return Calysto.Page.OnBeforeSubmit.Invoke();};
            return true;
        }
        */
        // ******************************************************************
        /**
         * Accepts function(errMsg){...} where errMsg is sent from the system.
         */
        Page.OnUnhandledException = new Calysto.MulticastDelegate().AsFunc(Calysto.Page);
        // *******************************************************************
        /**
         * Executes when JS engine version is outdated. This command is returned from server
         * errMsg is sent from the system
         * warning: must be MulticastDelegate because .Any() is used in EngineExpiredJS on server
         */
        Page.OnVersionExpired = new Calysto.MulticastDelegate().AsFunc(Calysto.Page);
        //else if (evName == "escKey")
        //{
        //	parts.unshift("keydown");
        //	cb11 = function (sender, ev)
        //	{
        //		if (Calysto.Event.IsEscKey(ev))
        //		{
        //			return callbackFunc.call(sender, sender, ev);
        //		}
        //	};
        //}
        var _isOnEscKeyEventAttached = false;
        /**
        * Accepts function(sender, ev){...} where sender is document
        */
        Page.OnEscKey = new Calysto.MulticastDelegate().OnAdd(() => {
            // init event
            if (!_isOnEscKeyEventAttached) {
                _isOnEscKeyEventAttached = true;
                Calysto.Event.Attach(document, "keydown", ev => {
                    if (Calysto.Event.IsEscKey(ev)) {
                        Page.OnEscKey.Invoke(f => f());
                    }
                });
            }
        }).AsFunc(Calysto.Page);
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        var Social;
        (function (Social) {
            var Facebook;
            (function (Facebook) {
                // https://developers.facebook.com/docs/graph-api/reference/user
                // https://developers.facebook.com/docs/facebook-login/permissions
                /* COMPLETE TEST:
                export function fbCompleteLogin1()
                {
                    // complete test
                    let promise2 = new Calysto.Page.Social.Facebook.FacebookPromise()
                        .Initialize("520024095463488")
                        .Login()
                        .LoadPermissions()
                        .LoadPicture()
                        .LoadProfile()
                        .Then((state, value) =>
                        {
                            console.log(value);
                            state.Success(value);
                        });
                }
                */
                function fbCreateTagLoaderOnce() {
                    (function (d, s, id) {
                        var localeStr = (Calysto.Globalization.CultureInfo.CurrentCulture.Name || "").replace("-", "_"); // hr-HR to hr_HR
                        var js;
                        var fjs = d.getElementsByTagName(s)[0];
                        if (d.getElementById(id)) {
                            return;
                        } // will not create tag if already exists
                        js = d.createElement(s);
                        js.id = id;
                        js.src = "//connect.facebook.net/" + (localeStr || "en_US") + "/sdk.js";
                        js.async = "async";
                        // fb locale: "en_US", "hr_HR", "sr_RS"
                        //js.src = "//connect.facebook.net/" + window.facebookLocaleStr + "/all.js#xfbml=1&appId=" + window.facebookAppId;
                        if (fjs && fjs.parentNode)
                            fjs.parentNode.insertBefore(js, fjs);
                    }(document, 'script', 'facebook-jssdk'));
                }
                function fbInitializeEngineAsync() {
                    return __awaiter(this, void 0, void 0, function* () {
                        return Calysto.Tasks.TaskUtility.RunAsync((state) => __awaiter(this, void 0, void 0, function* () {
                            state.Watchdog(15000);
                            state.OnError(err => state.NotifySuccess(null));
                            fbCreateTagLoaderOnce();
                            while (!state.IsCancelled) {
                                let _fbInstance = window["FB"];
                                if (_fbInstance && _fbInstance.init && _fbInstance.Event && _fbInstance.Event.subscribe) {
                                    state.NotifySuccess(_fbInstance);
                                    return;
                                }
                                yield Calysto.Tasks.TaskUtility.SleepAsync(100);
                            }
                        }));
                    });
                }
                function fbAssignEvents() {
                    let _fbInstance = window["FB"];
                    // listen for and handle auth.statusChange events
                    // This method will be called after the user login into facebook.
                    _fbInstance.Event.subscribe('auth.statusChange', (response) => {
                        // invoked eg. if customer is not logged in to facebook account and then he enters login data into popup window
                        // send callback to the server
                        //FacebookProvider.OnLoginResponse.Invoke(f => f(response));
                    });
                    // hook into the Event.subscribe to display the hidden content after the user likes the page
                    _fbInstance.Event.subscribe('edge.create', (response) => {
                        //console.log({ "edge.create": arguments });
                        //FacebookProvider.OnLikeResponse.Invoke(f => f());
                    });
                }
                class FacebookData {
                    constructor(_fbInstance) {
                        this._fbInstance = _fbInstance;
                    }
                    get FB() { return this._fbInstance; }
                }
                class FacebookPromise {
                    InitEngine() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync((state) => __awaiter(this, void 0, void 0, function* () {
                                let res = yield fbInitializeEngineAsync();
                                if (res) {
                                    this.Data = new FacebookData(res);
                                    state.NotifySuccess(true);
                                }
                                else {
                                    state.NotifySuccess(false);
                                }
                            }));
                        });
                    }
                    InitApp(facebookAppId) {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                if (this.Data.FB["__fbInitDone"] != facebookAppId) {
                                    this.Data.FB["__fbInitDone"] = facebookAppId;
                                    // if we invoke FB.init, after some time it looses settings, so it has to be invoked again
                                    this.Data.FB.init({
                                        appId: facebookAppId,
                                        xfbml: true,
                                        status: true,
                                        cookie: true,
                                        version: 'v4.0'
                                    });
                                }
                                state.NotifySuccess(true);
                            });
                        });
                    }
                    /**
                     * default scope: public_profile,email
                     * @param scope additional scope
                     */
                    Login(scope) {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                state.Watchdog(120000); // jer se moze cekati na popup prozoru
                                let scopes1 = (scope || "").split(',')
                                    .AsEnumerable()
                                    .Select(o => o.Trim())
                                    .Concat(["public_profile", "email"])
                                    .Where(o => !!o)
                                    .Distinct()
                                    .ToStringJoined(",");
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined) {
                                    console.log("fb#before-login");
                                }
                                //#endif
                                this.Data.FB.login(resp => {
                                    this.Data.StatusReponse = resp;
                                    if (resp.status == "connected") {
                                        //#if DEBUG
                                        if (Calysto.Core.IsDebugDefined)
                                            console.log("fb#login-success");
                                        //#endif
                                        state.NotifySuccess(true);
                                    }
                                    else {
                                        //#if DEBUG
                                        if (Calysto.Core.IsDebugDefined)
                                            console.log("fb#login-failed");
                                        //#endif
                                        this.Error = resp.status;
                                        state.NotifySuccess(false);
                                    }
                                }, {
                                    enable_profile_selector: true,
                                    return_scopes: true,
                                    scope: scopes1
                                });
                            });
                        });
                    }
                    LoadProfile() {
                        return __awaiter(this, void 0, void 0, function* () {
                            //#if DEBUG
                            if (Calysto.Core.IsDebugDefined)
                                console.log("fb#before-LoadProfile1");
                            //#endif
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    console.log("fb#before-LoadProfile2");
                                //#endif
                                try {
                                    this.Data.FB.api("/me", { fields: "id,name,gender,email,birthday,verified,picture,locale,link,first_name,last_name,age_range,hometown,photos" }, resp => {
                                        //#if DEBUG
                                        if (Calysto.Core.IsDebugDefined)
                                            console.log("fb#loaded-LoadProfile");
                                        //#endif
                                        this.Data.Profile = resp;
                                        state.NotifySuccess(true);
                                    });
                                }
                                catch (e1) {
                                    this.Error = e1;
                                    state.NotifySuccess(false);
                                }
                            });
                        });
                    }
                    LoadPicture() {
                        return __awaiter(this, void 0, void 0, function* () {
                            //#if DEBUG
                            if (Calysto.Core.IsDebugDefined)
                                console.log("fb#before-LoadPicture1");
                            //#endif
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    console.log("fb#before-LoadPicture2");
                                //#endif
                                try {
                                    // moze se dohvatiti sa osnovnim permissionima: public_profile,email
                                    this.Data.FB.api("/me/picture", { redirect: false, height: 300, width: 300 }, resp => {
                                        this.Data.Picture = resp;
                                        state.NotifySuccess(true);
                                    });
                                }
                                catch (e1) {
                                    this.Error = e1;
                                    state.NotifySuccess(false);
                                }
                            });
                        });
                    }
                    LoadPermissions() {
                        return __awaiter(this, void 0, void 0, function* () {
                            //#if DEBUG
                            if (Calysto.Core.IsDebugDefined)
                                console.log("fb#before-LoadPermissions1");
                            //#endif
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    console.log("fb#before-LoadPermissions2");
                                //#endif
                                try {
                                    // moze se dohvatiti sa osnovnim permissionima: public_profile,email
                                    this.Data.FB.api("/me/permissions", resp => {
                                        this.Data.Permissions = resp;
                                        state.NotifySuccess(true);
                                    });
                                }
                                catch (e1) {
                                    this.Error = e1;
                                    state.NotifySuccess(false);
                                }
                            });
                        });
                    }
                }
                Facebook.FacebookPromise = FacebookPromise;
            })(Facebook = Social.Facebook || (Social.Facebook = {}));
        })(Social = Page.Social || (Page.Social = {}));
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        var Social;
        (function (Social) {
            var Google;
            (function (Google) {
                // https://console.cloud.google.com/home/dashboard
                // https://console.cloud.google.com/apis/credentials
                // https://developers.google.com/identity/sign-in/web/reference
                /*	COMPLETE TEST:
                export function GoogleCompleteLogin1()
                {
                    let promise1 = new Calysto.Page.Social.Google.GooglePromise()
                        .Initialize()
                        .LoadAuth2("AIzaSyCRzDlVMG8_EHhIjwyqDApaLWKMBjRGrRM", "658661145263-qah8cdjjb5idbo2ovt90msr3nsr4kvh1.apps.googleusercontent.com")
                        .Login()
                        .Then((state, value) =>
                        {
                            console.log("Google final:");
                            console.log(value);
            
                        }, (state, error) =>
                        {
                            console.log(error);
                        });
                }
                */
                function fnCreateTagLoaderOnce() {
                    (function (d, s, id) {
                        var js;
                        var fjs = d.getElementsByTagName(s)[0];
                        if (d.getElementById(id)) {
                            return;
                        } // will not create tag if already exists
                        js = d.createElement(s);
                        js.id = id;
                        js.src = "https://apis.google.com/js/platform.js";
                        js.async = "async";
                        if (fjs && fjs.parentNode)
                            fjs.parentNode.insertBefore(js, fjs);
                    }(document, 'script', 'google-platform'));
                }
                function fnInitializeEngineAsync() {
                    return __awaiter(this, void 0, void 0, function* () {
                        return Calysto.Tasks.TaskUtility.RunAsync((state) => __awaiter(this, void 0, void 0, function* () {
                            state.Watchdog(15000);
                            state.OnError(err => state.NotifySuccess(false));
                            fnCreateTagLoaderOnce();
                            while (!state.IsCancelled) {
                                let _gapi = window["gapi"];
                                if (_gapi && _gapi.load) {
                                    state.NotifySuccess(true);
                                    return;
                                }
                                yield Calysto.Tasks.TaskUtility.SleepAsync(100);
                            }
                        }));
                    });
                }
                function fnExtractBasicProfileData(obj) {
                    return ({
                        Id: obj.getId(),
                        Name: obj.getName(),
                        GivenName: obj.getGivenName(),
                        FamilyName: obj.getFamilyName(),
                        ImageUrl: obj.getImageUrl(),
                        Email: obj.getEmail()
                    });
                }
                class GoogleData {
                }
                let _defaultScope = "https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/plus.me";
                function fnCreateScopes(scope) {
                    if (scope)
                        return _defaultScope + " " + scope;
                    else
                        return _defaultScope;
                }
                class GooglePromise {
                    InitEngine() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync((state) => __awaiter(this, void 0, void 0, function* () {
                                state.OnError(err => state.NotifySuccess(false));
                                let res = yield fnInitializeEngineAsync();
                                if (res) {
                                    this.Data = new GoogleData();
                                    state.NotifySuccess(true);
                                }
                                else {
                                    state.NotifySuccess(false);
                                }
                            }));
                        });
                    }
                    InitApp(apiKey, clientId, scope) {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                state.Watchdog(15000);
                                state.OnError(err => state.NotifySuccess(false));
                                if (window["gapi"] && gapi.load && gapi.auth2 && gapi.auth2.init) {
                                    state.NotifySuccess(true);
                                    return;
                                }
                                // Load "client" & "auth2" libraries
                                gapi.load('client:auth2', {
                                    callback: function () {
                                        // Initialize client library
                                        // clientId & scope is provided => automatically initializes auth2 library
                                        gapi.client.init({
                                            apiKey: apiKey,
                                            clientId: clientId,
                                            scope: fnCreateScopes(scope)
                                        }).then(
                                        // On success
                                        function (success) {
                                            //#if DEBUG
                                            if (Calysto.Core.IsDebugDefined)
                                                console.log({ "google#success_LoadAuth2": success });
                                            //#endif
                                            state.NotifySuccess(true);
                                        }, 
                                        // On error
                                        function (error) {
                                            //#if DEBUG
                                            if (Calysto.Core.IsDebugDefined)
                                                console.log(error);
                                            //#endif
                                            state.NotifyError();
                                        });
                                    },
                                    onerror: function (error) {
                                        // Failed to load libraries
                                        state.NotifyError(error);
                                    }
                                });
                            });
                        });
                    }
                    Login() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                state.Watchdog(120000); // jer se moze cekati na popup prozoru
                                state.OnError(err => state.NotifySuccess(false));
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    console.log({ "google#Login": this.Data });
                                //#endif
                                gapi.auth2.getAuthInstance().signIn().then((success) => {
                                    //#if DEBUG
                                    if (Calysto.Core.IsDebugDefined)
                                        console.log({ "google#success-Login": success });
                                    //#endif
                                    this.Data.GoogleUser = success;
                                    this.Data.Data = {
                                        AuthResponse: success.getAuthResponse(),
                                        GrantedScopes: success.getGrantedScopes(),
                                        isSignedIn: success.isSignedIn(),
                                        UserId: success.getId()
                                    };
                                    state.NotifySuccess(true);
                                    //console.log(success.getBasicProfile());
                                    //console.log(gapi.auth2.getAuthInstance().currentUser.get().getBasicProfile());
                                }, (error) => {
                                    state.NotifyError(error);
                                });
                            });
                        });
                    }
                    LoadProfile() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return Calysto.Tasks.TaskUtility.RunAsync(state => {
                                state.Watchdog(15000);
                                state.OnError(err => state.NotifySuccess(false));
                                //#if DEBUG
                                if (Calysto.Core.IsDebugDefined)
                                    console.log({ "google#LoadProfile": this.Data });
                                //#endif
                                this.Data.BasicProfile = fnExtractBasicProfileData(this.Data.GoogleUser.getBasicProfile());
                                state.NotifySuccess(true);
                            });
                        });
                    }
                }
                Google.GooglePromise = GooglePromise;
            })(Google = Social.Google || (Social.Google = {}));
        })(Social = Page.Social || (Page.Social = {}));
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        var Google;
        (function (Google) {
            class AnalyticsService {
                constructor(trackingId) {
                    this.trackingId = trackingId;
                    this.gtag('js', new Date());
                    Calysto.ScriptLoader.LoadJSFile("https://www.googletagmanager.com/gtag/js?id=" + trackingId, true);
                }
                // SPA analytics:
                // https://developers.google.com/analytics/devguides/collection/gtagjs/custom-dims-mets
                // https://developers.google.com/analytics/devguides/collection/gtagjs/single-page-applications
                // original tag:
                //<%--eRegistar.hr global site tag (gtag.js) - Google Analytics -- %>
                //<script async="async" src= "https://www.googletagmanager.com/gtag/js?id=UA-110466768-1" > </script>
                //<script>
                //		window.dataLayer = window.dataLayer || [];
                //		function gtag() { dataLayer.push(arguments); }
                //		gtag('js', new Date());
                //		gtag('config', 'UA-110466768-1');
                //</script>
                gtag(...args) {
                    let dataLayer = window["dataLayer"] = window["dataLayer"] || [];
                    dataLayer.push(arguments);
                }
                /**
                 * Hit ajax page view.
                 * @param pagePath
                 *		eg. /new-page.html
                 *		if not set, will hit current page
                 */
                HitPageView(pagePath) {
                    // gtag('config', 'GA_TRACKING_ID', {'page_path': '/new-page.html'});
                    if (pagePath)
                        this.gtag('config', this.trackingId, { 'page_path': pagePath });
                    else
                        this.gtag('config', this.trackingId); // hit current page
                    return this;
                }
            }
            Google.AnalyticsService = AnalyticsService;
        })(Google = Page.Google || (Page.Google = {}));
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        var Preloader;
        (function (Preloader) {
            let _isLoading = false;
            let _delayMs = 300;
            let _isEnabled = false;
            let _timer;
            let _hasPageEvent = false;
            function Enable(delayMs = 300) {
                /// <summary>
                /// Create preloader event and start monitoring for ajax start/stop
                /// </summary>
                /// <param name="delayMs" type="Integer" optional="true">default is 300ms, if not provided</param>
                _delayMs = arguments.length == 0 ? 300 : delayMs;
                _isEnabled = true;
                if (!_timer) {
                    _timer = new Calysto.Timer().OnTimeout(() => {
                        // add class to html element
                        if (!_isLoading) {
                            Calysto.Utility.Dom.RemoveClass(document.documentElement, "calystoAjaxLoading");
                        }
                        else {
                            Calysto.Utility.Dom.AddClass(document.documentElement, "calystoAjaxLoading");
                        }
                    });
                }
                if (!_hasPageEvent) {
                    _hasPageEvent = true;
                    Calysto.Page.OnLoading((isLoading) => {
                        _isLoading = isLoading;
                        if (_isEnabled) {
                            _timer.Abort().Start(_isLoading ? _delayMs : 1);
                        }
                    });
                }
            }
            Preloader.Enable = Enable;
            function Disable() {
                /// <summary>
                /// Stop monitoring ajax start/stop
                /// </summary>
                if (_timer) {
                    _isEnabled = false;
                    _isLoading = false; // remove class from body
                    _timer.Abort().Start(1);
                }
            }
            Preloader.Disable = Disable;
            ;
        })(Preloader = Page.Preloader || (Page.Preloader = {}));
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Page;
    (function (Page) {
        var Diagnostic;
        (function (Diagnostic) {
            /***********************************************************/
            // has to be set on server, ony if ElmahLog="true"
            var ServerUrl = (Calysto.Core.Constants.ServerDiagnosticUrl || "").replace("=", "://");
            /***********************************************************/
            function sendElmahLog(errMsg, errDetails) {
                if (!errMsg)
                    return;
                // Mozilla/5.0 (iPhone; CPU iPhone OS 10_2 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) GSA/22.0.141836113 Mobile/14C92 Safari/600.1.4
                // Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) GSA/22.0.141836113 Mobile/14D27 Safari/600.1.4
                // Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_2 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/58.0.3029.113 Mobile/14F89 Safari/602.1
                // neki agenti imaju interne greske pa da nam ne pune elmah, blacklistamo ih
                // SecurityError (DOM Exception 18): Blocked a frame with origin "https://www.somepage.com" from accessing a frame with origin "https://acdn.adnxs.com". Protocols, domains, and ports must match.
                // block next errors on iPhone to prevent from writing to Elmah:
                if (errMsg.indexOf("Blocked a frame with origin") >= 0) {
                    return;
                }
                else if (errMsg.indexOf("null is not an object (evaluating 'elt.parentNode')") >= 0) {
                    return;
                }
                var xmlhttp = Calysto.Net.WebClient.GetXMLHttpRequest(ServerUrl);
                // open request
                // since setRequestHeader is not supported on IE8 & IE9 XDomainRequest, it will throw exception here, that is why we have try-catch
                xmlhttp.open("POST", ServerUrl, true);
                xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                // custom header can't be set on crossdomain request
                xmlhttp.setRequestHeader(Calysto.Constants.WsjsHeaderConstants.XAjaxHeaderKey, Calysto.Constants.WsjsHeaderConstants.XExceptionHeaderValue);
                var pageHtml = (document.documentElement.innerHTML || "").substr(0, 100);
                var detailsFormated = errDetails; //// + "\r\n\r\n<--- page html start --->\r\n" + pageHtml + "\r\n...\r\n<--- page html end --->";
                var inputValues = "";
                try {
                    // we can't use Calysto.Forms.Serialize since not all elements have attributes calysto-id or name or id
                    var items22 = $$calysto(document.documentElement).Query("//input, //select, //textarea").Select((el) => ({
                        tagName: el.tagName,
                        type: el.type,
                        calystoId: el.getAttribute(Calysto.AttrName.CalystoId),
                        id: el.id,
                        name: el.name,
                        value: el.value
                    })).ToArray();
                    inputValues = Calysto.Json.Serialize(items22, 50);
                }
                catch (ex1) {
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        console.error(ex1);
                    }
                    //#endif
                    inputValues = "*error, values can no be serialized*";
                }
                // since all system objects return hasOwnProperty(name) == false, it can not be serialized, properties have to be cloned to new object first
                var jsitems = { location: {}, screen: {}, navigator: {} };
                Calysto.Collections.ForEachProperties(location, function (name, value, index) { try {
                    jsitems.location[name] = value;
                }
                catch (e) { } });
                Calysto.Collections.ForEachProperties(screen, function (name, value, index) { try {
                    jsitems.screen[name] = value;
                }
                catch (e) { } });
                Calysto.Collections.ForEachProperties(navigator, function (name, value, index) { try {
                    jsitems.navigator[name] = value;
                }
                catch (e) { } });
                var obj = {
                    calystoExObj: true,
                    errMsg: errMsg,
                    errDetails: detailsFormated,
                    url: window.location.href,
                    cookie: document.cookie,
                    userAgent: navigator.userAgent,
                    location: Calysto.Json.Serialize(jsitems.location),
                    screen: Calysto.Json.Serialize(jsitems.screen),
                    navigator: Calysto.Json.Serialize(jsitems.navigator),
                    inputValues: inputValues
                };
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log(JSON.stringify(obj));
                }
                //#endif
                var json = Calysto.Json.Serialize(obj);
                var bb = Calysto.Utility.Encoding.Base64RndEncoder.EncodeToBase64String(json);
                //send request
                // request is handled on server in CalystoElmahErrorHandler.cs
                xmlhttp.send(bb);
            }
            function ElmahLog(errMsg, errDetails) {
                /// <summary>
                /// Send exeption to server.
                /// </summary>
                /// <param name="elmahTitle" type="string"></param>
                /// <param name="elmahDescription" type="string"></param>
                try {
                    if (ServerUrl) {
                        sendElmahLog(errMsg, errDetails);
                    }
                }
                catch (e1) {
                    // slanje nije uspjelo
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        try {
                            console.error(e1);
                        }
                        catch (e2) { }
                    }
                    //#endif
                }
            }
            Diagnostic.ElmahLog = ElmahLog;
            ;
            ;
            function fnFormatErrorEvent(ev) {
                /// <summary>
                /// Format from ErrorEvent.
                /// </summary>
                /// <param name="ev" type="ErrorEvent"></param>
                // ev.error.CalystoException kreira se sa new Error().AppendErrorDetails({p:10}) u Error.js extenziji
                let res = {};
                try {
                    var calystoEx = ev && ev.error && ev.error.CalystoException ? ev.error.CalystoException : undefined;
                    res.IsServerError = !!(calystoEx && calystoEx.IsServerError); // true: exception thrown on server
                    var details = [];
                    if (res.IsServerError) {
                        res.Message = calystoEx.Message;
                        details.push(calystoEx.Details);
                        res.HtmlDetails = calystoEx.HtmlDetails || "";
                    }
                    else if (ev = (ev || window.event)) {
                        res.Message = ev.message;
                        res.FileName = ev.filename;
                        res.LineNo = ev.lineno;
                        res.ColNo = ev.colno;
                        // execute code in try-catch to prevent throwing exception from here, it would create endless loop
                        if (ev.error) {
                            res.Message = ev.error.message || ev.message; // this is message only
                            if (ev.message && res.Message != ev.message)
                                details.push(ev.message); // this is message prefixed with type
                            if (ev.error.description && ev.error.description != res.Message)
                                details.push(ev.error.description);
                        }
                        details.push("filename: " + ev.filename);
                        details.push("lineno: " + ev.lineno);
                        if (ev.colno != null)
                            details.push("colno: " + ev.colno);
                        if (ev.error) {
                            res.Stack = (ev.error || {}).stack;
                            if (res.Stack) {
                                details.push("stack:\r\n" + res.Stack);
                            }
                            if (ev.error && calystoEx) {
                                details.push("-----------------------------");
                                details.push("CalystoException.Message:");
                                details.push(calystoEx.Message);
                                details.push("CalystoException.Details:");
                                details.push(calystoEx.Details);
                                res.HtmlDetails = calystoEx.HtmlDetails || "";
                            }
                        }
                    }
                    res.Details = details.join("\r\n");
                }
                catch (e1) { }
                return res;
            }
            function errorHandler(ev) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="ev" type="ErrorEvent"></param>
                try {
                    var err = fnFormatErrorEvent(ev);
                    if (!err || !err.Message) {
                        // this err has no description, usually it is thrown if some google script is not loaded or is blocked by adblocker
                        // don't show anything
                        return;
                    }
                    // if there is no FileName or no Stack, exception is useless, so don't write it to Elmah
                    if (err && !err.IsServerError && err.FileName && err.Message && err.Stack) {
                        try {
                            // server error is thrown on server and written to Elmah
                            // write to elmah
                            Calysto.Page.Diagnostic.ElmahLog(err.Message, err.Details);
                        }
                        catch (e6) { }
                    }
                    try {
                        // show error message to the user
                        Calysto.Page.OnUnhandledException.Invoke(f => f(err.Message));
                    }
                    catch (e5) { }
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        try {
                            // if <pre> element is not supported, we need <br/> instead of \r\n, like IE <= 8
                            // <pre> element knows that <br/> has to be show as \r\n
                            var dialog = Calysto.Dialog.CreateError(err.Message + "\r\n\r\n" + err.Details, "DEBUG MODE - " + (err.IsServerError ? "Server Exception" : "Unhandled JS Exception")).Show();
                            if (err.HtmlDetails) {
                                dialog.AppendContent(err.HtmlDetails);
                            }
                        }
                        catch (e5) { }
                    }
                    //#endif
                }
                catch (e1) {
                }
            }
            ;
            if (typeof (ErrorEvent) != "undefined") {
                if (window.addEventListener) {
                    window.addEventListener("error", errorHandler, true);
                }
                else if (window.attachEvent) {
                    window.attachEvent("on" + "error", errorHandler, true);
                }
            }
            else {
                // ovo je IE <= 9
                // Safari win 5.x
                window.onerror = function (msg, file, line, column) {
                    errorHandler({
                        // column number
                        colno: column || null,
                        // line number
                        lineno: line,
                        // source filename
                        filename: file,
                        // error message
                        message: msg,
                        // error type
                        type: "error"
                    });
                };
            }
        })(Diagnostic = Page.Diagnostic || (Page.Diagnostic = {}));
    })(Page = Calysto.Page || (Calysto.Page = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var AjaxHistory;
    (function (AjaxHistory) {
        let _eventsDone = false;
        function EnsureEvents() {
            if (!_eventsDone) {
                _eventsDone = true;
                Calysto.Event.Attach(window, "popstate", (ev) => RestoreState(ev.state));
            }
        }
        /**
         * Create state restoration command for current url.
         * @param stateArray
         */
        function ReplaceHistoryState(stateArray) {
            var stateObj = {
                isCalystoState: true,
                url: window.location.href,
                pathname: window.location.pathname,
                search: window.location.search,
                hash: window.location.hash,
                title: document.title,
                stateArray: stateArray
            };
            if (stateObj && stateObj.isCalystoState && window.history.replaceState) {
                EnsureEvents();
                window.history.replaceState(stateObj, stateObj.title, stateObj.url);
            }
        }
        function RestoreState(stateObj) {
            if (stateObj && stateObj.isCalystoState && stateObj.stateArray && window.history.replaceState) {
                document.title = stateObj.title;
                for (let n = 0; n < stateObj.stateArray.length; n++) {
                    let obj = stateObj.stateArray[n];
                    if (obj.selector) {
                        $$calysto(obj.selector).SetInnerHtml(obj.html);
                    }
                }
            }
        }
        /**
         * Create new history state by changing url hash.
         */
        function CreateNewRandomHash() {
            // firefox will register new url only if property hash is explicitly set
            window.location.hash = "!x" + Date.now() + "-" + Math.floor(Math.random() * 1000000);
        }
        ;
        /**
         * Will save current state, then modify with new values and save new state, so the back-forward will work.
         * @param stateArray [{selector:.., html:..}, {selector:.., html:..}...]
         */
        function PushState(stateArray) {
            // save current state connected with current url
            let currentArr = [];
            for (let n = 0; n < stateArray.length; n++) {
                let sel1 = stateArray[n].selector;
                if (!sel1)
                    throw new Error("Error in AjaxHistory, selector is null");
                currentArr.push({
                    selector: sel1,
                    html: $$calysto(sel1).SelectInnerHtml().FirstOrDefault(),
                });
            }
            ReplaceHistoryState(currentArr);
            // update content
            for (let n = 0; n < stateArray.length; n++) {
                // update page content
                $$calysto(stateArray[n].selector).SetInnerHtml(stateArray[n].html);
            }
            // change hash, new url will be connected with new state
            CreateNewRandomHash();
            // save new current state for new url (this is required only go forward is pushed after go back is pushed)
            let newArr = [];
            for (let n = 0; n < stateArray.length; n++) {
                let sel1 = stateArray[n].selector;
                newArr.push({
                    selector: sel1,
                    html: $$calysto(sel1).SelectInnerHtml().FirstOrDefault(),
                });
            }
            ReplaceHistoryState(newArr);
        }
        AjaxHistory.PushState = PushState;
    })(AjaxHistory = Calysto.AjaxHistory || (Calysto.AjaxHistory = {}));
})(Calysto || (Calysto = {}));
/*
 * example of usage:

    // create instance with UID:
    var ppp = new Calysto.PostMessage("win1");

    // register method inside of iframe or main window:
    ppp.RegisterMethod("GetWindowTime", function(val1, ev){
        // acctual handler function
    });

    // invoke method from any other iframe or main window, val1 is passed as parameter
    p1.InvokeMethod("destinationUID", "GetWindowTime", val1, function(val3, ev){
        // optional response handler, val3 is return value from function GetWindowTime(val1);
    });
*/
var Calysto;
(function (Calysto) {
    function GenerateUID(prefix) {
        return (prefix || "uid") + (Math.random() + "").substr(2) + Date.now();
    }
    // MSIE 9,8,7 allows to send string only
    function EncodeDataObj(obj) {
        return Calysto.Json.Serialize(obj);
    }
    function DecodeDataObj(obj) {
        try {
            return Calysto.Json.Deserialize(obj);
        }
        catch (e) {
            return null;
        }
    }
    const __EchoTestMethod = "__EchoTestMethod";
    // for compatibility with other code, everything has to be inside class which has to be instantinated
    class PostMessage {
        constructor(UID) {
            this._listenersArr = [];
            this._funcBag = {};
            // create PostMessage instance unique id
            this._uniqueUID = UID || GenerateUID("uid");
            // register echo method
            this._funcBag[__EchoTestMethod] = (msg) => "received: " + msg;
            // parent windows should be added as listeners
            // iframes should not be added, so communication has be initialized from iframe to parent
            this.AddDistinctListener(window.parent);
            this.AddDistinctListener(window.opener);
            Calysto.Event.Attach(window, "message", ev => this.HandleMessageEvent(ev));
        }
        AddDistinctListener(obj) {
            // can not test obj._postMsgUID if domains are different
            if (!obj || obj == window)
                return; // if current window, it can not be listener for itself
            for (var n1 = 0; n1 < this._listenersArr.length; n1++) {
                if (this._listenersArr[n1] == obj)
                    return;
            }
            // we don't have that obj in array yet
            this._listenersArr.push(obj);
        }
        EncapsulateFunc(funcRef) {
            /// <summary>
            /// If funcRef defined, add funcRef to _funcBag and return funcUID, else return null.
            /// </summary>
            /// <param name="funcRef" type="Function"></param>
            if (funcRef) {
                var cnt = 0;
                var funcUid;
                while (cnt++ < 50 && (!(funcUid = GenerateUID("fn")) || this._funcBag[funcUid])) {
                    // if uid already exists, generate new UID, try up to 50 times
                }
                this._funcBag[funcUid] = funcRef;
                return funcUid;
            }
            return null;
        }
        /**
         * Register function in postmessage instance.
         * @param {string} funcName Name of the function.
         * @param {(sentValue} funcRef Acctual function which will receive and process the sentValue. Function returns TReturn at the end.
         * @param {function} ev
         * @returns
         */
        RegisterMethod(funcName, funcRef) {
            /// <summary>
            /// Register method inside of current window which may be invoked from any other iframe.
            /// </summary>
            /// <param name="funcName" type="String">Function name.</param>
            /// <param name="funcRef" type="Function">
            ///		<para>function(sentValue, event, this){....}</para>
            ///		<para>this inside of function is current PostMessage instance</para>
            ///		<para>event is current event {sender:..., origin:..., data:...}</para>
            ///		<para>sentValue is sent as argument parameter in method this.InvokeMethod(....)</para>
            /// </param>
            if (typeof (funcName) != "string") {
                throw Error("PostMessage.RegisterMethod argument funcName is not string");
            }
            if (typeof (funcRef) != "function") {
                throw Error("PostMessage.RegisterMethod argument funcRef is not function");
            }
            if (this._funcBag[funcName]) {
                throw new Error("Method is already registerd in PostMessage.RegisterMethod: " + funcName);
            }
            this._funcBag[funcName] = funcRef;
            return this;
        }
        InvokeMethod(destinationUID, funcName, sendValue, callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="destinationUID" type="String">UID string or * for all</param>
            /// <param name="funcName" type="String">Function name to be executed on destinationUID and pass arg as parameter to the function.</param>
            /// <param name="arg" type="Object" optional="true">object to be passed to invoking method as argument</param>
            /// <param name="callbackFunc" type="Function" optional="true">
            ///		<para>function(value, event, this){....}</para>
            ///		<para>function to be invoked on response received, handles object returned from invoked method using return (value);</para>
            ///		<para>this inside of function is current PostMessage instance</para>
            ///		<para>event is current event {sender:..., origin:..., data:...}</para>
            ///		<para>value is sent as argument parameter in method this.InvokeMethod(....)</para>
            /// </param>
            var tt = [destinationUID, funcName, sendValue];
            var _ttNames = ["destinationUID", "funcName", "arg"];
            for (var n = 0; n < tt.length; n++) {
                if (typeof (tt[n]) == "function") {
                    throw Error("PostMessage.InvokeMethod argument " + _ttNames[n] + " can not be function");
                }
            }
            if (callbackFunc && typeof (callbackFunc) != "function") {
                throw Error("PostMessage.InvokeMethod argument callbackFunc is not function");
            }
            // send message to listeners
            for (var n = 0; n < this._listenersArr.length; n++) {
                var curr;
                if ((curr = this._listenersArr[n]) && curr != window) // do not send to itself
                 {
                    curr.postMessage(EncodeDataObj({
                        senderUID: this._uniqueUID,
                        destinationUID: destinationUID,
                        funcName: funcName,
                        argument: sendValue,
                        callbackFuncName: this.EncapsulateFunc(callbackFunc) // every callbackFunc may be invoked once, than it has to be removed from _funcBag
                    }), "*");
                }
            }
            return this;
        }
        Echo(destinationUID, msg, callbackFunc) {
            /// <summary>
            /// Echo method. It may be used to connect listener in iframe or child window.
            /// </summary>
            /// <param name="destinationUID" type="String">window or UID string</param>
            /// <param name="msg" type="Object" optional="true">object to be passed to invoking method as argument</param>
            /// <param name="callbackFunc" type="Function" optional="true">
            ///		<para>function(returnedValue, event, this){....}</para>
            ///		<para>function to be invoked on response received, handles object returned from invoked method using return (returnedValue);</para>
            ///		<para>this inside of function is current PostMessage instance</para>
            ///		<para>event is current event {sender:..., origin:..., data:...}</para>
            ///		<para>returnedValue is sent as argument parameter in method this.InvokeMethod(....)</para>
            /// </param>
            return this.InvokeMethod(destinationUID, __EchoTestMethod, msg, callbackFunc);
        }
        HandleMessageEvent(ev) {
            var dat1;
            // if any 3rd party code uses postMessage, make sure this message is from Calysto.PostMessage engine:
            // ev.data is readonly
            if (ev && ev.data && ev.type == "message" && typeof (ev.data) == "string"
                && (dat1 = DecodeDataObj(ev.data))
                && dat1.senderUID
                && dat1.destinationUID) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log("PostMessage " + dat1.senderUID + " -> " + dat1.destinationUID + ": " + ev.data);
                }
                //#endif
                if (dat1.destinationUID == "*" || dat1.destinationUID == this._uniqueUID) {
                    // register sender if not already registered
                    this.AddDistinctListener(ev.source);
                    ////console.log("call to func: " + dat1.funcName);
                    var func1;
                    if (dat1.funcName && (func1 = this._funcBag[dat1.funcName])) {
                        // execute funcName, and get result:
                        var result = func1(dat1.argument, ev); //pass original event as 2nd parameter
                        if (dat1.isCallback) {
                            // this should be executed on sender after InvokeMethod is called than callback is received
                            // console.log("delete func: " + dat1.funcName);
                            // callback executed, remove it
                            delete (this._funcBag[dat1.funcName]);
                        }
                        else if (ev && ev.source && dat1.callbackFuncName) {
                            // console.log("callback response from " + _postMsgUID + ": " + Calysto.JSON.Serialize(result));
                            // this part of the code is destination after InvokeMethod is invoked on sender
                            // send response to sender only
                            let data1 = EncodeDataObj({
                                senderUID: this._uniqueUID,
                                destinationUID: dat1.senderUID,
                                funcName: dat1.callbackFuncName,
                                isCallback: true,
                                argument: result
                            });
                            ev.source.postMessage(data1, "*");
                        }
                        else {
                            // InvokeMethod is invoked without callbackFunction
                        }
                    }
                    else {
                        throw new Error("Error in PostMessage, function not registered: " + dat1.funcName);
                    }
                }
                else {
                    // not PostMessage message or not for current listener
                }
            }
        }
        static FindIframe(arg) {
            /// <summary>
            /// Find iframe element from arg
            /// </summary>
            /// <param name="ifrContentWin" type="MessageEvent|Window"></param>
            var iframes = document.getElementsByTagName("iframe");
            var ifr;
            for (var n = 0; n < iframes.length; n++) {
                if ((ifr = iframes[n]) && (ifr.contentWindow == arg.source || ifr.contentWindow == arg)) {
                    return ifr;
                }
            }
            return null;
        }
    }
    Calysto.PostMessage = PostMessage;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Forms;
    (function (Forms) {
        class SerializedElement {
            constructor() {
                this.Enabled = true;
                this.Visible = true;
            }
        }
        //#region SerializeElement
        function SerializeElement(element) {
            /// <summary>
            /// values which browser originally send on form-submit. Returns name-value object: {Element: el, Name:name1, Value: value1}
            /// </summary>
            /// <param name="element"></param>
            //////#if VSINT ELLISENSE
            ////if (Calysto.IsVSIntellisense)
            ////{
            ////	return {
            ////		// dom element
            ////		Element: HTMLInputElement.prototype,
            ////		// string: attribute name="..."
            ////		Name: "",
            ////		// string or array: attribute value="..." or array of values in multiselect
            ////		Value: ""
            ////	};
            ////}
            //////#endif
            // if there is calysto-id, name may not exsits, serialize element anyway
            if (!(element && element.tagName && element.type)) {
                return {}; // text nodes, html nodes
            }
            var elementName = element.name;
            var tagName = element.tagName.toUpperCase();
            var type = element.type.toLowerCase();
            var finalValue = null;
            var attr = element.getAttribute(Calysto.AttrName.CalystoGetter);
            if (attr) {
                var fn = Calysto.Utility.Expressions.CompileLambdaExpression(attr); /// fn must return value
                finalValue = fn.call(element, element);
            }
            else {
                switch (tagName) {
                    case "INPUT":
                        switch (type) {
                            case "checkbox":
                            case "radio":
                                // if not checked, value should not be sent to server at all,
                                // can not create false value because of radios group where all of them have the same name and value is selected if radio is checked
                                if (!element.checked) {
                                    return {};
                                }
                                else if (element.value == "on" && !element.getAttribute("value")) {
                                    // if there is no attribute "value", default value for checkbox and radio is "on"
                                    // than return only true if checked, if not checked, value should not be sent to server at all
                                    finalValue = true;
                                }
                                else {
                                    finalValue = element.value;
                                }
                                break;
                            case "file":
                                finalValue = []; // always create name and array of values (or empty array if there is no values)
                                if (element.files && element.files[0]) {
                                    for (var n = 0; n < element.files.length; n++) {
                                        finalValue.push(element.files[n]);
                                    }
                                }
                                break;
                            // text, password, hidden, email, tel, ...
                            default:
                                finalValue = element.value; // allways create name and value, even if value is empty ("")
                                break;
                        }
                        break;
                    case "TEXTAREA":
                        finalValue = element.value; // allways create name and value, even if value is empty ("")
                        break;
                    case "SELECT":
                        {
                            switch (element.type) {
                                case "select":
                                case "select-one":
                                    finalValue = element.value; // allways create name and value, even if value is empty ("")
                                    break;
                                case "select-multiple":
                                    {
                                        var option;
                                        finalValue = []; // allways create name and value, even if value is empty ("")
                                        // browser creates CSV values, but it is better to use Array because we may have value with comma inside
                                        for (var j = 0; j < element.options.length; j++) {
                                            if ((option = element.options[j]) && option.selected) {
                                                finalValue.push(option.value);
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                        break;
                }
            }
            let toType = element.getAttribute(Calysto.AttrName.CalystoType);
            if (toType) {
                let destType = Calysto.Type.TypeDescriptor.FromTypeName(toType);
                if (!destType.IsValidKnownType) {
                    throw new Error("Forms serializer error, invalid toType: " + toType);
                }
                var fnConvert = function (val1) {
                    // Date or Calysto.DateTime convertion only
                    var format = element.getAttribute(Calysto.AttrName.CalystoFormat);
                    if (val1 && format && (destType.KnownTypeName == Calysto.Type.KnownType.Date || destType.KnownTypeName == Calysto.Type.KnownType.DateTime)) {
                        let refOut = new Calysto.BoxValue();
                        if (Calysto.DateTime.TryParseDateTime(val1, format, refOut)) {
                            val1 = refOut.GetValue();
                        }
                    }
                    // empty string has to be converted to null if toType != String
                    val1 = Calysto.Type.TypeConverter.ChangeType(val1, toType, true);
                    return val1;
                };
                let currType = Calysto.Type.TypeDescriptor.FromValue(finalValue);
                if (currType.KnownTypeName != destType.KnownTypeName) {
                    if (Calysto.Type.TypeInspector.IsArray(finalValue)) {
                        var arr = [];
                        for (var n1 = 0; n1 < finalValue.length; n1++) {
                            arr.push(fnConvert(finalValue[n1]));
                        }
                        finalValue = arr;
                    }
                    else {
                        finalValue = fnConvert(finalValue);
                    }
                }
            }
            // if finalValue is not set, value should not be sent to server at all
            // if null, don't send to server at all
            return {
                // dom element
                Element: element,
                // string: attribute name="..."
                Name: elementName,
                // string or array: attribute value="..." or array of values in multiselect
                Value: finalValue,
                // if has value, empty string is considred as value too
                HasValue: !Calysto.Type.TypeInspector.IsNullOrUndefined(finalValue)
            };
        }
        ;
        function SerializeContainer(containerSelector) {
            /// <summary>
            /// Form-serialize containerSelector, returns array of Name-Value objects: [{Element:el1, Name:name1, Value:value1}, {Element:el2, Name:name2, Value:value2}, ...]
            /// </summary>
            /// <param name="containerSelector"></param>
            /// <param name="nameValueDataObject"></param>
            //////#if VSIN TELLISENSE
            ////if (Calysto.Core.IsVSIntellisense)
            ////{
            ////	return [SerializeElement()];
            ////}
            //////#endif
            if (!containerSelector) {
                return [];
            }
            var all = $$calysto(containerSelector).Query("*, //*").Query("input, textarea, select").ToArray();
            var result;
            var finalArr = [];
            for (var n = 0; n < all.length; n++) {
                if ((result = SerializeElement(all[n])).HasValue) // result is {Element:el1, Name:name1, Value:value1}
                 {
                    finalArr.push(result);
                }
            }
            return finalArr;
        }
        Forms.SerializeContainer = SerializeContainer;
        ;
        //#endregion
        //#region DeserializeElement
        function EnsureDataTypeAttribute(el, data) {
            /// <summary>
            /// Set calysto-type attribute, only if doesn't exist already
            /// </summary>
            /// <param name="el" type="HTMLDivElement"></param>
            /// <param name="data" type="type"></param>
            /// <returns type=""></returns>
            if (!el.getAttribute(Calysto.AttrName.CalystoType)) {
                var tt = Calysto.Type.TypeDescriptor.FromValue(data);
                if (tt.IsValidKnownType) {
                    el.setAttribute(Calysto.AttrName.CalystoType, tt.NullableTypeName);
                }
            }
        }
        function DeserializeElement(elem, pval) {
            let element = elem;
            EnsureDataTypeAttribute(element, pval);
            var attr = element.getAttribute(Calysto.AttrName.CalystoSetter);
            if (attr) {
                // use original pval, do not convert to "" if null or undefined or NaN
                var fn = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(attr);
                fn.call(element, pval);
                return true;
            }
            var type = "";
            if (element.type) {
                // div element doesn't have .type
                type = element.type.toLowerCase();
            }
            if (Calysto.Type.TypeInspector.IsNullOrUndefined(pval)) {
                pval = "";
            }
            var tagName = element.tagName.toUpperCase();
            switch (tagName) {
                case "TEXTAREA":
                    element.value = pval;
                    break;
                case "INPUT":
                    switch (type) {
                        case "checkbox":
                        case "radio":
                            if (element.value == "on" && !element.getAttribute("value")) // means if value is not set, it's default value is "on"
                             {
                                // if pval is boolean, set checked = value
                                element.checked = pval === true || pval === "true" || pval === "True";
                            }
                            else {
                                // if pval is equal to value, set checked = true
                                element.checked = element.value + "" == pval + "";
                            }
                            break;
                        default:
                            // if we have calysto-format specified or if pval is dateTime or number, format it
                            element.value = Calysto.Type.TypeConverter.ToStringFormated(pval, element.getAttribute(Calysto.AttrName.CalystoFormat));
                            break;
                    }
                    break;
                case "SELECT":
                    switch (type) {
                        case "select":
                        case "select-one":
                        case "select-multiple":
                            // select-multiple.value is always single value, must select options one by one
                            try {
                                if (pval && "Items" in pval) {
                                    var listItems = pval["Items"];
                                    var el = element; // element with options as children
                                    el.innerHTML = "";
                                    var optArr = listItems.ForEach((o, n) => {
                                        let opt = document.createElement("option");
                                        opt.innerHTML = o.Text;
                                        opt.value = o.Value;
                                        el.appendChild(opt);
                                        opt.selected = !!o.Selected;
                                        return opt;
                                    });
                                    break;
                                }
                            }
                            catch (e) { }
                            if (type == "select-multiple") {
                                if (Calysto.Type.TypeInspector.IsNullOrUndefined(pval)) {
                                    pval = [];
                                }
                                else if (!Calysto.Type.TypeInspector.IsArray(pval)) {
                                    pval = [pval];
                                }
                                var arr = pval;
                                var el = element; // element with options as children
                                // pval contains values which have to be selected
                                // since IE element.options return select element, we have use it like this:
                                for (var n1 = 0; n1 < el.options.length; n1++) {
                                    el.options[n1].selected = arr.Where(o => (o + "") == el.options[n1].value).Any(); // value is always string
                                }
                            }
                            else {
                                // if value doesn't exist in ddl, it will select index -1, or nothing
                                // it is better way because we may not accidentaly assign first value in ddl if there is no valid pval send from 
                                // if pval is dateTime or number, format it
                                // if value doesn't exist, it will set selectedIndex = -1 (none will be selected)
                                element.value = Calysto.Type.TypeConverter.ToStringFormated(pval, element.getAttribute(Calysto.AttrName.CalystoFormat));
                            }
                            break;
                        default:
                            throw new Error(`Type ${type} not supported.`);
                    }
                    break;
                default:
                    if ("innerHTML" in element) {
                        // if pval is dateTime or number, format it
                        element.innerHTML = Calysto.Type.TypeConverter.ToStringFormated(pval, element.getAttribute(Calysto.AttrName.CalystoFormat));
                    }
                    else {
                        return false; // element can't be deserialized
                    }
                    break;
            }
            return true; // element deserialized successfuly
        }
        //#endregion
        //#region Reset Form Fields
        /**
         * Reset all values do defaults. Exclude disabled or readOnly elements.
         * @param {string | HTMLElement} containerSelector
         */
        function ResetForm(containerSelector) {
            /// <summary>
            /// Reset all values do defaults. Exclude disabled or readOnly elements.
            /// </summary>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            $$calysto(containerSelector || document.documentElement).Query("*, //*").Query("input, select, textarea, [" + Calysto.AttrName.CalystoSetter + "=*]").ForEach((o) => {
                if (!o.disabled && !o.readOnly) {
                    var attr = o.getAttribute(Calysto.AttrName.CalystoSetter);
                    var tagName = o.tagName.toLowerCase();
                    if (attr) {
                        var fn = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(attr);
                        fn.call(o, "");
                    }
                    else if (tagName == "textarea") {
                        o.value = "";
                    }
                    else if (tagName == "input") {
                        if (o.type == "radio" || o.type == "checkbox") {
                            o.checked = false;
                        }
                        else if (o.type == "button" || o.type == "submit") {
                            // nothing
                        }
                        else {
                            o.value = "";
                        }
                    }
                    else if (tagName.indexOf("select") == 0) {
                        o.value = ""; // if value doesn't exist select selectedIndex = -1
                        o.selectedIndex = 0; // now set first value in ddl
                    }
                }
            });
        }
        Forms.ResetForm = ResetForm;
        ;
        //#endregion
        //#region FormSerialize & FormDeserialize
        /**
         * Form-serialize containerSelector into dictionary. Serializes inputs with 'name' attribute. Returns dictionary: {name1: value1, name2: value2, ...}<br/>
            If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} trimStrings?
         * @param {TResult} refOutDataObj?
         * @returns
         */
        function FormSerialize(containerSelector, trimStrings, refOutDataObj) {
            /// <summary>
            /// Form-serialize containerSelector into dictionary. Serializes inputs with 'name' attribute. Returns dictionary: {name1: value1, name2: value2, ...}<br/>
            /// If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            /// If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
            /// </summary>
            /// <param name="containerSelector"></param>
            /// <param name="trimStrings" optional="true">if true, trim text values</param>
            /// <param name="refOutDataObj" optional="true">update read values into this object</param>
            var arr = SerializeContainer(containerSelector || document.documentElement);
            let includedNames = {};
            var dic = refOutDataObj || {};
            for (var n = 0; n < arr.length; n++) {
                var name = arr[n].Name;
                if (!name) {
                    continue;
                }
                else if (includedNames[name]) {
                    // Form standard uses first name found in form and ignores next item with the same name
                    continue;
                }
                includedNames[name] = true;
                var value = arr[n].Value;
                if (trimStrings && Calysto.Type.TypeInspector.IsString(value)) {
                    value = (value || "").Trim();
                }
                // if value is null, undefined, NaN or empty string, do not set value at all
                // DataAnnotation attributes considers null as no data, while empty string "" is considered as data and triggers MinLen attribute
                if (!Calysto.Type.TypeInspector.IsNullOrUndefined(value) && !String.IsNullOrEmpty(value)) {
                    dic[name] = value;
                }
            }
            return dic;
        }
        Forms.FormSerialize = FormSerialize;
        ;
        /**
         * Bind data from dataObj dictionay to any element (not just input) with 'name' or 'id' attribute named as dataObj properties<br/>
            If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
         * @param {any} dataObj
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} alwaysSet?
         */
        function FormDeserialize(dataObj, containerSelector, alwaysSet) {
            /// <summary>
            /// Bind data from dataObj dictionay to any element (not just input) with 'name' or 'id' attribute named as dataObj properties<br/>
            /// If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            /// If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            /// If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
            /// </summary>
            /// <param name="dataObj" type="object">object with values</param>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="alwaysSet" optional="true">if true, always set element value, if value doesn't exist in dataObj, use default value</param>
            dataObj = dataObj || {};
            // populate controls
            // allow multiple elements with the same name or id
            // asp.net style name = pp$aa$propName
            // asp.net style id = pp_aa_propName
            $$calysto(containerSelector || document.documentElement).Query("[name=*], //[name=*]").ForEach((o) => {
                // required condition: name && name.length > 0
                var name;
                if (o && (name = o.name)) {
                    if (alwaysSet || name in dataObj) {
                        if (!DeserializeElement(o, dataObj[name])) {
                            throw new Error("Element with name=" + name + " is not valid for data binding");
                        }
                    }
                }
            });
        }
        Forms.FormDeserialize = FormDeserialize;
        ;
        //#endregion
        //#region MvcSerialize && MvcDeserialize
        /**
         * Form-serialize values into dictionary.
         * Ignores null or empty values.
         * Serializes inputs with 'name' attribute. Name may have nested path: prop1.prop2.prop3. It builds nested js objects.
            If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} trimStrings?
         * @param {TResult} refOutDataObj?
         * @returns
         */
        function MvcSerialize(containerSelector, trimStrings, refOutDataObj) {
            var arr = SerializeContainer(containerSelector || document.documentElement);
            let includedNames = {};
            var dic = refOutDataObj || {};
            for (var n = 0; n < arr.length; n++) {
                var name = arr[n].Name;
                if (!name) {
                    continue;
                }
                else if (includedNames[name]) {
                    // Form standard uses first name found in form and ignores next item with the same name
                    continue;
                }
                includedNames[name] = true;
                var value = arr[n].Value;
                if (trimStrings && Calysto.Type.TypeInspector.IsString(value)) {
                    value = (value || "").Trim();
                }
                // if value is null, undefined, NaN or empty string, do not set value at all
                // DataAnnotation attributes considers null as no data, while empty string "" is considered as data and triggers MinLen attribute
                if (!Calysto.Type.TypeInspector.IsNullOrUndefined(value) && !String.IsNullOrEmpty(value)) {
                    ///dic[name] = value;
                    // create hierarchy
                    Calysto.DataBinder.SetValue(dic, name, value);
                }
            }
            return dic;
        }
        Forms.MvcSerialize = MvcSerialize;
        ;
        /**
         * Bind data from dataObj to any element (not just inputs) with 'name' or 'id' attributes named as dataObj properties or asp.net style names with pp$aa$propName<br/>
            If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
         * @param {any} dataObj
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} alwaysSet?
         */
        function MvcDeserialize(dataObj, containerSelector, alwaysSet) {
            /// <summary>
            /// Bind data from dataObj to any element (not just inputs) with 'name' or 'id' attributes named as dataObj properties or asp.net style names with pp$aa$propName<br/>
            /// If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            /// If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            /// If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
            /// </summary>
            /// <param name="dataObj" type="object">object with values</param>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="alwaysSet" optional="true">if true, always set element value, if value doesn't exist in dataObj, use null value</param>
            dataObj = dataObj || {};
            // populate controls
            // allow multiple elements with the same name or id
            // asp.net style name = pp$aa$propName
            // asp.net style id = pp_aa_propName
            $$calysto(containerSelector || document.documentElement).Query("*, //*").ForEach((el) => {
                var name;
                if (el && (name = el.name)) {
                    if (!!name) {
                        // element name many be full property path prop1.prop2.prop3
                        let box1 = new Calysto.BoxValue();
                        let hasProperty = Calysto.DataBinder.TryGetValue(dataObj, name, box1);
                        // required condition: name && name.length > 0
                        if (alwaysSet || hasProperty) {
                            if (!DeserializeElement(el, box1.GetValue())) {
                                throw new Error("Element with name=" + name + " is not valid for data binding");
                            }
                        }
                    }
                }
            });
        }
        Forms.MvcDeserialize = MvcDeserialize;
        ;
        //#endregion
        //#region CalystoSerialize & CalystoDeserialize
        /**
         * Serialize values from input elements with 'calysto-id' attribute into dictionary by creating properties named as calysto-id attribute values.<br/>
            Property names may by compound path, eg. prop1.prop2.prop3, it creates nested object using Calysto.DataBinder.SetValue(...).<br/>
            If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} trimStrings?
         * @param {TResult} refOutDataObj?
         * @returns
         */
        function CalystoSerialize(containerSelector, trimStrings, refOutDataObj) {
            /// <summary>
            /// Serialize values from input elements with 'calysto-id' attribute into dictionary by creating properties named as calysto-id attribute values.<br/>
            /// Property names may by compound path, eg. prop1.prop2.prop3, it creates nested object using Calysto.DataBinder.SetValue(...).<br/>
            /// If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            /// If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
            /// </summary>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="trimStrings" optional="true">if true, trim text values</param>
            /// <param name="refOutDataObj" optional="true">update values into this refOutDataObj</param>
            // important: serialize input, select, textarea only, do not serialize other html elements bezause there may be duplicated ids
            let arr = $$calysto(containerSelector || document.documentElement)
                .Query("[" + Calysto.AttrName.CalystoId + "=*], //[" + Calysto.AttrName.CalystoId + "=*]").Query("input, textarea, select, [" + Calysto.AttrName.CalystoGetter + "=*]")
                .Distinct()
                .ToArray();
            let dic = refOutDataObj || {};
            for (let n = 0; n < arr.length; n++) {
                let el = arr[n];
                let result;
                let name;
                let value;
                // if we're using existing object to populate with values, allow previous values to exist in dataObj
                let createArrayValues = !!el.getAttribute(Calysto.AttrName.CalystoIsGroup);
                // we may have multiple input elements with the same calysto-id attribute value, than create array with their values
                let allowDuplicates = createArrayValues || (!!refOutDataObj);
                result = SerializeElement(el);
                // if we're populating existing refOutDataObj, we have to set it's value even if it is empty or has no value, 
                // this way we update the existing value with new one when the new one is empty or null or ""
                if (!!refOutDataObj || result.HasValue) {
                    name = el.getAttribute(Calysto.AttrName.CalystoId);
                    value = result.Value;
                    if (!name)
                        continue;
                }
                else {
                    continue;
                }
                if (trimStrings && typeof (value) == "string") {
                    value = (value || "").Trim();
                }
                // name can be property path: prop1.prop2.prop3, only in calysto-id="prop1.prop2.prop3", MVC or Forms doesnt support it
                let refOut = new Calysto.BoxValue();
                if (!allowDuplicates && Calysto.DataBinder.TryGetValue(dic, name, refOut)) {
                    throw new Error("Error in CalystoSerialize, property " + name + " already exists.");
                }
                if (createArrayValues) {
                    Calysto.DataBinder.SetValue(dic, name, [refOut.GetValue()]);
                }
                else {
                    Calysto.DataBinder.SetValue(dic, name, value);
                }
            }
            return dic;
        }
        Forms.CalystoSerialize = CalystoSerialize;
        ;
        /**
         * Bind data from dataObj to any element with 'calysto-id' attribute named as dataObj properties.<br/>
            Property names may by compound path, eg. prop1.prop2.prop2, value is read using Calysto.DataBinder.TryGetValue(...).<br/>
            If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
         * @param {any} dataObj
         * @param {string | HTMLElement} containerSelector
         * @param {boolean} alwaysSet?
         */
        function CalystoDeserialize(dataObj, containerSelector, alwaysSet) {
            /// <summary>
            /// Bind data from dataObj to any element with 'calysto-id' attribute named as dataObj properties.<br/>
            /// Property names may by compound path, eg. prop1.prop2.prop2, value is read using Calysto.DataBinder.TryGetValue(...).<br/>
            /// If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            /// If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            /// If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
            /// </summary>
            /// <param name="dataObj" type="object">object with values</param>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="alwaysSet" optional="true">if true, always set element value, if value doesn't exist in dataObj, use default value</param>
            // populate controls
            // allow multiple calysto-id=name with the same name
            if (dataObj) {
                $$calysto(containerSelector || document.documentElement).Query("[" + Calysto.AttrName.CalystoId + "=*], //[" + Calysto.AttrName.CalystoId + "=*]").Distinct().ForEach((el) => {
                    // componud name path may be used, eg. calysto-id="Data.Names.0.Age", that is why we use Calysto.DataBinder.TryGetValue
                    let name = el.getAttribute(Calysto.AttrName.CalystoId);
                    // required condition: name && name.length > 0
                    let refObj = new Calysto.BoxValue();
                    if (name && (Calysto.DataBinder.TryGetValue(dataObj, name, refObj)) || alwaysSet) {
                        if (el["type"] == "text" && el.getAttribute(Calysto.AttrName.CalystoIsGroup)) {
                            // for check and radio inputs, we have to find p
                            // can not deserialize value if element has calysto-isgroup attribute, 
                            // means there are multiple elements with the same calysto-id attribute
                            throw new Error("NotImplemented: deserialization to element with calysto-isgroup attribute");
                        }
                        else if (!DeserializeElement(el, refObj.GetValue())) // if value doesn't exists in dataObj[name], it will set default value to element
                         {
                            throw new Error("Element with calysto-id=" + name + " is not valid for data binding");
                        }
                    }
                });
            }
        }
        Forms.CalystoDeserialize = CalystoDeserialize;
        ;
        //#endregion
        //#region CalystoSerialize2 & CalystoDeserialize2
        ////type TResult =
        ////	{
        ////		[p: string]: SerializedElement
        ////	};
        function CalystoSerialize2(containerSelector, trimStrings, refOutDataObj) {
            /// <summary>
            /// Serialize values from input elements with 'calysto-id' attribute into dictionary by creating properties named as calysto-id attribute values.<br/>
            /// Property names may by compound path, eg. prop1.prop2.prop3, it creates nested object using Calysto.DataBinder.SetValue(...).<br/>
            /// If 'calysto-type' attribute exists, data is converted to calysto-type type. For supported calysto-type values, see: Calysto.Type.DotNetTypeName<br/>
            /// If 'calysto-getter' attribute exists with lambda expression, it will be used to get value from element. this inside lamba is element.
            /// </summary>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="trimStrings" optional="true">if true, trim text values</param>
            /// <param name="refOutDataObj" optional="true">update values into this refOutDataObj</param>
            // important: serialize input, select, textarea only, do not serialize other html elements because there may be duplicated ids
            let arr = $$calysto(containerSelector || document.documentElement)
                .Query("[" + Calysto.AttrName.CalystoId + "=*], //[" + Calysto.AttrName.CalystoId + "=*]")
                .Query("input, textarea, select, [" + Calysto.AttrName.CalystoGetter + "=*]")
                .Distinct()
                .ToArray();
            let allowDuplicates = !!refOutDataObj; // if we're using existing object to populate with values, allow previous values to exist in dataObj
            let dic = refOutDataObj || {};
            for (let n = 0; n < arr.length; n++) {
                let element = arr[n];
                let calystoid = element.getAttribute(Calysto.AttrName.CalystoId);
                let calystouid = element.getAttribute(Calysto.AttrName.CalystoUid);
                if (!calystouid) {
                    element.setAttribute(Calysto.AttrName.CalystoUid, (calystouid = Calysto.Utility.Generators.GeneratePassword(20)));
                }
                let res = SerializeElement(element);
                let dic2 = {
                    CalystoId: calystoid,
                    CalystoUid: calystouid,
                    Value: res && res.HasValue ? res.Value : undefined,
                    Enabled: $$calysto(element).WhereEnabled(true).Any(),
                    Visible: $$calysto(element).WhereVisible(true).Any(),
                    Name: Calysto.Utility.Html.ExtractAspNameOrId(element["name"]),
                    Id: Calysto.Utility.Html.ExtractAspNameOrId(element.id),
                    Checked: element["checked"],
                    HtmlName: element["name"],
                    HtmlValue: element["value"],
                    HtmlId: element.id,
                    HtmlTagName: element.tagName,
                    HtmlType: element["type"]
                };
                // name can be property path: prop1.prop2.prop3, only in calysto-id="prop1.prop2.prop3", MVC or Forms doesnt support it
                let refOut = new Calysto.BoxValue();
                if (!allowDuplicates && Calysto.DataBinder.TryGetValue(dic, calystoid, refOut)) {
                    throw new Error("Error in CalystoSerialize2, property " + calystoid + " already exists.");
                }
                if (trimStrings && typeof (dic2.Value) == "string") {
                    dic2.Value = (dic2.Value || "").Trim();
                }
                Calysto.DataBinder.SetValue(dic, calystoid, dic2);
            }
            return dic;
        }
        Forms.CalystoSerialize2 = CalystoSerialize2;
        function CalystoDeserialize2(dataObj, containerSelector, alwaysSet) {
            /// <summary>
            /// Bind data from dataObj to any element with 'calysto-id' attribute named as dataObj properties.<br/>
            /// Property names may by compound path, eg. prop1.prop2.prop2, value is read using Calysto.DataBinder.TryGetValue(...).<br/>
            /// If 'calysto-format' attribute exists, data is formated into string using Calysto.Type.ToStringFormated(val, format).<br/>
            /// If 'calysto-type' attribute doesn't exist, it resolved from current data value and is added to element.<br/>
            /// If 'calysto-setter' attribute exits with lambda expression, it is used to set value to element. this inside lambda is element.
            /// </summary>
            /// <param name="dataObj" type="object">object with values</param>
            /// <param name="containerSelector" optional="true">if not provided, default: document</param>
            /// <param name="alwaysSet" optional="true">if true, always set element value, if value doesn't exist in dataObj, use default value</param>
            // populate controls
            // allow multiple calysto-id=name with the same name
            if (dataObj) {
                $$calysto(containerSelector || document.documentElement).Query("[" + Calysto.AttrName.CalystoId + "=*], //[" + Calysto.AttrName.CalystoId + "=*]").Distinct().ForEach((el) => {
                    // componud name path may be used, eg. calysto-id="Data.Names.0.Age", that is why we use Calysto.DataBinder.TryGetValue
                    var name = el.getAttribute(Calysto.AttrName.CalystoId);
                    // required condition: name && name.length > 0
                    var refOut = new Calysto.BoxValue();
                    if (name && (Calysto.DataBinder.TryGetValue(dataObj, name, refOut)) || alwaysSet) {
                        let item = refOut.GetValue();
                        let val1 = item ? item.Value : undefined;
                        if (!DeserializeElement(el, val1)) // if value doesn't exists in dataObj[name], it will set default value to element
                         {
                            throw new Error("Element with calysto-id=" + name + " is not valid for data binding");
                        }
                        else if (item) {
                            // deserialize other values
                            $$calysto(el)
                                .SetVisible(!!item.Visible)
                                .SetEnabled(!!item.Enabled)
                                .SetProperty("checked", !!item.Checked);
                        }
                    }
                });
            }
        }
        Forms.CalystoDeserialize2 = CalystoDeserialize2;
        //#endregion
        //#region ToMvcModelState
        function ToMvcModelState(containerSelector) {
            let state = new Calysto.Web.UI.Direct.CalystoMvcModelState();
            state.Raw = MvcSerialize(containerSelector, true);
            state.RootSelector = Calysto.Utility.Dom.EnsureElementId(containerSelector);
            return state;
        }
        Forms.ToMvcModelState = ToMvcModelState;
        //#endregion
    })(Forms = Calysto.Forms || (Calysto.Forms = {}));
})(Calysto || (Calysto = {}));
////namespace Calysto.JsObjectReader
////{
////	export interface IJsObjectElement
////	{
////		tagName: string;
////		childNodes: IJsObjectElement[];
////		parentNode: IJsObjectElement;
////		nodeValue: any;
////		isConvertedJsNode: boolean;
////	}
////	/**
////	 * read JS object and create DOM like hierarchy to enable traversing with DomQuery .Query(..)
////	 * @param jsObject
////	 */
////	export function ReadObject(jsObject)
////	{
////		/// <summary>
////		/// parse js object, creates collection of artifitial dom elements to enable .Query(...) function.
////		/// </summary>
////		/// <param name="jsObject"></param>
////		var root = CreateNewNode("#root");
////		Dump(root, jsObject);
////		return new Calysto.DomQuery([root]);
////	}
////	function CreateNewNode(tagName: string)
////	{
////		return <IJsObjectElement><any>{
////			// represents property name in JS object
////			tagName: tagName || "",
////			childNodes: [],
////			//parentNode: undefined,
////			nodeValue: null,
////			isConvertedJsNode: true
////		};
////	}
////	function IsEnumerable(obj)
////	{
////		try
////		{
////			for (var p in obj)
////			{
////				return true;
////			}
////		}
////		catch (e)
////		{
////		}
////		return false;
////	}
////	function AddValue(parent, o)
////	{
////		var node = CreateNewNode("#value");
////		node.parentNode = parent;
////		node.nodeValue = o;
////		parent.childNodes.push(node);
////	}
////	function DumpArray(parent, o)
////	{
////		var n1 = CreateNewNode("#arrayItem");
////		for (var n = 0; n < o.length; n++)
////		{
////			try
////			{
////				Dump(n1, o[n]);
////			}
////			catch (ex)
////			{
////			}
////		}
////		parent.childNodes.push(n1);
////	}
////	function DumpObject(parent, o)
////	{
////		try
////		{
////			for (var prop in o)
////			{
////				var v1 = o[prop];
////				var node = CreateNewNode(prop);
////				node.parentNode = parent;
////				parent.childNodes.push(node);
////				try
////				{
////					Dump(node, v1);
////				}
////				catch (ex1)
////				{
////					(<any>node).nodeValue = "*** ERROR_PARSING ***";
////				}
////			}
////		}
////		catch (ex)
////		{
////		}
////	}
////	function Dump(parent, o)
////	{
////		if (o == null)
////		{
////			AddValue(parent, null);
////		}
////		else if (typeof (o) == "function")
////		{
////			return;
////		}
////		else if (o && (typeof (o) == "string" || typeof (o) == "number" || typeof (o) == "boolean"))
////		{
////			AddValue(parent, o);
////		}
////		else if (o && o.push && o.pop && o.length) // JS or DOM array
////		{
////			DumpArray(parent, o);
////		}
////		else if (IsEnumerable(o))
////		{
////			DumpObject(parent, o);
////		}
////		else
////		{
////			AddValue(parent, o);
////		}
////	}
////}
var Calysto;
(function (Calysto) {
    class SelectorReader {
        constructor(selector) {
            this.selector = selector;
            this.currPosition = 0;
        }
        Peek(forwardBy = 0) {
            /// <summary>
            /// Peek next char.
            /// </summary>
            /// <param name="forwardBy" optional="true">default:0 (first available on stack)</param>
            return this.selector.charAt(this.currPosition + (forwardBy || 0));
        }
        Pop() {
            /// <summary>
            /// Pop first available value, than advance index + 1.
            /// </summary>
            return this.selector.charAt(this.currPosition++);
        }
        PopMatch(regex, origin = 0) {
            /// <summary>
            /// Match from (first + origin) position, if match found, advance index by (match length + origin) and return match.
            /// If match is not found, return undefined and don't advance current position index.
            /// </summary>
            /// <param name="regex"></param>
            /// <param name="origin" optional="true">default: 0</param>
            origin = origin || 0;
            var mm = (this.selector.substr(this.currPosition + origin) || "").match(regex);
            if (mm && mm[0]) {
                this.currPosition += mm[0].length + origin;
                return mm;
            }
            // return undefined
            return null;
        }
    }
    Calysto.SelectorReader = SelectorReader;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    //#region Helper functions
    function attrPredicateFunc(el, attrName, attrSign, attrValue) {
        // currentValue: current attribute value
        // attrValue: expected attribute value
        // attrSign is comparison operator: =, !=, ==, etc.
        if (!attrSign) {
            // eg. [calysto-id] meaning if has value, function el.getAttribute returns null if there is no attribute, but it should be used hasAttribute()
            return Calysto.Utility.Dom.HasAttribute(el, attrName);
        }
        var currValue = Calysto.Utility.Dom.GetAttribute(el, attrName) || ""; // if attribute doesn't exsits, GetAttribute returns null
        var m = attrSign;
        if (!m) {
            // the same as =*
            // no attr sign, statement [attrName] means has attribute value, doesn't matter which value is
            return !!(currValue);
        }
        else if (m == "=" || m == "==") {
            return (currValue == attrValue);
        }
        else if (m == "=*") {
            // has any value, but not empty
            return !!(currValue);
        }
        else if (m == "~=") // E[foo~="warning"]	Matches any E element whose "foo" attribute value is a list of space-separated values, one of which is exactly equal to "warning"
         {
            return ((" " + currValue + " ").indexOf(" " + attrValue + " ") >= 0);
        }
        else if (m == "*=") // contains value
         {
            return (currValue.indexOf(attrValue) >= 0);
        }
        else if (m == "^=") // starts with
         {
            return (currValue.indexOf(attrValue) == 0);
        }
        else if (m == "$=") // ends with
         {
            var index = currValue.lastIndexOf(attrValue);
            return ((index + attrValue.length) == currValue.length);
        }
        else if (m == "!=" || m == "<>") {
            return (currValue != attrValue);
        }
        else //// if (currValue && attrValue) // <, >, <=, >=, % etc
         {
            var num1 = Calysto.Type.NumberConverter.ToNumberOrDefault(currValue, NaN, "."); // current attribute value
            var num2 = Calysto.Type.NumberConverter.ToNumberOrDefault(attrValue, NaN, "."); // expected value
            if (!Calysto.Type.TypeInspector.IsNumber(num1) || !Calysto.Type.TypeInspector.IsNumber(num2)) {
                return false;
            }
            switch (m) {
                case "<": return num1 < num2;
                case ">": return num1 > num2;
                case ">=": return num1 >= num2;
                case "<=": return num1 <= num2;
            }
            // unknown selector
            throw new Error("Unsupported calystoSelector (" + (attrName + ", " + attrSign + ", " + attrValue) + ") in Calysto.DomQuery.BuildLambdaExpression #2");
        }
    }
    function CreateAttributeQuery(source, attrName, attrSign, attrValue) {
        var func = (function (attrName, attrSign, attrValue) {
            return (function (el) {
                return attrPredicateFunc(el, attrName, attrSign, attrValue);
            });
        })(attrName, attrSign, attrValue);
        return source.Where(function (o) { return func(o); });
    }
    function CreateIdQuery(source, id) {
        return source.Where(function (o) { return o.id == id || Calysto.Utility.Html.ExtractAspNameOrId(o.id) == id; });
    }
    function CreateClassQuery(source, className) {
        return source.Where(function (o) { return Calysto.Utility.Dom.HasClass(o, className); });
    }
    function CreateTagQuery(source, tag) {
        return source.Where(function (o) { return Calysto.Utility.Dom.HasTagName(o, tag); });
    }
    function CreateColonWordQuery(source, colonWord, colonValue) {
        var count = parseInt(colonValue, 10) || 1;
        switch (colonWord) {
            case "visible":
                return source.WhereVisible(true); // specific for JS query only
            case "invisible":
            case "hidden":
                return source.WhereVisible(false); // specific for JS query only
            case "first":
            case "take":
                return source.Take(count);
            case "last":
                return source.Reverse().Take(count).Reverse();
            case "skip":
                return source.Skip(count);
            case "exact":
                return source.Exact(count).AsDomQuery();
            case "is":
            case "not":
                // select elements from source where subquery in :is(subquery) is true or :not(subquery) is false, input to subquery is each element from source query
                // $('div//*:not(span)'), select div's descendants, except span, '*' can be removed
                // $(".firstquery...").Query(":not(a>span, .cls1>>div)") or .Query(":not(a>span), :not(.cls1>>div)"), // select all items from first query where item is not "a" with child "span" and item with class 'cls' has no 2nd child 'div'
                // $(".firstquery...").Query(":is(a>span)"), // select all items from first query where item is "a" with child "span"
                // $(".firstquery...").Query(":is(*>span)"), // * is optional: .Query(":is(>span)") select all items from first query where item has child "span"
                return source.Where(o => DomQuery.FromArray([o]).Query(colonValue).Any() == (colonWord == "is"));
            ////case "has":
            ////case "hasnot":
            //// OBSOLETE: use :is or :not instead since "is" or "not" is much more sophisticated version than this crappy jQuery.has(...)
            ////	// The expression $('div:has(p)') matches a <div> if a <p> exists anywhere among its descendants, not just as a direct child.
            ////	var doesHave = colonWord == "has";
            ////	return source.Where(function (o) { return new source._typeCtor([o]).DescendantNodes().Query(colonValue).Any() == doesHave; });
            case "reverse":
                return source.Reverse();
            case "ancestor":
                return source.AncestorNodes();
            case "descendant":
                return source.DescendantNodes();
            case "child":
                return source.ChildNodes();
            case "parent":
                return source.ParentNodes();
            case "next-sibling":
                return source.NextSiblings();
            case "previous-sibling":
                return source.PreviousSiblings();
            default:
                throw new Error("Unsupported calystoSelector: " + colonWord + "(" + colonValue + ")");
        }
    }
    function GetAncestors(node) {
        var items = [];
        while (node.parentNode) {
            items.push(node.parentNode);
            node = node.parentNode;
        }
        return items;
    }
    var dimMap = {
        absoluteTop: NaN,
        absoluteLeft: NaN,
        position: "",
        top: NaN,
        right: NaN,
        bottom: NaN,
        left: NaN,
        width: NaN,
        height: NaN,
        minWidth: NaN,
        minHeight: NaN,
        maxWidth: NaN,
        maxHeight: NaN,
        clientLeft: NaN,
        clientTop: NaN,
        clientWidth: NaN,
        clientHeight: NaN,
        offsetLeft: NaN,
        offsetTop: NaN,
        offsetWidth: NaN,
        offsetHeight: NaN,
        scrollLeft: NaN,
        scrollTop: NaN,
        scrollWidth: NaN,
        scrollHeight: NaN,
        paddingTop: NaN,
        paddingRight: NaN,
        paddingBottom: NaN,
        paddingLeft: NaN,
        marginTop: NaN,
        marginRight: NaN,
        marginBottom: NaN,
        marginLeft: NaN,
        borderTop: NaN,
        borderRight: NaN,
        borderBottom: NaN,
        borderLeft: NaN
    };
    function SetOffsetDimensions(element, offsetWidth, offsetHeight) {
        var el = element;
        if (!Calysto.Utility.Dom.IsElementVisible(el)) {
            return;
        }
        if (typeof (offsetWidth) == "number" && Calysto.Type.TypeInspector.IsNumber(offsetWidth)) {
            // IE fix: button is not mesured correctly with GetComputedStyle(), so set offsetHeigth as style, and test if values are equal
            el.style.width = offsetWidth + "px";
            if (el.offsetWidth != offsetWidth) {
                var currStyleWidth = Calysto.Utility.Dom.GetComputedStyle(el, "width").NumericValue;
                var w1 = offsetWidth - (el.offsetWidth - (currStyleWidth || 0));
                el.style.width = w1 + "px";
            }
        }
        if (typeof (offsetHeight) == "number" && Calysto.Type.TypeInspector.IsNumber(offsetHeight)) {
            // IE fix: button is not mesured correctly with GetComputedStyle(), so set offsetHeigth as style, and test if values are equal
            el.style.height = offsetHeight + "px";
            if (el.offsetHeight != offsetHeight) {
                var currStyleHeight = Calysto.Utility.Dom.GetComputedStyle(el, "height").NumericValue;
                var h1 = offsetHeight - (el.offsetHeight - (currStyleHeight || 0));
                el.style.height = h1 + "px";
            }
        }
    }
    function GetTextValueOnly(node, ignoreCase) {
        var txt = node.tagName || "";
        // get start tag text and node value if exists
        if (node.attributes && node.attributes.length > 0) {
            for (var n = 0; n < node.attributes.length; n++) {
                var attr = node.attributes[n];
                txt += " " + attr.name + "=\"" + attr.value + "\"";
            }
        }
        if (node.nodeValue) {
            if (txt && txt.length > 0) {
                txt += " ";
            }
            txt += node.nodeValue;
        }
        return ignoreCase ? txt.toLowerCase() : txt;
    }
    function CssClass(source, method, cssClass) {
        return source.ForEach(function (item, index) {
            Calysto.Utility.Dom[method](item, cssClass);
        });
    }
    var transforms = ["transform", "-ms-transform", "-webkit-transform"];
    function GetHoverCB(isHover, callbackFunc) {
        return (function (sender, ev) {
            if (Calysto.Event.IsHoverChanged(sender, ev, isHover)) {
                // enter or exit
                return callbackFunc.call(sender, sender, ev); // this is element
            }
        });
    }
    function GetTriggCountCB(triggCountMax, callbackFunc) {
        var count = 0;
        return (function (sender, ev) {
            var ret;
            ev = ev || window.event; // old IE doesn't send event
            if (count < triggCountMax) {
                count++;
                ret = callbackFunc.call(sender, sender, ev); // this is element
            }
            // there is no state, so we can't remove event
            // it is not enough to use type and originalCallback
            return ret;
        });
    }
    ;
    function GetCBEncaps(callback) {
        return ((sender, ev) => {
            ev = ev || window.event; // old IE doesn't send event
            var res = callback.call(sender, sender, ev); // this is element
            if (res === false) {
                Calysto.Event.StopPropagation(ev, true);
            }
            else if (res === true) {
                Calysto.Event.StopPropagation(ev, false);
            }
            return res;
        });
    }
    function AddOrModify(funcName, currItemsArray, contentArgsArray) {
        /// <summary>
        /// If node already has parentNode, node will be cloned
        /// </summary>
        /// <param name="funcName" type="String"></param>
        /// <param name="contentArgsArray"></param>
        var allCurr = currItemsArray;
        var elarr = Calysto.Utility.Dom.ConvertToElementsArray(contentArgsArray);
        var allNew = [];
        for (var n1 = 0; n1 < allCurr.length; n1++) {
            var cloned = [];
            // elarr may be null
            for (var k = 0; elarr && k < elarr.length; k++) {
                // clone nodes which already has parentNode
                var el = Calysto.Utility.Dom.CloneNodeIfHasParent(elarr[k]);
                cloned.push(el);
                allNew.push(el);
            }
            // even if elarr is null, we have to call func, eg. ReplaceChildren to remove children from dom
            Calysto.Utility.Dom[funcName](allCurr[n1], cloned);
        }
        ExecuteInsertedScripts(allNew);
        return { ThisItems: allCurr, NewItems: allNew };
    }
    function ExecuteInsertedScripts(containers) {
        DomQuery.FromArray(containers).Query("script, //script").ForEach(o => Calysto.ScriptLoader.ReloadScriptNode(o));
    }
    function ParseXmlString(xmlDocStr) {
        var xmlDoc;
        if (window.DOMParser) {
            var parser = new DOMParser();
            xmlDoc = parser.parseFromString(xmlDocStr, "text/xml");
        }
        else {
            // IE :(
            if (xmlDocStr.indexOf("<?") == 0) {
                xmlDocStr = xmlDocStr.substr(xmlDocStr.indexOf("?>") + 2);
            }
            xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = false;
            xmlDoc.loadXML(xmlDocStr);
        }
        return xmlDoc;
    }
    //#endregion
    //#region PoolingState
    class PoolingState {
        constructor(query, intervalID) {
            this.query = query;
            this.intervalID = intervalID;
        }
        /**Abort pooling state for changes */
        Abort() {
            clearInterval(this.intervalID);
            return this;
        }
        AsDomQuery() {
            return this.query;
        }
    }
    Calysto.PoolingState = PoolingState;
    //#endregion
    class DomQuery extends Calysto.CalystoEnumerable {
        constructor(getEnumerator) {
            super(getEnumerator);
            /**
             * Callback after event is attached. eventDef may be used to remove event at later time.
             * @param fn
             */
            this.OnEventAttached = new Calysto.MulticastDelegate().AsFunc(this);
        }
        ForEach(action) {
            return super.ForEach(action).AsDomQuery();
        }
        Skip(count) {
            return super.Skip(count).AsDomQuery();
        }
        Take(count) {
            return super.Take(count).AsDomQuery();
        }
        SkipWhile(predicate) {
            return super.SkipWhile(predicate).AsDomQuery();
        }
        Reverse() {
            return super.Reverse().AsDomQuery();
        }
        Where(predicate) {
            return super.Where(predicate).AsDomQuery();
        }
        Select(selector) {
            return super.Select(selector).AsDomQuery();
        }
        Cast() {
            return this;
        }
        SelectMany(selector) {
            return super.SelectMany(selector).AsDomQuery();
        }
        Distinct(keySelector) {
            return super.Distinct(keySelector).AsDomQuery();
        }
        selectFilteredSingle(source, calystoSelector) {
            let origsrc = source;
            let newsrc = source;
            let selector1 = calystoSelector
                .replace(new RegExp("['\"]", "ig"), "") // remove ' and "
                .replace(new RegExp("(^[\\s]+)|([\\s]+$)", "ig"), "") // trim spaces from start and end of string
                .replace(new RegExp("([ ]*)([\\/\\<\\>\\!\\~\\^\\$\\*\\=]+)([ ]*)", "ig"), "$2") // remove spaces arround special chars
                .replace(new RegExp("[ ]+"), " "); // replace multiple spaces with single space
            let sett, ch, mm;
            let reader = new Calysto.SelectorReader(selector1);
            while (ch = reader.Pop()) {
                if (ch == '#' && (mm = reader.PopMatch(new RegExp("^([\\w\\-_]+)")))) {
                    // #id
                    newsrc = CreateIdQuery(newsrc, mm[1]);
                }
                else if (ch == '.' && (mm = reader.PopMatch(new RegExp("^([\\w\\-_]+)")))) {
                    // .class
                    newsrc = CreateClassQuery(newsrc, mm[1]);
                }
                else if (ch == ' ') {
                    // descendant
                    newsrc = newsrc.DescendantNodes();
                }
                else if (ch == '/' && reader.Peek() == '/' && reader.Peek(1) != '/') // descendants, double //
                 {
                    // descendant
                    reader.Pop(); // pop next / too
                    newsrc = newsrc.DescendantNodes();
                }
                else if (ch == '*') {
                    newsrc = newsrc.Select(o => o); // must create select if the only statement is "*", this way we return all, not empty collection
                }
                else if (ch == '^') // ancestors, Calysto specific
                 {
                    newsrc = newsrc.AncestorNodes();
                }
                else if (ch == '<') // parent, << will create 2 times: .ParentNodes().ParentNodes()
                 {
                    newsrc = newsrc.ParentNodes();
                }
                else if (ch == '>') // children, eg. >>> wil create 3 times .ChildNodes().ChildNodes().ChildNodes()
                 {
                    newsrc = newsrc.ChildNodes();
                }
                else if (ch == '/' && reader.Peek() != '/') // children, x-path first level children
                 {
                    newsrc = newsrc.ChildNodes();
                }
                else if (ch == ':' && (mm = reader.PopMatch(new RegExp("^([\\w\\-_]+)([\\(]([^\\)]*)[\\)])*")))) {
                    // special attribute, eg. :take(10), :first, :first(5)
                    newsrc = CreateColonWordQuery(newsrc, mm[1], mm[3]);
                }
                else if (ch == '[' && (mm = reader.PopMatch(new RegExp("^[ ]*([\\w\\-_]+)" + "[ ]*" + "([<>\\!\\=\\~\\^\\$\\*]*)" + "[ ]*" + "((([^\\[\\]])*(\\[\\d+\\])*)*)" + "[ ]*" + "\\]")))) {
                    // attribute value may have indexed property: TransakcijskiRacuni[4].IBAN[1].dva[3].nesto
                    //"name=TransakcijskiRacuni[4].IBAN[1].dva[3].nesto][color=blue]".match(new RegExp("^[ ]*([\\w\\-_]+)" + "[ ]*" + "([<>\\!\\=\\~\\^\\$\\*]*)" + "[ ]*" + "((([^\\[\\]])*(\\[\\d+\\])*)*)" + "[ ]*" + "\\]"))
                    // '[attribute="value"]' // '[attribute == "value"]' // // '[attribute != "value"]' // '[attribute >= value]'
                    newsrc = CreateAttributeQuery(newsrc, mm[1], mm[2], mm[3]);
                }
                else if ((mm = reader.PopMatch(new RegExp("^([\\w\\-_]+)"), -1))) // origin -1 to include current ch in match
                 {
                    // tag name
                    newsrc = CreateTagQuery(newsrc, mm[1]);
                }
                else {
                    // unknown
                    throw new Error("Unsupported calystoSelector (" + (selector1) + ")");
                }
            }
            // if newsrc == origsrc, nothing was selected by calystoSelector, return an empty eneumerable
            if (newsrc == origsrc) {
                newsrc = DomQuery.FromArray([]);
            }
            return newsrc;
        }
        /**
            operates on current document.all and select elements by calystoSelector as document.all.Query(args)
         * @param calystoSelector lambda or css calystoSelector:
TAG name: html, body...
ID: #idvalue...
CLASS: .mydiv, a.mydiv...
ATTRIBUTES: [name] (contains attribute), [name=value], [name &gt; value], ==, =, <, >, !=, <>, [name*=value] (contains value), [name^=value] (starts with value), [name$=value] (ends with value)...
TRAVERSING: * (all), space or // (descendants), / (children), ^ (ancestors), >>> (n-th level children), << (n-th level parent) :first(n) :last(n) :skip(n) :take(n) :reverse() :exact(n), with or without (n), if there is no (n), default n == 1
Element state: :hidden, :visible</para>
from x-path: :ancestor :descendant :child :parent :next-siblings :previous-siblings
         */
        Query(calystoSelector) {
            return this.QueryWorker(calystoSelector).Cast().AsDomQuery();
        }
        QueryWorker(calystoSelector) {
            /// <summary>
            /// filter current items by calystoSelector
            /// </summary>
            /// <param name="calystoSelector" type="string">
            ///		lambda or css calystoSelector:
            ///		<para>TAG name: html, body...</para>
            ///		<para>ID: #idvalue...</para>
            ///		<para>CLASS: .mydiv, a.mydiv...;</para>
            ///		<para>ATTRIBUTES: [name] (contains attribute), [name=value], [name &gt; value], ==, =, &lt;, &gt;, !=, &lt;&gt;, [name*=value] (contains value), [name^=value] (starts with value), [name$=value] (ends with value)...</para>
            ///		<para>TRAVERSING: * (all), space or // (descendants), / (children), ^ (ancestors), &gt;&gt;&gt; (n-th level children), &lt;&lt; (n-th level parent) :first(n) :last(n) :skip(n) :take(n) :reverse() :exact(n), with or without (n), if there is no (n), default n == 1</para>
            ///		<para>from x-path: :ancestor :descendant :child :parent :next-siblings :previous-siblings</para>
            /// </param>
            if (!calystoSelector) {
                // we should create new instance maybe
                return this;
            }
            var source = this;
            if ((typeof (calystoSelector) == "string" && calystoSelector.indexOf("=>") > 0) || typeof (calystoSelector) == "function") {
                // already is lambda expression or function
                let fn1 = Calysto.Utility.Expressions.CompileLambdaExpression(calystoSelector);
                return source.Where(fn1);
            }
            // *********************************************************
            // multiple calystoSelector processor
            // split by comma, but do not split by comma inside (...), eg. :not(div, a, body)
            var calystoSelectorsArr = [];
            var currPart = "";
            var digCount = 0;
            for (var n = 0; n < calystoSelector.length; n++) {
                var ch = calystoSelector.charAt(n); // IE8 and older requires charAt
                if (ch == ')') {
                    digCount--;
                    currPart += ch;
                }
                else if (ch == '(') {
                    digCount++;
                    currPart += ch;
                }
                else if (ch == ',' && digCount == 0) {
                    // split
                    calystoSelectorsArr.push(currPart);
                    currPart = "";
                }
                else {
                    currPart += ch;
                }
            }
            if (currPart.length > 0) {
                calystoSelectorsArr.push(currPart);
            }
            ////var calystoSelectorsArr = calystoSelector.split(","); //  " body5 div.noa, form div[id='asdc'], body div#Div1.klasa, div.collapsed.expanded,  ";
            if (calystoSelectorsArr.length > 1) {
                var newSources = null;
                for (var n = 0; n < calystoSelectorsArr.length; n++) {
                    var sel = calystoSelectorsArr[n].replace(new RegExp("((^[ ,]+)|([ ,]+$))", "ig"), ""); // tim chars
                    if (sel != null && sel != "") {
                        var tmpnewsrc = this.selectFilteredSingle(source, sel);
                        if (!newSources) {
                            newSources = tmpnewsrc;
                        }
                        else {
                            newSources = newSources.Concat(tmpnewsrc);
                        }
                    }
                }
                return newSources;
            }
            else {
                return this.selectFilteredSingle(source, calystoSelector);
            }
            // *********************************************************
        }
        ParentNodes(calystoSelector) {
            /// <summary>Parent nodes only</summary>
            /// <param name="calystoSelector">lambda or css calystoSelector</param>
            return this
                .Where(o => !!o.parentNode)
                .Select(o => o.parentNode)
                .Query(calystoSelector);
        }
        AncestorNodes(calystoSelector) {
            /// <summary>All ancestors</summary>
            /// <param name="calystoSelector">lambda or css calystoSelector</param>
            return this
                .SelectMany(function (o) { return GetAncestors(o); })
                .Select(o => o)
                .Query(calystoSelector);
        }
        ChildNodes(calystoSelector) {
            /// <summary>Child nodes only</summary>
            /// <param name="calystoSelector">lambda or css calystoSelector</param>
            return this
                .Where(o => o.childNodes && o.childNodes.length > 0) // text nodes doesn't have childNodes property
                .SelectMany(o => o.childNodes)
                .Query(calystoSelector);
        }
        getDescendants(curr) {
            if (curr && curr.childNodes && curr.childNodes.length > 0) {
                if (curr.nodeType && curr.getElementsByTagName) {
                    return curr.getElementsByTagName("*"); // doesn't get text nodes, but doesn't matter, this is much faster way
                }
                else // text nodes can not be retrieved using getElementsByTagName
                 {
                    ////throw new Error("curr.getElementsByTagName is not supported");
                }
            }
            return null; // .SelectMany() can handle if null is returned
        }
        DescendantNodes(calystoSelector) {
            /// <summary>Descendant nodes</summary>
            /// <param name="calystoSelector">lambda or css calystoSelector</param>
            /// <param name="includeTextNodes">if true, select text nodes too, but it is much slower</param>
            // return children than concat children's children
            return this
                .SelectMany(node => this.getDescendants(node))
                .Query(calystoSelector);
        }
        NextSiblings(calystoSelector) {
            return this
                .Where(function (o) { return o && o.parentNode && o.parentNode.childNodes; })
                .SelectMany(function (o) {
                return DomQuery.FromArray(o.parentNode.childNodes).Select(o => o).SkipWhile(function (k) { return k != o; }).Skip(1).ToArray();
            })
                .Query(calystoSelector);
        }
        PreviousSiblings(calystoSelector) {
            return this
                .Where(function (o) { return o && o.parentNode && o.parentNode.childNodes; })
                .SelectMany(function (o) {
                return DomQuery.FromArray(o.parentNode.childNodes).Select(o => o).TakeWhile(function (k) { return k != o; }).ToArray();
            })
                .Reverse() // order nodes backward so first node in collection is first previous sibling
                .Query(calystoSelector);
        }
        WhereTagName(tagName) {
            /// <summary>case non-sensitive tagName</summary>
            /// <param name="tagName">tag name</param>
            if (!tagName) {
                throw new Error("WhereTagName requires tagName parameter");
            }
            tagName = tagName.toLowerCase();
            return this
                .Where(function (o) { return o.tagName && o.tagName.toLowerCase() == tagName; });
        }
        WhereAttribute(name, predicate) {
            /// <summary>filter items by attribute value</summary>
            /// <param name="name" type="String">case non-sensitive</param>
            /// <param name="predicate" type="String|Function|Null">function(stringValue){...}, lambda predicate to test attribute value. </param>
            if (!name) {
                throw new Error("WhereAttribute requires name parameter");
            }
            // o.getAttribute("name") will get attribute value
            // o.getAttributeNode("name") will get attribute node
            return this
                .Where(function (o) { return predicate(Calysto.Utility.Dom.GetAttribute(o, name)); });
        }
        WhereHasAttribute(name, hasIt = true) {
            /// <summary>
            /// Filter items by attribute
            /// </summary>
            /// <param name="name">attribute name</param>
            /// <param name="hasIt" type="Boolean">OPTIONAL. If not set, default is true.</param>
            return this
                .Where(function (o) { return Calysto.Utility.Dom.HasAttribute(o, name) == hasIt; });
        }
        WhereStyle(name, predicate) {
            /// <summary>filter items by style value</summary>
            /// <param name="name" type="String">case sensitive, valid css style name, camel case or with -</param>
            /// <param name="predicate" type="String|Function|Null">function(numericValue){return ...;}, or value=>... lambda predicate, values with px or % are parsed into numbers</param>
            if (!name) {
                throw new Error("WhereAttribute requires name parameter");
            }
            return this
                .Where(function (o) { return predicate(Calysto.Utility.Dom.GetComputedStyle(o, name).NumericValue); });
        }
        WhereId(idvalue) {
            /// <summary>where attribute obj.id='id', always case-sensitive</summary>
            /// <param name="id">Case sensitive dom element id.</param>
            if (!idvalue) {
                throw new Error("WhereId requires id parameter");
            }
            return this
                .WhereAttribute("id", function (o) { return o == idvalue; });
        }
        WhereHasClass(cssClass, hasIt = true) {
            /// <summary>where contains cssClass, always case-sensitive</summary>
            /// <param name="cssClass">Case sensitive css class name.</param>
            /// <param name="hasIt" type="Boolean">OPTIONAL. If not set, default is true.</param>
            if (!cssClass) {
                throw new Error("WhereHasClass requires cssClass parameter");
            }
            return this
                .Where(function (item) { return Calysto.Utility.Dom.HasClass(item, cssClass) == hasIt; });
        }
        SelectStyle(name) {
            /// <summary>
            /// Select NumericValue or StyleValue, which one is available first. Returns new Calysto.List with values.
            /// </summary>
            /// <param name="name">style property name</param>
            if (!name) {
                throw new Error("StyleValue requires name parameter");
            }
            return this
                .Select((item) => {
                var ss = Calysto.Utility.Dom.GetComputedStyle(item, name);
                return Calysto.Type.TypeInspector.IsNumber(ss.NumericValue) ? ss.NumericValue : ss.StyleValue;
            });
        }
        SelectStyleMap(mapObj) {
            /// <summary>
            /// Select NumericValue or StyleValue, which one is available first. Return new Calysto.List with objects who's properties are array names: [{name1:value1, name2:value2}, {name1: value, name2: value}, ...].
            /// </summary>
            /// <param name="mapObj"> object with names to be selected: {"width": null, "height": null}</param>
            /// <returns>TMap[]</returns>
            return this
                .Select((element) => {
                let obj = {};
                Calysto.Collections.ForEachOwnProperties(mapObj, (name) => {
                    var ss = Calysto.Utility.Dom.GetComputedStyle(element, name);
                    var num = Calysto.Type.NumberConverter.ToNumberOrDefault(ss.NumericValue, NaN, ".");
                    if (!Calysto.Type.TypeInspector.IsNumber(num))
                        num = ss.StyleValue;
                    obj[name] = num;
                });
                return obj;
            });
        }
        ;
        SelectDimensionsMap() {
            return this.SelectStyleMap(dimMap);
        }
        ApplyStyleMap(styleMap) {
            /// <summary>
            /// Set elements style.
            /// </summary>
            /// <param name="styleMap">{marginTop: 10, "margin-left": "22%"}</param>
            return this
                .ForEach(function (item, index) {
                for (var prop in styleMap) {
                    Calysto.Utility.Dom.SetStyleValue(item, prop, styleMap[prop]);
                }
            });
        }
        ApplyStyle(nameOrCssText, value) {
            /// <summary>
            /// Set style value. If value is eg. 20%, it will get current value first, than set 20% of current value.
            /// </summary>
            /// <param name="name">cssText or style name or style map {height:10, width:20}, case sensitive style name or camelCase name</param>
            /// <param name="value">if cssText used, value is empty, else style value</param>
            if (!nameOrCssText) {
                return this; // if value is "", to allow conditional eg.: doSet ? "display:none" : ""
            }
            if (arguments.length == 1) {
                if (typeof (nameOrCssText) == "string") {
                    return this
                        .ForEach((item, index) => {
                        if (item && item.style) {
                            // setting cssText in style object acts as real css: uses last value and ignores previous definitions of the same style-name
                            // works with all browsers
                            item.style.cssText += ";" + nameOrCssText;
                        }
                    });
                }
                else if (typeof (nameOrCssText) == "object") {
                    return this
                        .ApplyStyleMap(nameOrCssText);
                }
                else {
                    throw new Error("Invalid argument in ApplyStyle: " + nameOrCssText);
                }
            }
            else {
                return this
                    .ForEach(function (item, index) { Calysto.Utility.Dom.SetStyleValue(item, nameOrCssText, value); });
            }
        }
        ;
        SetOffsetSize(offsetWidth, offsetHeight) {
            /// <summary>
            /// Set elements offset dimensions by recalculating and setting style values.
            /// Size may be set only if element is visible
            /// </summary>
            /// <param name="offsetWidth" type="int">if value not int, won't be set</param>
            /// <param name="offsetHeight" type="int">if value not int, won't be set</param>
            // table, select, button grows inside
            return this
                .ForEach(function (el) {
                SetOffsetDimensions(el, offsetWidth, offsetHeight);
            });
        }
        /**
         * Fit each element into it's parent. Useful for elements with padding set so style.width can not be set to 100% to fit into parent.
         * @param fitWidth
         * @param fitHeight
         */
        FitIntoParent(fitWidth, fitHeight) {
            return this
                .ForEach(function (o) { o._calystoPrevPosition = o.style.position; })
                .ApplyStyle("position:absolute")
                .ForEach(function (o) {
                // we have to get dimensions for all elements while they have position:absolute
                var newW = Calysto.Utility.Dom.GetComputedStyle(o.parentNode, "width").NumericValue;
                var newH = Calysto.Utility.Dom.GetComputedStyle(o.parentNode, "height").NumericValue;
                SetOffsetDimensions(o, newW, newH);
            })
                .ForEach(function (o) {
                o.style.position = o._calystoPrevPosition || "";
                delete (o._calystoPrevPosition);
            });
        }
        /**
         * Select attribute value and return new Calysto.List with values.
         * @param name
         */
        SelectAttribute(name) {
            // get value
            return this
                .Select(function (item) {
                return Calysto.Utility.Dom.GetAttribute(item, name);
            });
        }
        ;
        /**
         * Return TMap[] (TMap for each element) with objects who's properties are names from array:
         * [{name1:value1, name2:value2}, {name1: value, name2: value}, ...]
         * @param mapObj object with names to be selected: {"width": null, "height": null}
         */
        SelectAttributeMap(mapObj) {
            return this
                .Select(function (item) {
                var obj = {};
                Calysto.Collections.ForEachOwnProperties(mapObj, name => {
                    obj[name] = Calysto.Utility.Dom.GetAttribute(item, name);
                });
                return obj;
            });
        }
        /**
         * Return dictionary {[key:attrName]: attrValue} for each element.
         * */
        SelectAttributesAll() {
            return this
                .Select(function (item) {
                var _a;
                let dic = {};
                let attributes1 = (_a = item) === null || _a === void 0 ? void 0 : _a.attributes;
                if (!attributes1)
                    return dic;
                for (let attr of attributes1)
                    dic[attr.name] = attr.value;
                return dic;
            });
        }
        SetAttribute(name, value, add = true) {
            /// <summary>
            /// set attribute value
            /// </summary>
            /// <param name="name">name is case non-sensitive</param>
            /// <param name="value"></param>
            /// <param name="add" type="Boolean" optional="true">OPTIONAL. If not set, default is true.</param>
            if (!name) {
                throw new Error("AttributeValue requires name parameter");
            }
            ////add = arguments.length < 3 || !!add;
            // set value
            return this
                .ForEach((item, index) => {
                if (add) {
                    Calysto.Utility.Dom.SetAttribute(item, name, value);
                }
                else {
                    Calysto.Utility.Dom.RemoveAttribute(item, name);
                }
            });
        }
        RemoveAttribute(name) {
            /// <summary>
            /// Remove attribute by name.
            /// </summary>
            /// <param name="name">Attribute name.</param>
            return this
                .SetAttribute(name, null, false);
        }
        SetInnerHtml(html) {
            /// <summary>
            /// convert value to string and set as innerHTML to every element in collection.
            /// </summary>
            /// <param name="html" type="String|Object|Any"></param>
            if (arguments.length == 0 || html == null || typeof (html) == "undefined") {
                html = "";
            }
            // use html + "" if html is not string
            return this
                .ForEach(function (el) {
                let h1 = html + "";
                el.innerHTML = h1;
                if (h1) {
                    ExecuteInsertedScripts([el]);
                }
            });
        }
        /**
         * If target element supports "value", will add content as value, else, will invoke ReplaceChildren
         * @param content
         */
        SetValueOrInnerHtml(content) {
            return this
                .ForEach(function (el) {
                let el1 = el;
                let tagName = el1.tagName.toLowerCase();
                switch (tagName) {
                    case "input":
                    case "select":
                    case "textarea":
                        el1.value = content;
                        break;
                    default:
                        el1.innerHTML = content;
                        ExecuteInsertedScripts([el1]);
                        break;
                }
            });
        }
        SetProperty(property, value) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="property" type="String"></param>
            /// <param name="value" type="Object|String|Number"></param>
            return this
                .ForEach(function (el) { el[property] = value; });
        }
        SetChecked(value) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="value" type="bool"></param>
            return this
                .SetProperty("checked", value);
        }
        AppendInnerHtml(html) {
            /// <summary>
            /// convert value to string and append to innerHTML of every element in collection.
            /// </summary>
            /// <param name="html" type="String|Object|Any"></param>
            if (arguments.length == 0 || html == null || typeof (html) == "undefined") {
                html = "";
            }
            // use html + "" if html is not string
            return this
                .ForEach(function (el) { el.innerHTML += html + ""; });
        }
        SelectInnerHtml() {
            /// <summary>
            /// Select innerHTML value from each element and returns new Calysto.List with values.
            /// </summary>
            return this
                .Select(function (el) { return el.innerHTML; });
        }
        SelectInnerText() {
            /// <summary>
            /// Select innerHTML value from each element and returns new Calysto.List with values.
            /// </summary>
            return this
                .Select(function (el) { return Calysto.Utility.Dom.GetInnerText(el); });
        }
        WhereText(textToSearch, ignoreCase) {
            if (!textToSearch) {
                throw new Error("WhereText requires textToSearch parameter");
            }
            textToSearch = ignoreCase ? textToSearch.toLowerCase() : textToSearch;
            return this
                .Where(function (item) { return item && GetTextValueOnly(item, ignoreCase).indexOf(textToSearch) >= 0; });
        }
        AddClass(cssClass, add = true) {
            /// <summary>
            /// Add css class to classes collection.
            /// </summary>
            /// <param name="cssClass"></param>
            /// <param name="add" type="Boolean" optional="true">OPTIONAL. If not set, default is true.</param>
            if (add) {
                return CssClass(this, "AddClass", cssClass);
            }
            else {
                return this.RemoveClass(cssClass);
            }
        }
        RemoveClass(cssClass) {
            /// <summary>
            /// Remove css class from classes collection.
            /// </summary>
            /// <param name="cssClass"></param>
            return CssClass(this, "RemoveClass", cssClass);
        }
        SetClass(cssClass) {
            /// <summary>
            /// Set css class value, removing previous values.
            /// </summary>
            /// <param name="cssClass"></param>
            return CssClass(this, "SetClass", cssClass);
        }
        ToggleClass(cssClass) {
            /// <summary>
            /// If doesn't exist, add class, else remove it.
            /// </summary>
            /// <param name="cssClass"></param>
            return CssClass(this, "ToggleClass", cssClass);
        }
        SelectClassNames() {
            /// <summary>
            /// Select class names as new Calysto.List;
            /// </summary>
            return this
                .SelectMany(function (el) {
                return el.className.match(new RegExp("[\\S]+", "g")); // returns array of matches
            });
        }
        /**
         * Test if element is visible in DOM, using style.display and offsetHeight and offsetWidth
         * @param isVisible
         */
        WhereVisible(isVisible = true) {
            /// <summary>
            /// Test if element is visible in DOM, using style.display and offsetHeight and offsetWidth
            /// </summary>
            /// <param name="isVisible" type="Boolean">OPTIONAL. If not set, default is true.</param>
            isVisible = arguments.length == 0 || !!isVisible;
            return this
                .Where(function (o) {
                return (Calysto.Utility.Dom.IsElementVisible(o)) == isVisible;
            });
        }
        /**
         * Test if element is visible in DOM and in viewport (on screen) only part
         * @param isVisible
         */
        WhereInViewPort(isVisible = true, onlyPart = true) {
            isVisible = arguments.length == 0 || !!isVisible;
            return this
                .Where(function (o) {
                return Calysto.Utility.Dom.IsElementVisible(o) == isVisible
                    && Calysto.Utility.Dom.IsElementInViewport(o, onlyPart) == isVisible;
            });
        }
        WhereEnabled(isEnabled = true) {
            /// <summary>
            /// Test if "disabled" attribute exists.
            /// </summary>
            /// <param name="isEnabled" type="Boolean">OPTIONAL. If not set, default is true.</param>
            isEnabled = arguments.length == 0 || !!isEnabled;
            return this
                .Where(function (o) {
                return !Calysto.Utility.Dom.HasAttribute(o, "disabled") == isEnabled;
            });
        }
        On(eventFullNameOrArr, callbackFunc, useCapture, triggCountMax) {
            /// <summary>
            /// bind event handler to current items
            /// </summary>
            /// <param name="eventFullName" type="String|Array">
            ///		<para>event name with class name, ex: click.one1.two2</para>
            ///		<para>event name or array of event names without 'on' on start (click, mouserover, mousemove,...)</para>
            ///		<para>may include namespace for simple removal as [eventType].[namespace]: click.my_one, click.mynode.divone</para>
            /// </param>
            /// <param name="callbackFunc">function(sender, event){ }, if not bound to different context, inside of function this == sender</param>
            /// <param name="useCapture">if true, use capture, trigger event before all other</param>
            /// <param name="triggCountMax">number of how many times to trigger, after that events are ignored</param>
            if (!callbackFunc) {
                // callback can't be null, throw exception or return this
                throw new Error("CallbackFunc can not be null");
                //return this;
            }
            if (Calysto.Type.TypeInspector.IsArray(eventFullNameOrArr)) {
                // if eventName array length == 0, return this
                var src = this;
                for (var n = 0; n < eventFullNameOrArr.length; n++) {
                    src = this.On(eventFullNameOrArr[n], callbackFunc, useCapture, triggCountMax);
                }
                return src; // return the latest src, it is only new enumerable with current items
            }
            var eventFullName = eventFullNameOrArr;
            if (eventFullName.indexOf("on") == 0) {
                eventFullName = eventFullName.substr(2);
            }
            // namespace
            var cb11 = callbackFunc;
            var parts = eventFullName.split(".");
            var evName = parts[0]; // leave event in array, later just add "mouseover" in front, if first value is "hover"
            if (evName == "enterKey") {
                parts.unshift("keydown");
                cb11 = function (sender, ev) {
                    if (Calysto.Event.IsEnterKey(ev)) {
                        return callbackFunc.call(sender, sender, ev);
                    }
                };
            }
            else if (evName == "escKey") {
                parts.unshift("keydown");
                cb11 = function (sender, ev) {
                    if (Calysto.Event.IsEscKey(ev)) {
                        return callbackFunc.call(sender, sender, ev);
                    }
                };
            }
            return this
                .ForEach((domElement, index) => {
                if (domElement) {
                    var cb = GetCBEncaps(cb11); // implement event.preventDefault() if callback func returns false value
                    if (evName == "hover") {
                        parts.unshift("mouseover");
                        cb = GetHoverCB(true, cb);
                    }
                    else if (evName == "hout") {
                        parts.unshift("mouseout");
                        cb = GetHoverCB(false, cb);
                    }
                    if (triggCountMax && triggCountMax > 0) {
                        cb = GetTriggCountCB(triggCountMax, cb);
                    }
                    var fnEncaps = (function (contextItem, cbFunc) {
                        // proxy method: since inside Calysto.Event.Append cb is invoked by the browser as cb.call(this, event) where this is current element
                        // Calysto event handlers always have 2 arguments: function(sender, event){...}
                        return (function (ev) {
                            //// contextItem === this
                            cbFunc.call(contextItem, contextItem, ev);
                        });
                    })(domElement, cb);
                    // attach event
                    let def = Calysto.Event.Attach(domElement, parts.join("."), fnEncaps, useCapture);
                    // callback on event is attached
                    this.OnEventAttached.Invoke(f => f(def));
                }
            });
        }
        RemoveEvent(eventFullName) {
            /// <summary>
            /// Remove event by eventFullName (event type.namespace). Can remove previously added with .On(...)
            /// </summary>
            /// <param name="eventFullName">
            ///		<para>full name including namespace, or namespace only, or name only</para>
            ///		<para>full event name to be removed, without on: (click, change,...)</para>
            ///		<para>may include namespace for simple removal as [eventType].[namespace]: click.my_one, click.mynode.divone</para>
            /// </param>
            /// <param name="callbackFunc" optional="true">optional, original callback func. if not provided, will remove all events by eventFullName</param>
            /// <param name="useCapture" optional="true"></param>
            // can not use callbackFunc because we attach encapsulated function, not the original one
            return this
                .ForEach(function (domElement, index) {
                if (domElement) {
                    domElement.$$calysto_EventsArr.Where(o => o.eventFullName == eventFullName).ForEach(o => o.removeEvent());
                }
            });
        }
        DispatchEvent(event) {
            /// <summary>
            /// Dispatch event or event type on element el.
            /// </summary>
            /// <param name="event" type="MouseEvent|KeyboardEvent|String">Event object or string event type name</param>
            return this.ForEach(function (el, index) {
                Calysto.Event.DispatchEvent(el, event);
            });
        }
        OnHover(onOver, onOut) {
            /// <summary>
            /// Hover event on mouse enter or mouse leave an element.
            /// </summary>
            /// <param name="onOver">function(sender, event){...}</param>
            /// <param name="onOut">function(sender, event){...}</param>
            var tt = this;
            if (onOver) {
                tt = tt.On("hover", onOver);
            }
            if (onOut) {
                tt = tt.On("hout", onOut);
            }
            return tt;
        }
        OnChange(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("change", callbackFunc);
        }
        /**
         * Monitor for changes in value or checked property in regular intervals.
         * Default pooling interval = 100 ms.
         * @param callbackFunc
         * @param intervalMs default = 100 ms
         */
        OnChangePooling(callbackFunc, intervalMs = 100) {
            let key = Calysto.Utility.Generators.GeneratePassword(10);
            let valueKey = "__value_" + key;
            let checkedKey = "__checked_" + key;
            let items = this.ForEach(o => {
                o[valueKey] = o["value"];
                o[checkedKey] = o["checked"];
            }).ToList();
            let id = setInterval(() => {
                items.ForEach(o => {
                    if (o[valueKey] != o["value"] || o[checkedKey] != o["checked"]) {
                        o[valueKey] = o["value"];
                        o[checkedKey] = o["checked"];
                        callbackFunc(o, {
                            type: "change",
                            target: o,
                            currentTarget: o
                        });
                    }
                });
            }, 100);
            return new PoolingState(items.AsDomQuery(), id);
        }
        OnInput(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("input", callbackFunc);
        }
        OnClick(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("click", callbackFunc);
        }
        OnDblClick(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("dblclick", callbackFunc);
        }
        OnMouseUp(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("mouseup", callbackFunc);
        }
        OnMouseDown(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("mousedown", callbackFunc);
        }
        OnMouseOver(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            return this.On("mouseover", callbackFunc);
        }
        OnMouseOut(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("mouseout", callbackFunc);
        }
        OnLeftMouseDown(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            let tmp111 = this;
            function cb(sender, event) {
                if (Calysto.Event.IsLeftMouseButton(event)) {
                    callbackFunc.apply(tmp111, arguments);
                }
            }
            return this.On("mousedown.leftmousedown", cb);
        }
        OnRightMouseDown(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            let tmp111 = this;
            function cb(sender, event) {
                if (Calysto.Event.IsRightMouseButton(event)) {
                    callbackFunc.apply(tmp111, arguments);
                }
            }
            return this.On("mousedown.rightmousedown", cb);
        }
        OnMouseMove(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("mousemove", callbackFunc);
        }
        OnFocus(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("focus", callbackFunc);
        }
        OnBlur(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("blur", callbackFunc);
        }
        OnKeyDown(callbackFunc) {
            /// <summary>
            /// has NO ev.charCode, only ev.keyCode, triggers on any key press (eg. shift, ctrl, F1...)
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("keydown", callbackFunc);
        }
        OnKeyUp(callbackFunc) {
            /// <summary>
            /// has NO ev.charCode, only ev.keyCode, triggers on any key press (eg. shift, ctrl, F1...)
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("keyup", callbackFunc);
        }
        OnKeyPress(callbackFunc) {
            /// <summary>
            /// has ev.charCode and ev.keyCode, triggers on chars only, doesn't trigger with special keys eg. shift, ctrl, F1
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("keypress", callbackFunc);
        }
        OnEnter(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("enterKey", callbackFunc);
        }
        OnEscKey(callbackFunc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="callbackFunc">function(sender, event){...}, this inside is sender</param>
            return this.On("escKey", callbackFunc);
        }
        /**
         * Deep clone current nodes and return cloned nodes only.
         * @returns
         */
        CloneNodes() {
            /// <summary>
            /// Deep clone current nodes and return cloned nodes only.
            /// </summary>
            return this
                .Where(o => !!o.cloneNode)
                .Select(o => o.cloneNode(true));
        }
        /**
         * disconnect nodes from DOM
         * @returns
         */
        RemoveFromDom() {
            /// <summary>
            /// disconnect nodes from DOM
            /// </summary>
            return this
                .ForEach(function (item, index) {
                Calysto.Utility.Dom.RemoveNodeFromDom(item);
            });
        }
        /**
         * replace each node with new html or element. if content is null, remove node from dom. Returnes new (replacement) nodes.
         * @param {any[]} ...content
         * @returns
         */
        ReplaceWith(...content) {
            /// <summary>
            /// replace each node with new html or element. if content is null, remove node from dom. Returnes new (replacement) nodes.
            /// </summary>
            /// <param name="content"></param>
            var _a;
            var res = AddOrModify("InsertBefore", this.ToArray(), arguments);
            // remove current items
            (_a = res.ThisItems) === null || _a === void 0 ? void 0 : _a.ForEach((o, n) => Calysto.Utility.Dom.RemoveNodeFromDom(o));
            // return new items
            return res.NewItems.AsEnumerable().AsDomQuery();
        }
        /**
         * Replace each current collection node's children with content. if content is null, remove children only. Returns current collection.
         * @param {any[]} ...content
         * @returns
         */
        ReplaceChildren(...content) {
            /// <summary>
            /// Replace each current collection node's children with content. if content is null, remove children only. Returns current collection.
            /// </summary>
            /// <param name="content"></param>
            var res = AddOrModify("ReplaceChildrenWith", this.ToArray(), arguments);
            return this;
        }
        RemoveChildren() {
            return this.ReplaceChildren();
        }
        /**
         * Add content as last child to each node in current collection. Returns current collection.
         * @param {any[]} ...content
         * @returns
         */
        AddChildren(...content) {
            /// <summary>
            /// Add content as last child to each node in current collection. Returns current collection.
            /// </summary>
            /// <param name="content">html, single dom element, array of dom element, Calysto.DomQuery elements</param>
            var res = AddOrModify("AddChildren", this.ToArray(), arguments);
            return this;
        }
        /**
         * Insert content as first child to each node in current collection. Returns current collection.
         * @param {any[]} ...content
         * @returns
         */
        InsertChildren(...content) {
            /// <summary>
            /// Insert content as first child to each node in current collection. Returns current collection.
            /// </summary>
            /// <param name="content">html, dom element or array of dom element</param>
            var res = AddOrModify("InsertChildren", this.ToArray(), [].AddRange(arguments).Reverse());
            return this;
        }
        /**
         * Insert content before every node in current collection. Returns current collection.
         * @param {any[]} ...content
         * @returns
         */
        InsertBefore(...content) {
            /// <summary>
            /// Insert content before every node in current collection. Returns current collection.
            /// </summary>
            /// <param name="content"></param>
            var res = AddOrModify("InsertBefore", this.ToArray(), arguments);
            return this;
        }
        /**
         * Insert content after every node in current collection. Returns current collection.
         * @param {any[]} ...content
         * @returns
         */
        InsertAfter(...content) {
            /// <summary>
            /// Insert content after every node in current collection. Returns current collection.
            /// </summary>
            /// <param name="content"></param>
            var res = AddOrModify("InsertAfter", this.ToArray(), [].AddRange(arguments).Reverse());
            return this;
        }
        /**
         * Insert current collection nodes as first children into nodes specified by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied
         * @param {string | HTMLElement} calystoSelector
         * @returns
         */
        InsertAsChildrenTo(calystoSelector) {
            /// <summary>
            /// <para>Insert current collection nodes as first children into nodes specified by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied.</para>
            /// </summary>
            /// <param name="calystoSelector"></param>
            var destinationArr = Calysto.DomQuery.FromSelector(calystoSelector).ToArray();
            var thisArr = this.Reverse().ToArray();
            var res = AddOrModify("InsertChildren", destinationArr, thisArr);
            return res.NewItems.AsEnumerable().AsDomQuery();
        }
        /**
         * Add current collection as last children into nodes specified by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied
         * @param {string | HTMLElement} calystoSelector
         * @returns
         */
        AddAsChildrenTo(calystoSelector) {
            /// <summary>
            /// <para>Add current collection as last children into nodes specified by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied.</para>
            /// </summary>
            /// <param name="calystoSelector"></param>
            var destinationArr = Calysto.DomQuery.FromSelector(calystoSelector).ToArray();
            var thisArr = this.ToArray();
            var res = AddOrModify("AddChildren", destinationArr, thisArr);
            return res.NewItems.AsEnumerable().AsDomQuery();
        }
        /**
         * Insert current collection before nodes selected by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied
         * @param {string | HTMLElement} calystoSelector
         * @returns
         */
        InsertBeforeTo(calystoSelector) {
            /// <summary>
            /// <para>Insert current collection before nodes selected by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied.</para>
            /// </summary>
            /// <param name="calystoSelector"></param>
            var destinationArr = Calysto.DomQuery.FromSelector(calystoSelector).ToArray();
            var thisArr = this.ToArray();
            var res = AddOrModify("InsertBefore", destinationArr, thisArr);
            return res.NewItems.AsEnumerable().AsDomQuery();
        }
        /**
         * Insert current collection after nodes selected by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied
         * @param {string | HTMLElement} calystoSelector
         * @returns
         */
        InsertAfterTo(calystoSelector) {
            /// <summary>
            /// <para>Insert current collection after nodes selected by calystoSelector. Returns added nodes, including cloned ones if there were cloned or multiplied.</para>
            /// </summary>
            /// <param name="calystoSelector"></param>
            var destinationArr = Calysto.DomQuery.FromSelector(calystoSelector).ToArray();
            var thisArr = this.ToArray();
            var res = AddOrModify("InsertAfter", destinationArr, thisArr);
            return res.NewItems.AsEnumerable().AsDomQuery();
        }
        /**
         * Sleep execution with setTimeout. Can be used for branching. When expired, execute onExpired.call(this, this). "this" is sent both as parameter and as context.
         * @param {number} sleepMs
         * @param {(sender} onExpired function to execute onExpired.call(this, this)
         * @returns
         */
        Sleep(sleepMs, onExpired) {
            var aa = this;
            setTimeout(function () { onExpired.call(aa, aa); }, sleepMs);
            return this;
        }
        /**
         * Export current elements to animator. Animate from current style settings to finalMap settings.
         * @param finalMap final values to animate to, eg. {height:40, opacity:25, marginTop: 54}
         */
        ToAnimator(finalMap) {
            if (!finalMap)
                throw new Error("ToAnimator requires finalMap");
            var animator = new Calysto.Animator();
            this.ForEach((item, index) => {
                for (var prop in finalMap) {
                    animator.AddElement(item, prop, finalMap[prop]);
                }
            });
            return animator;
        }
        SetSelectable(isSelectable = true) {
            /// <summary>
            /// Add onselectstart handler which returns false.
            /// </summary>
            /// <param name="isSelectable" type="Boolean">OPTIONAL. If not set, default is true.</param>
            ////.calystoNoUserSelect {
            ////	-webkit-touch-callout: none;
            ////	-webkit-user-select: none;
            ////	-khtml-user-select: none;
            ////	-moz-user-select: none;
            ////	-ms-user-select: none;
            ////	user-select: none;
            ////}
            // Formal syntax: none | text | all | element
            //////// use css class because if it is set directly into style, it can not be removed
            //////var val = isSelectable ? "" : "none"; //empty value for removal
            //////var pp = ["-khtml-", "-moz-", "-ms-", "-o-", ""];
            //////var arr = ["-webkit-user-select:" + val];
            //////for(var n = 0; n < pp.length; n++)
            //////{
            //////	arr.push(pp[n] + "user-select:" + val);
            //////}
            //////arr.push("");
            //////// first create string and apply it using element.style.cssText += this, if values are applyed one by one, they will be overriden by the last one and it won't work in all browsers
            //////return this.ApplyStyle(arr.join(";"));
            if (isSelectable) {
                return this.RemoveClass("calystoNoUserSelect");
            }
            else {
                return this.AddClass("calystoNoUserSelect"); // class is defined in ThemeBase
            }
        }
        SetEnabled(isEnabled = true) {
            /// <summary>
            /// Set attribute disabled=disabled and disable onclick handler. LIMITATION: "disabled" has to be set on all descendants.
            /// </summary>
            /// <param name="isEnabled" type="Boolean">OPTIONAL. If not set, default is true.</param>
            return this
                .ForEach(function (item, index) {
                Calysto.Utility.Dom.SetEnabled(item, isEnabled);
            });
        }
        SetVisible(isVisible = true) {
            /// <summary>
            /// Set style display="none", else set display="".
            /// </summary>
            /// <param name="isVisible" type="Boolean">
            /// false: apply style.display = "none"<br/>
            /// true: or undefined: apply style.display = ""<br/>
            /// </param>
            return this
                .ForEach((item, index) => {
                if (item && item.style) {
                    if (isVisible) {
                        if (item.style.display == "none") {
                            item.style.display = ""; // first set "", then thest for visibility
                        }
                        var val = Calysto.Utility.Dom.GetComputedStyle(item, "display").StyleValue;
                        if (val == "none") {
                            // value is set in css, override it
                            item.style.display = item.tagName.toLowerCase() == "div" ? "block" : "inherit";
                        }
                        if (item.style.visibility == "hidden") {
                            item.style.visibility = ""; // first set "", then test for visibility
                        }
                        var val = Calysto.Utility.Dom.GetComputedStyle(item, "visibility").StyleValue;
                        if (val == "hidden" || val == "collapse") {
                            // value is set in css, override it
                            item.style.visibility = "inherit";
                        }
                    }
                    ////else if(item.style && "visibility" in item.style)
                    ////{
                    ////	item.style.visibility = "hidden"; // hidden makes element inivisible, but still reserves width & height in DOM
                    ////}
                    else {
                        // old compatibility
                        item.style.display = "none";
                    }
                }
            });
        }
        SetReadOnly(isReadonly = true) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="isReadonly">default: true</param>
            if (isReadonly) {
                return this.SetAttribute("readonly", "readonly");
            }
            else {
                return this.RemoveAttribute("readonly");
            }
        }
        /**
         * Set opacity
         * @param value 0.0 - 1.0 (full visibility = 1.0)
         */
        SetOpacity(value) {
            // ako je poslan postotak do 100%
            if (value > 1)
                value = value / 100;
            /*filter for For IE8 and earlier */
            return this
                .ApplyStyle("filter", "alpha(opacity=" + (value * 100.0) + ")")
                .ApplyStyle("opacity", value);
        }
        SetClip(clipValue) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="clipValue" type="object|string">already parsed into object, or string: "margins(100% 0 0 0)" or "rect:(10px 100px 50px 53px)" </param>
            return this
                .ForEach(function (o) { Calysto.Utility.Dom.SetClip(o, clipValue); });
        }
        SetTransition(propertyName = "all", durationMs = 0, func = "linear", delayMs = 0) {
            /// <summary>
            /// single line transition
            /// </summary>
            /// <param name="propertyName">"none" to remove transition (optional, default: all) Specifies the name of the CSS property the transition effect is for. Css default is all.</param>
            /// <param name="durationMs">(optional, default: 400ms) Specifies how many seconds or milliseconds the transition effect takes to complete. Css default is 0</param>
            /// <param name="delayMs">(optional, default: 0) Defines when the transition effect will start. css default is 0</param>
            /// <param name="func"> (optional, default: linear)
            ///		<para>linear	Specifies a transition effect with the same speed from start to end (equivalent to cubic-bezier(0,0,1,1))</para>
            ///		<para>(default) ease	Specifies a transition effect with a slow start, then fast, then end slowly (equivalent to cubic-bezier(0.25,0.1,0.25,1))</para>
            ///		<para>ease-in	Specifies a transition effect with a slow start (equivalent to cubic-bezier(0.42,0,1,1))</para>
            ///		<para>ease-out	Specifies a transition effect with a slow end (equivalent to cubic-bezier(0,0,0.58,1))</para>
            ///		<para>ease-in-out	Specifies a transition effect with a slow start and end (equivalent to cubic-bezier(0.42,0,0.58,1))</para>
            ///		<para>cubic-bezier(n,n,n,n)	Define your own values in the cubic-bezier function. Possible values are numeric values from 0 to 1</para>
            /// </param>
            if (arguments.length < 1) {
                propertyName = "all";
            }
            if (arguments.length < 2) {
                durationMs = 400;
            }
            if (arguments.length < 3) {
                func = "linear";
            }
            if (arguments.length < 4) {
                delayMs = 0;
            }
            var val = propertyName == "none" ? "" : (propertyName + " " + durationMs + "ms" + " " + func + " " + delayMs + "ms");
            this.ApplyStyle("transition", val);
            this.ApplyStyle("-webkit-transition", val);
            return this;
        }
        SetTransform(transformFunc) {
            /// <summary>
            /// <para>Remove any previous transform and apply new.</para>
            /// <para>angle must have deg: eg. 45deg.</para>
            /// <para>x,y,z values must have px units.</para>
            /// <para>scale has no units</para>
            /// </summary>
            /// <param name="transformFunc">
            ///		<para>none</para>
            ///		<para>matrix(n,n,n,n,n,n) 2D transform</para>
            ///		<para>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 3D transform</para>
            ///		<para>translate(x,y)</para>
            ///		<para>translate3d(x,y,z)</para>
            ///		<para>translateX(x)</para>
            ///		<para>translateY(y)</para>
            ///		<para>translateZ(z)</para>
            ///		<para>scale(x,y)</para>
            ///		<para>scale3d(x,y,z)</para>
            ///		<para>scaleX(x)</para>
            ///		<para>scaleY(y)</para>
            ///		<para>scaleZ(z)</para>
            ///		<para>rotate(angle)</para>
            ///		<para>rotate3d(x,y,z,angle)</para>
            ///		<para>rotateX(angle)</para>
            ///		<para>rotateY(angle)</para>
            ///		<para>rotateZ(angle)</para>
            ///		<para>skew(x-angle,y-angle)</para>
            ///		<para>skewX(angle)</para>
            ///		<para>skewY(angle)</para>
            ///		<para>perspective(n)</para>
            /// </param>
            if (arguments.length == 0 || transformFunc == "none") {
                transformFunc = "";
            }
            for (var n = 0; n < transforms.length; n++) {
                this.ApplyStyle(transforms[n], transformFunc);
            }
            return this;
        }
        ApplyTransform(transformFunc) {
            /// <summary>
            /// <para>Get current transform and apply modification to existing transform only.</para>
            /// <para>angle must have deg: eg. 45deg.</para>
            /// <para>x,y,z values must have px units.</para>
            /// <para>scale has no units</para>
            /// </summary>
            /// <param name="transformFunc">
            ///		<para>none</para>
            ///		<para>matrix(n,n,n,n,n,n) 2D transform</para>
            ///		<para>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 3D transform</para>
            ///		<para>translate(x,y)</para>
            ///		<para>translate3d(x,y,z)</para>
            ///		<para>translateX(x)</para>
            ///		<para>translateY(y)</para>
            ///		<para>translateZ(z)</para>
            ///		<para>scale(x,y)</para>
            ///		<para>scale3d(x,y,z)</para>
            ///		<para>scaleX(x)</para>
            ///		<para>scaleY(y)</para>
            ///		<para>scaleZ(z)</para>
            ///		<para>rotate(angle)</para>
            ///		<para>rotate3d(x,y,z,angle)</para>
            ///		<para>rotateX(angle)</para>
            ///		<para>rotateY(angle)</para>
            ///		<para>rotateZ(angle)</para>
            ///		<para>skew(x-angle,y-angle)</para>
            ///		<para>skewX(angle)</para>
            ///		<para>skewY(angle)</para>
            ///		<para>perspective(n)</para>
            /// </param>
            if (arguments.length == 0 || transformFunc == "none") {
                return this.SetTransform("none");
            }
            var fnames = transformFunc.match(new RegExp("[\\w]+", "ig"));
            return this.ForEach((o) => {
                if (o && o.style && fnames && fnames.length > 0) {
                    var newval = transformFunc;
                    var curr = o.style.transform || o.style.msTransform || o.style.webkitTransform;
                    if (curr) {
                        // if new val is compund, eg.: translate(100px, -100px) rotate(170deg) scale(0.2)"
                        // remove previous and add new
                        newval = curr.replace(new RegExp("(" + fnames.join("|") + ")" + "[\\s]*\\([^\\)]*\\)", "ig"), "") + " " + transformFunc;
                    }
                    ////console.log("set: " + newval);
                    Calysto.DomQuery.FromSelector(o).SetTransform(newval);
                }
            });
        }
        ;
        SelectTransform() {
            /// <summary>
            /// Select transform value of current elements and return new Calysto.List with string values.
            /// </summary>
            return this.Select(function (o) {
                return Calysto.Utility.Dom.SelectTransform(o);
            });
        }
        SetLinearGradient(degrees, color0, color1, color3, etc) {
            /// <summary>
            /// 
            /// </summary>
            /// <param name="degrees" type="Int|String">
            ///		<para>none to remove gradient</para>
            ///		<para>0 is from bottom to top, negative i CCV, pozitive CV</para>
            /// </param>
            /// <param name="color0" type="String">color value or color value and position in percent starting from start (0% is start, 100% is end) eg. red, blue, or red 10%, blue 20%, etc</param>
            /////* background-image: linear-gradient(0deg, color percent, color percent, etc)*/
            ////background-color: #F07575; /* fallback color if gradients are not supported */
            ////background-image: -webkit-linear-gradient(top, hsl(0, 80%, 70%), #bada55 50%, red 100%); /* For Chrome and Safari */
            ////background-image: -moz-linear-gradient(top, hsl(0, 80%, 70%), #bada55); /* For old Fx (3.6 to 15) */
            ////background-image: -ms-linear-gradient(top, hsl(0, 80%, 70%), #bada55); /* For pre-releases of IE 10*/
            ////background-image: -o-linear-gradient(top, hsl(0, 80%, 70%), #bada55); /* For old Opera (11.1 to 12.0) */ 
            ////background-image: linear-gradient(to bottom, hsl(0, 80%, 70%), #bada55); /* Standard syntax; must be last */
            if (arguments.length == 0 || degrees == "none") {
                return this.ApplyStyle("background-color", "").ApplyStyle("background-image", "");
            }
            degrees = parseFloat(degrees);
            // all browsers uses clock-wise orientataion and 0 is at bottom
            // safari uses CCW orientation and 0 is at left
            if (Calysto.Features.GetBrowser().Kind == Calysto.Features.BrowserKindEnum.Safari) {
                degrees = (degrees - 90) * (-1);
            }
            degrees += "deg";
            var arr = [degrees];
            for (var n = 1; n < arguments.length; n++) {
                arr.push(arguments[n]);
            }
            var str = arr.join(", ");
            var pp = ["-webkit-", "-moz-", "-ms-", "-o-", ""];
            var ss = ["background-color:" + (color0 || "").split(" ")[0]]; // background-color if gradient is not supported
            for (var n = 0; n < pp.length; n++) {
                ss.push("background-image:" + pp[n] + "linear-gradient(" + str + ")");
            }
            ss.push("");
            console.log(ss.join(";"));
            // create complete string first, than assign it as style.cssText += ..., if assigned one by one, it will override each other and the last one will be set as final, so it wont' work in all browsers
            this.ApplyStyle(ss.join(";"));
            return this;
        }
        ToAnimatorScrollIntoView(alignToTop = false) {
            /// <summary>
            /// Returns Animator instance. Must invoke .Start()
            /// </summary>
            /// <param name="alignToTop" optional="true" type="boolean">default: false, will align to bottom</param>
            let animator = new Calysto.Animator();
            this.ForEach((item, index) => {
                let el1 = item;
                let scrollableAncestor = Calysto.Utility.Dom.GetScrollableAncestors(el1)[0];
                if (!scrollableAncestor)
                    return;
                let elPosition = Calysto.Utility.Dom.GetElementScreenPosition(el1);
                let elAncestorPosition = Calysto.Utility.Dom.GetElementScreenPosition(scrollableAncestor);
                // top align:
                let scrollTop = elPosition.top - elAncestorPosition.top;
                let scrollLeft = elPosition.left - elAncestorPosition.left;
                if (!alignToTop) {
                    // bottom align
                    scrollTop += scrollableAncestor.clientHeight - el1.clientHeight;
                    scrollLeft += scrollableAncestor.clientHeight - el1.clientWidth;
                }
                ////console.log(elPosition, elAncestorPosition, { scrollTop, scrollLeft });
                //// IE scrolls documentElement, other scrolls body
                //// always scroll body and documentElement, FF and IE works with documentElement, Chrome with body
                //animator.AddElement(document.body, "scrollTop", scrollTop);
                //animator.AddElement(document.body, "scrollLeft", scrollLeft);
                //animator.AddElement(document.documentElement, "scrollTop", scrollTop);
                //animator.AddElement(document.documentElement, "scrollLeft", scrollLeft);
                animator.AddElement(scrollableAncestor, "scrollTop", scrollTop);
                animator.AddElement(scrollableAncestor, "scrollLeft", scrollLeft);
            });
            return animator;
        }
        /*
        instance.SetCentered = function ()
        {
            /// <summary>
            /// Set current elements centered into their parents
            /// </summary>

            return this.Where("o=>o.parentNode").ForEach(function (el, index)
            {
                el.style.marginLeft = ((el.parentNode.clientWidth - el.offsetWidth) / 2) + "px";
                el.style.marginTop = ((el.parentNode.clientHeight - el.offsetHeight) / 2) + "px";
            });
        };
        */
        static FromArray(arr) {
            return new DomQuery(() => Calysto.CalystoEnumerator.From(arr));
        }
        /**
            operates on current document.all and select elements by calystoSelector as document.all.Query(args)
         * @param calystoSelector lambda or css calystoSelector:
TAG name: html, body...
ID: #idvalue...
CLASS: .mydiv, a.mydiv...
ATTRIBUTES: [name] (contains attribute), [name=value], [name &gt; value], ==, =, <, >, !=, <>, [name*=value] (contains value), [name^=value] (starts with value), [name$=value] (ends with value)...
TRAVERSING: * (all), space or // (descendants), / (children), ^ (ancestors), >>> (n-th level children), << (n-th level parent) :first(n) :last(n) :skip(n) :take(n) :reverse() :exact(n), with or without (n), if there is no (n), default n == 1
Element state: :hidden, :visible</para>
from x-path: :ancestor :descendant :child :parent :next-siblings :previous-siblings
         */
        static FromSelector(calystoSelector) {
            // flattern arguments and arguments which are arrays
            let argsAll = arguments;
            if (argsAll.length > 1) {
                let qq;
                for (var n = 0; n < argsAll.length; n++) {
                    let innerSel = Calysto.DomQuery.FromSelector(argsAll[n]);
                    if (!qq) {
                        qq = innerSel; //.addPredicateInfo("FromSelector", argsAll);
                    }
                    else {
                        qq = qq.addPredicateInfo("Concat", argsAll[n]).Concat(innerSel);
                    }
                }
                return qq;
            }
            if (!calystoSelector) {
                return DomQuery.FromArray([]);
            }
            // if starts with white space or / or //, remove it, it doesn't make sense since it already works on document.DescendantNodes()
            if (typeof (calystoSelector) == "string") {
                switch (calystoSelector.charAt(0)) {
                    case ' ':
                    case '/':
                        calystoSelector = calystoSelector.TrimStart([' ', '/']);
                        break;
                }
            }
            if (calystoSelector == window) // #text node has .cloneNode()
             {
                // window, document, any other dom element
                // warning: window on some portals may have window.length > 0 property, so test if it is window, html or body element first
                return DomQuery.FromArray([calystoSelector]);
            }
            else if (calystoSelector == document) // #text node has .cloneNode()
             {
                // window, document, any other dom element
                // warning: window on some portals may have window.length > 0 property, so test if it is window, html or body element first
                return DomQuery.FromArray([calystoSelector]);
            }
            else if ((calystoSelector.nodeType > 0 && calystoSelector.cloneNode)) // #text node has .cloneNode()
             {
                // window, document, any other dom element
                // warning: window on some portals may have window.length > 0 property, so test if it is window, html or body element first
                return DomQuery.FromArray([calystoSelector]);
            }
            else if (calystoSelector == "html") {
                return DomQuery.FromArray([document.documentElement]);
            }
            else if (calystoSelector == "body") {
                return DomQuery.FromArray([document.body]);
            }
            else if (calystoSelector.constructor == Calysto.DomQuery) {
                return calystoSelector;
            }
            else if (calystoSelector.GetEnumerator) // || (calystoSelector._source && calystoSelector._source.GetEnumerator))
             {
                return new Calysto.DomQuery(() => calystoSelector.GetEnumerator());
            }
            else if (calystoSelector.childNodes) // single dom element
             {
                return DomQuery.FromArray([calystoSelector]);
            }
            else if (typeof (calystoSelector) == "string" && calystoSelector.length > 0) // custom string calystoSelector: "div .red #home"
             {
                return DomQuery.FromArray([document])
                    .DescendantNodes()
                    .Query(calystoSelector);
            }
            else if (calystoSelector.push && calystoSelector.pop) // array, real
             {
                let qq1 = null;
                for (var n = 0; n < calystoSelector.length; n++) {
                    let tmp2 = Calysto.DomQuery.FromSelector(calystoSelector[n]);
                    if (!qq1) {
                        qq1 = tmp2; //.addPredicateInfo("FromSelector", argsAll);
                    }
                    else {
                        qq1 = qq1.Concat(tmp2).AsDomQuery();
                    }
                }
                // if array has no elements, qq1 is null, so return new instance
                return qq1 || DomQuery.FromArray([]);
            }
            else if (calystoSelector && calystoSelector.length > 0 && calystoSelector[0] && calystoSelector[0].nodeType > 0) // dom array
             {
                let qq1 = null;
                for (var n = 0; n < calystoSelector.length; n++) {
                    let tmp2 = Calysto.DomQuery.FromSelector(calystoSelector[n]);
                    if (!qq1) {
                        qq1 = tmp2; //.addPredicateInfo("FromSelector", argsAll);
                    }
                    else {
                        qq1 = qq1.Concat(tmp2).AsDomQuery();
                    }
                }
                // if array has no elements, qq1 is null, so return new instance
                return qq1 || DomQuery.FromArray([]);
            }
            else if (calystoSelector) {
                // if selector is window, document etc.
                return DomQuery.FromArray([calystoSelector]);
            }
            else {
                throw new Error("Unknown calystoSelector in GetDomNodesEnumerable");
            }
        }
        static FromXml(xmlString) {
            /// <summary>
            /// creates source from xmlString
            /// </summary>
            /// <param name="xmlString" type="string"></param>
            var xmlDocument = ParseXmlString(xmlString);
            var docEl = xmlDocument.documentElement; // remove #root node
            return DomQuery.FromArray([docEl]);
        }
        static FromHtml(htmlString) {
            /// <summary>
            /// creates from html string
            /// </summary>
            /// <param name="htmlString"></param>
            var arr = Calysto.Utility.Dom.ConvertToElementsArray(htmlString);
            return DomQuery.FromArray(arr);
        }
        ;
        ////public static FromJsObject(jsObject)
        ////{
        ////	return Calysto.JsObjectReader.ReadObject(jsObject);
        ////}
        static CreateElement(tagName) {
            return DomQuery.FromArray([document.createElement(tagName)]);
        }
    }
    Calysto.DomQuery = DomQuery;
})(Calysto || (Calysto = {}));
// export global variable:
var $$calysto = Calysto.DomQuery.FromSelector;
var Calysto;
(function (Calysto) {
    var Colorspace;
    (function (Colorspace) {
        Colorspace.NamedColors = {
            'aliceblue': '#f0f8ff',
            'antiquewhite': '#faebd7',
            'aqua': '#00ffff',
            'aquamarine': '#7fffd4',
            'azure': '#f0ffff',
            'beige': '#f5f5dc',
            'bisque': '#ffe4c4',
            'black': '#000000',
            'blanchedalmond': '#ffebcd',
            'blue': '#0000ff',
            'blueviolet': '#8a2be2',
            'brown': '#a52a2a',
            'burlywood': '#deb887',
            'cadetblue': '#5f9ea0',
            'chartreuse': '#7fff00',
            'chocolate': '#d2691e',
            'coral': '#ff7f50',
            'cornflowerblue': '#6495ed',
            'cornsilk': '#fff8dc',
            'crimson': '#dc143c',
            'cyan': '#00ffff',
            'darkblue': '#00008b',
            'darkcyan': '#008b8b',
            'darkgoldenrod': '#b8860b',
            'darkgray': '#a9a9a9',
            'darkgrey': '#a9a9a9',
            'darkgreen': '#006400',
            'darkkhaki': '#bdb76b',
            'darkmagenta': '#8b008b',
            'darkolivegreen': '#556b2f',
            'darkorange': '#ff8c00',
            'darkorchid': '#9932cc',
            'darkred': '#8b0000',
            'darksalmon': '#e9967a',
            'darkseagreen': '#8fbc8f',
            'darkslateblue': '#483d8b',
            'darkslategray': '#2f4f4f',
            'darkslategrey': '#2f4f4f',
            'darkturquoise': '#00ced1',
            'darkviolet': '#9400d3',
            'deeppink': '#ff1493',
            'deepskyblue': '#00bfff',
            'dimgray': '#696969',
            'dimgrey': '#696969',
            'dodgerblue': '#1e90ff',
            'firebrick': '#b22222',
            'floralwhite': '#fffaf0',
            'forestgreen': '#228b22',
            'fuchsia': '#ff00ff',
            'gainsboro': '#dcdcdc',
            'ghostwhite': '#f8f8ff',
            'gold': '#ffd700',
            'goldenrod': '#daa520',
            'gray': '#808080',
            'grey': '#808080',
            'green': '#008000',
            'greenyellow': '#adff2f',
            'honeydew': '#f0fff0',
            'hotpink': '#ff69b4',
            'indianred': '#cd5c5c',
            'indigo': '#4b0082',
            'ivory': '#fffff0',
            'khaki': '#f0e68c',
            'lavender': '#e6e6fa',
            'lavenderblush': '#fff0f5',
            'lawngreen': '#7cfc00',
            'lemonchiffon': '#fffacd',
            'lightblue': '#add8e6',
            'lightcoral': '#f08080',
            'lightcyan': '#e0ffff',
            'lightgoldenrodyellow': '#fafad2',
            'lightgray': '#d3d3d3',
            'lightgrey': '#d3d3d3',
            'lightgreen': '#90ee90',
            'lightpink': '#ffb6c1',
            'lightsalmon': '#ffa07a',
            'lightseagreen': '#20b2aa',
            'lightskyblue': '#87cefa',
            'lightslategray': '#778899',
            'lightslategrey': '#778899',
            'lightsteelblue': '#b0c4de',
            'lightyellow': '#ffffe0',
            'lime': '#00ff00',
            'limegreen': '#32cd32',
            'linen': '#faf0e6',
            'magenta': '#ff00ff',
            'maroon': '#800000',
            'mediumaquamarine': '#66cdaa',
            'mediumblue': '#0000cd',
            'mediumorchid': '#ba55d3',
            'mediumpurple': '#9370d8',
            'mediumseagreen': '#3cb371',
            'mediumslateblue': '#7b68ee',
            'mediumspringgreen': '#00fa9a',
            'mediumturquoise': '#48d1cc',
            'mediumvioletred': '#c71585',
            'midnightblue': '#191970',
            'mintcream': '#f5fffa',
            'mistyrose': '#ffe4e1',
            'moccasin': '#ffe4b5',
            'navajowhite': '#ffdead',
            'navy': '#000080',
            'oldlace': '#fdf5e6',
            'olive': '#808000',
            'olivedrab': '#6b8e23',
            'orange': '#ffa500',
            'orangered': '#ff4500',
            'orchid': '#da70d6',
            'palegoldenrod': '#eee8aa',
            'palegreen': '#98fb98',
            'paleturquoise': '#afeeee',
            'palevioletred': '#d87093',
            'papayawhip': '#ffefd5',
            'peachpuff': '#ffdab9',
            'peru': '#cd853f',
            'pink': '#ffc0cb',
            'plum': '#dda0dd',
            'powderblue': '#b0e0e6',
            'purple': '#800080',
            'red': '#ff0000',
            'rosybrown': '#bc8f8f',
            'royalblue': '#4169e1',
            'saddlebrown': '#8b4513',
            'salmon': '#fa8072',
            'sandybrown': '#f4a460',
            'seagreen': '#2e8b57',
            'seashell': '#fff5ee',
            'sienna': '#a0522d',
            'silver': '#c0c0c0',
            'skyblue': '#87ceeb',
            'slateblue': '#6a5acd',
            'slategray': '#708090',
            'slategrey': '#708090',
            'snow': '#fffafa',
            'springgreen': '#00ff7f',
            'steelblue': '#4682b4',
            'tan': '#d2b48c',
            'teal': '#008080',
            'thistle': '#d8bfd8',
            'tomato': '#ff6347',
            'turquoise': '#40e0d0',
            'violet': '#ee82ee',
            'wheat': '#f5deb3',
            'white': '#ffffff',
            'whitesmoke': '#f5f5f5',
            'yellow': '#ffff00',
            'yellowgreen': '#9acd32'
        };
        let ColorConverter;
        (function (ColorConverter) {
            function ParseToRGB(colorStr) {
                /// <summary>
                /// Detect format and parse to RGBA. Returns RGB color object. Parse from hex, rgb or hsv: #rgb, #rrggbb, rgb(R, G, B), rgb(R, G, B, opacity), hsv(H, S, V).
                /// Returns RGB always.
                /// </summary>
                /// <param name="colorStr"></param>
                var hex;
                if (colorStr && (hex = Colorspace.NamedColors[colorStr]) && hex.indexOf("#") == 0) {
                    // named color is converted to #hex value, parse from hex:
                    return ColorConverter.ParseToRGB(hex);
                }
                else if (colorStr.indexOf("rgb") == 0) {
                    var arr = colorStr.match(new RegExp("[\\d\\.]+", "ig"));
                    return new RGB(arr[0], arr[1], arr[2], arr[3]);
                }
                else if (colorStr.indexOf("hsl") == 0) {
                    var arr = colorStr.match(new RegExp("[\\d\\.\\%]+", "ig"));
                    return new HSL(arr[0], arr[1], arr[2], arr[3]).ToRGB();
                }
                else if (colorStr.indexOf("#") == 0) {
                    var str = colorStr.substr(1);
                    let h = str.match(new RegExp('(.{' + str.length / 3 + '})', 'g'));
                    for (var i = 0; i < h.length; i++) {
                        h[i] = parseInt(h[i].length == 1 ? h[i] + h[i] : h[i], 16);
                    }
                    return new RGB(h[0], h[1], h[2], h[3]);
                }
                else {
                    throw Error(colorStr + " can not be parsed to RGB color");
                }
            }
            ColorConverter.ParseToRGB = ParseToRGB;
        })(ColorConverter = Colorspace.ColorConverter || (Colorspace.ColorConverter = {}));
        function toInt(str, def, min, max) {
            var n = parseFloat(str);
            if (isNaN(n) || !isFinite(n))
                return def;
            if (typeof (str) == "string" && str.indexOf("%") > 0)
                n = n / 100; // HSL uses % for view, has to be converted to value
            if (n < min)
                return min;
            if (n > max)
                return max;
            return n;
        }
        function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len)
                val = "0" + val;
            return val;
        }
        class HSL {
            constructor(hue, saturation, luminance, alpha) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="hue" type="int">0...360</param>
                /// <param name="saturation" type="double">0...1</param>
                /// <param name="luminance" type="double">0...1</param>
                /// <param name="alpha" type="double">0...1</param>
                this.h = (parseInt(hue) || 0) % 360;
                this.s = toInt(saturation, 1, 0, 1);
                this.l = toInt(luminance, 0.5, 0, 1);
                this.a = toInt(alpha, 1, 0, 1);
            }
            static Parse(colorStr) {
                /// <summary>
                /// parse hex #rgb or #rrggbb or rgb(....)
                /// </summary>
                /// <param name="hexString"></param>
                if (colorStr.indexOf("hsl") == 0) {
                    // hsla(350,120%,50%,0.5) // % has to be converted to value: x/100
                    var arr = colorStr.match(new RegExp("[\\d\\.\\%]+", "ig"));
                    return new HSL(arr[0], arr[1], arr[2], arr[3]);
                }
                else {
                    // hex, rgb, named color
                    var rgba = ColorConverter.ParseToRGB(colorStr);
                    return rgba.ToHSL();
                }
            }
            Clone() {
                return new HSL(this.h, this.s, this.l, this.a);
            }
            Set(fn) {
                fn(this);
                return this;
            }
            // eg. hsla(130.4325324,47.5%,79%,0.443534001)
            // eg. hsl(130.4325324,47.5%,79%)
            ToHslString() {
                var hasAlpha = this.a != 1 && (this.a > 0 || this.a === 0);
                var str = "hsl";
                if (hasAlpha)
                    str += "a";
                str += "(" + this.h + "," + (this.s * 100) + "%," + (this.l * 100) + "%";
                if (hasAlpha)
                    str += "," + this.a;
                str += ")";
                return str;
            }
            ToRGB() {
                var hsla = this;
                var h = hsla.h / 360;
                var s = hsla.s;
                var v = hsla.l;
                var a = hsla.a;
                if (s == 0) {
                    return new RGB(v * 255, v * 255, v * 255, a);
                }
                else {
                    var var_h = h * 6;
                    var var_i = Math.floor(var_h);
                    var var_1 = v * (1 - s);
                    var var_2 = v * (1 - s * (var_h - var_i));
                    var var_3 = v * (1 - s * (1 - (var_h - var_i)));
                    var var_r, var_g, var_b;
                    if (var_i == 0) {
                        var_r = v;
                        var_g = var_3;
                        var_b = var_1;
                    }
                    else if (var_i == 1) {
                        var_r = var_2;
                        var_g = v;
                        var_b = var_1;
                    }
                    else if (var_i == 2) {
                        var_r = var_1;
                        var_g = v;
                        var_b = var_3;
                    }
                    else if (var_i == 3) {
                        var_r = var_1;
                        var_g = var_2;
                        var_b = v;
                    }
                    else if (var_i == 4) {
                        var_r = var_3;
                        var_g = var_1;
                        var_b = v;
                    }
                    else {
                        var_r = v;
                        var_g = var_1;
                        var_b = var_2;
                    }
                    ;
                    return new RGB(var_r * 255, var_g * 255, var_b * 255, a);
                }
            }
        }
        Colorspace.HSL = HSL;
        class RGB {
            constructor(r, g, b, alpha) {
                this.r = Math.round(toInt(r, 255, 0, 255));
                this.g = Math.round(toInt(g, 255, 0, 255));
                this.b = Math.round(toInt(b, 255, 0, 255));
                this.a = toInt(alpha, 1, 0, 1);
            }
            static Parse(colorStr) {
                /// <summary>
                /// parse hex #rgb or #rrggbb or rgb(....)
                /// </summary>
                /// <param name="colorStr"></param>
                if (colorStr.indexOf("rgb")) {
                    var arr = colorStr.match(new RegExp("[\\d\\.]+", "ig"));
                    return new RGB(arr[0], arr[1], arr[2], arr[3]);
                }
                else {
                    // hex, hsl, named color, cmyk
                    return ColorConverter.ParseToRGB(colorStr);
                }
            }
            Clone() {
                return new RGB(this.r, this.g, this.b, this.a);
            }
            Set(fn) {
                fn(this);
                return this;
            }
            // eg. rgba(176, 227, 185, 0.443534001)
            // eg. rgb(176, 227, 185)
            ToRgbString() {
                var hasAlpha = this.a != 1 && (this.a > 0 || this.a === 0);
                var str = "rgb";
                if (hasAlpha)
                    str += "a";
                str += "(" + this.r + "," + this.g + "," + this.b;
                if (hasAlpha)
                    str += "," + this.a;
                str += ")";
                return str;
            }
            ToHexString() {
                return "#"
                    + pad(Number(Math.round(this.r || 0)).toString(16), 2)
                    + pad(Number(Math.round(this.g || 0)).toString(16), 2)
                    + pad(Number(Math.round(this.b || 0)).toString(16), 2);
            }
            ToHSL() {
                var rgba = this;
                var result = { h: NaN, s: NaN, l: NaN, a: NaN };
                var r = rgba.r / 255;
                var g = rgba.g / 255;
                var b = rgba.b / 255;
                result.a = rgba.a;
                var minVal = Math.min(r, g, b);
                var maxVal = Math.max(r, g, b);
                var delta = maxVal - minVal;
                result.l = maxVal;
                if (delta == 0) {
                    result.h = 0;
                    result.s = 0;
                }
                else {
                    result.s = delta / maxVal;
                    var del_R = (((maxVal - r) / 6) + (delta / 2)) / delta;
                    var del_G = (((maxVal - g) / 6) + (delta / 2)) / delta;
                    var del_B = (((maxVal - b) / 6) + (delta / 2)) / delta;
                    if (r == maxVal) {
                        result.h = del_B - del_G;
                    }
                    else if (g == maxVal) {
                        result.h = (1 / 3) + del_R - del_B;
                    }
                    else if (b == maxVal) {
                        result.h = (2 / 3) + del_G - del_R;
                    }
                    if (result.h < 0) {
                        result.h += 1;
                    }
                    if (result.h > 1) {
                        result.h -= 1;
                    }
                }
                // don't round it, to be more precize when adjusting values for web
                result.h = (result.h * 360);
                result.s = (result.s);
                result.l = (result.l);
                return new HSL(result.h, result.s, result.l, result.a);
            }
            ToCMYK() {
                var RGB = this;
                var result = { k: NaN, c: NaN, m: NaN, y: NaN };
                var r = RGB.r / 255;
                var g = RGB.g / 255;
                var b = RGB.b / 255;
                result.k = Math.min(1 - r, 1 - g, 1 - b);
                result.c = (1 - r - result.k) / (1 - result.k);
                result.m = (1 - g - result.k) / (1 - result.k);
                result.y = (1 - b - result.k) / (1 - result.k);
                result.c = Math.round(result.c * 100);
                result.m = Math.round(result.m * 100);
                result.y = Math.round(result.y * 100);
                result.k = Math.round(result.k * 100);
                return new CMYK(result.c, result.m, result.y, result.k);
            }
        }
        Colorspace.RGB = RGB;
        class CMYK {
            constructor(c, m, y, k) {
                /// <summary>
                /// ctor.
                /// </summary>
                /// <param name="c">0...100</param>
                /// <param name="m">0...100</param>
                /// <param name="y">0...100</param>
                /// <param name="k">0...100</param>
                this.c = toInt(c, 100, 0, 100);
                this.m = toInt(m, 100, 0, 100);
                this.y = toInt(y, 100, 0, 100);
                this.k = toInt(k, 100, 0, 100);
            }
            ToRGB() {
                var CMYK = this;
                var result = {};
                var c = CMYK.c / 100;
                var m = CMYK.m / 100;
                var y = CMYK.y / 100;
                var k = CMYK.k / 100;
                result.r = 1 - Math.min(1, c * (1 - k) + k);
                result.g = 1 - Math.min(1, m * (1 - k) + k);
                result.b = 1 - Math.min(1, y * (1 - k) + k);
                result.r = Math.round(result.r * 255);
                result.g = Math.round(result.g * 255);
                result.b = Math.round(result.b * 255);
                return new RGB(result.r, result.g, result.b, result.a);
            }
        }
        Colorspace.CMYK = CMYK;
    })(Colorspace = Calysto.Colorspace || (Calysto.Colorspace = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    let EasingHelper;
    (function (EasingHelper) {
        const easings = {
            // http://easings.net/
            // arg0: time fraction or time progress: 0...1, elapsed time / duration
            // arg1: elapsed time, 0...100
            // arg2: startValue
            // arg3: total value delta: finalValue - startValue
            // arg4: total duration, 100
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            },
            easeInQuad: function (x, t, b, c, d) {
                return c * (t /= d) * t + b;
            },
            easeOutQuad: function (x, t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
            },
            easeInOutQuad: function (x, t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t + b;
                return -c / 2 * ((--t) * (t - 2) - 1) + b;
            },
            easeInCubic: function (x, t, b, c, d) {
                return c * (t /= d) * t * t + b;
            },
            easeOutCubic: function (x, t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b;
            },
            easeInOutCubic: function (x, t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t + 2) + b;
            },
            easeInQuart: function (x, t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            },
            easeOutQuart: function (x, t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            },
            easeInOutQuart: function (x, t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t + b;
                return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            },
            easeInQuint: function (x, t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b;
            },
            easeOutQuint: function (x, t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            },
            easeInOutQuint: function (x, t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            },
            easeInSine: function (x, t, b, c, d) {
                return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            },
            easeOutSine: function (x, t, b, c, d) {
                return c * Math.sin(t / d * (Math.PI / 2)) + b;
            },
            easeInOutSine: function (x, t, b, c, d) {
                return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
            },
            easeInExpo: function (x, t, b, c, d) {
                return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
            },
            easeOutExpo: function (x, t, b, c, d) {
                return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
            },
            easeInOutExpo: function (x, t, b, c, d) {
                if (t == 0)
                    return b;
                if (t == d)
                    return b + c;
                if ((t /= d / 2) < 1)
                    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
            },
            easeInCirc: function (x, t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
            },
            easeOutCirc: function (x, t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
            },
            easeInOutCirc: function (x, t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
                return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
            },
            easeInElastic: function (x, t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (t == 0)
                    return b;
                if ((t /= d) == 1)
                    return b + c;
                if (!p)
                    p = d * .3;
                if (a < Math.abs(c)) {
                    a = c;
                    var s = p / 4;
                }
                else
                    var s = p / (2 * Math.PI) * Math.asin(c / a);
                return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            },
            easeOutElastic: function (x, t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (t == 0)
                    return b;
                if ((t /= d) == 1)
                    return b + c;
                if (!p)
                    p = d * .3;
                if (a < Math.abs(c)) {
                    a = c;
                    var s = p / 4;
                }
                else
                    var s = p / (2 * Math.PI) * Math.asin(c / a);
                return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
            },
            easeInOutElastic: function (x, t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;
                if (t == 0)
                    return b;
                if ((t /= d / 2) == 2)
                    return b + c;
                if (!p)
                    p = d * (.3 * 1.5);
                if (a < Math.abs(c)) {
                    a = c;
                    var s = p / 4;
                }
                else
                    var s = p / (2 * Math.PI) * Math.asin(c / a);
                if (t < 1)
                    return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
            },
            easeInBack: function (x, t, b, c, d, s) {
                if (s == undefined)
                    s = 1.70158;
                return c * (t /= d) * t * ((s + 1) * t - s) + b;
            },
            easeOutBack: function (x, t, b, c, d, s) {
                if (s == undefined)
                    s = 1.70158;
                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            },
            easeInOutBack: function (x, t, b, c, d, s) {
                if (s == undefined)
                    s = 1.70158;
                if ((t /= d / 2) < 1)
                    return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
                return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
            },
            easeInBounce: function (x, t, b, c, d) {
                return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
            },
            easeOutBounce: function (x, t, b, c, d) {
                if ((t /= d) < (1 / 2.75)) {
                    return c * (7.5625 * t * t) + b;
                }
                else if (t < (2 / 2.75)) {
                    return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
                }
                else if (t < (2.5 / 2.75)) {
                    return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
                }
                else {
                    return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
                }
            },
            easeInOutBounce: function (x, t, b, c, d) {
                if (t < d / 2)
                    return this.easeInBounce(x, t * 2, 0, c, d) * .5 + b;
                return this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
            }
        };
        /**
         *
         * @param {keyof typeof easings} easingName
         * @param {number} startValue
         * @param {number} finalValue
         * @param {number} currentTimeFraction 0-1
         * @returns
         */
        function InvokeEasing(easingName, startValue, finalValue, currentTimeFraction) {
            /// <summary>
            /// Calculate current value based on current time fraction
            /// </summary>
            /// <param name="startValue" type="Number"></param>
            /// <param name="finalValue" type="Number"></param>
            /// <param name="currentTimeFraction" type="Number">0...1</param>
            if (currentTimeFraction < 0)
                currentTimeFraction = 0;
            if (currentTimeFraction > 1)
                currentTimeFraction = 1;
            var easingFunc = null;
            if (typeof (easingName) == "string") {
                easingFunc = easings[easingName];
            }
            else if (typeof (easingName) == "function") {
                throw new Error("Easing function not supported: " + easingName);
            }
            if (!easingFunc) {
                throw new Error("Unknown easing function: " + easingName);
            }
            return easingFunc(currentTimeFraction, // 0...1
            currentTimeFraction * 100, // percent duration 0...100
            startValue, finalValue - startValue, 100 // total duration
            );
        }
        EasingHelper.InvokeEasing = InvokeEasing;
    })(EasingHelper || (EasingHelper = {}));
    let AnimationFrameHelper;
    (function (AnimationFrameHelper) {
        var _ff = window.requestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.msRequestAnimationFrame;
        if (!_ff) // if native is not supported
         {
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                console.log("requestAnimationFrame not supported");
            }
            //#endif
            var _timeoutId;
            var _buffer = [];
            var fnInvoke = () => {
                var arr = _buffer;
                _buffer = [];
                for (var n1 = 0; n1 < arr.length; n1++) {
                    arr[n1]();
                }
            };
            var fnStart = () => {
                if (!_timeoutId)
                    _timeoutId = setTimeout(() => { _timeoutId = null; fnInvoke(); }, 20);
            };
            // if not of above is supported, use next:
            _ff = (fnCallback => {
                _buffer.push(fnCallback);
                fnStart();
            });
        }
        /**
         *  fnCallback is executed just before the DOM has to become visible
         * @param fnCallback
         */
        function RequestAnimationFrame(fnCallback) {
            return _ff(() => fnCallback()); // use lambda expressoin to have correct context
        }
        AnimationFrameHelper.RequestAnimationFrame = RequestAnimationFrame;
    })(AnimationFrameHelper || (AnimationFrameHelper = {}));
    class AnimItem {
    }
    let AnimState;
    (function (AnimState) {
        AnimState[AnimState["Unstarted"] = 0] = "Unstarted";
        AnimState[AnimState["Running"] = 1] = "Running";
        AnimState[AnimState["Completed"] = 2] = "Completed";
        AnimState[AnimState["Aborted"] = 3] = "Aborted";
    })(AnimState || (AnimState = {}));
    class Animator {
        constructor() {
            // total duration, default 400 ms
            this.durationMs = 400;
            // default easing method (linear)
            this.easing = "linear";
            this.state = AnimState.Unstarted;
            this.items = [];
        }
        static RequestAnimationFrame(onAcquired) {
            return AnimationFrameHelper.RequestAnimationFrame(onAcquired);
        }
        /**
         * Returns all items, both DOM and non-dom.
         */
        Items() {
            return this.items.ToArray();
        }
        /**
         * Returns distinct DOM elements list.
         */
        ToList() {
            return new Calysto.List(this.items.Select(o => o.element).Where(o => !!o)).ToList();
        }
        /**
         * Returns distinct DOM elements DomQuery.
         */
        AsDomQuery() {
            return this.ToList().AsDomQuery();
        }
        /**
         * Push DOM element with final value setting. Animation will run from current state to final setting.
         * @param element
         * @param styleName
         * @param finalValue
         * can be exact value or eg. "+=10", "-=50", "*=34"
         * @param onTick
         * optional, Function, eg. function(animator, currentValue){...}, this is animator instance
         */
        AddElement(element, styleName, finalValue, onTick) {
            var aa = new AnimItem();
            aa.element = element;
            aa.elStyleName = styleName;
            aa.elFinalValue = finalValue;
            aa.onTick = onTick;
            this.items.push(aa);
            return this;
        }
        AddValue(startValue, finalValue, onTick) {
            /// <summary>
            /// Animate general value from startValue to finalValue.
            /// </summary>
            /// <param name="startValue"></param>
            /// <param name="finalValue"></param>
            /// <param name="onTick" optional="true" type="Function">function(animator, currentValue){...}, this is animator instance</param>
            var aa = new AnimItem();
            aa.numStart = startValue;
            aa.numFinal = finalValue;
            aa.onTick = onTick;
            aa.isNumValue = true;
            this.items.push(aa);
            return this;
        }
        Clear() {
            /// <summary>
            /// remove all this._items
            /// </summary>
            this.items.Clear();
            return this;
        }
        Duration(durationMs = 400) {
            /// <summary>
            /// total duration of animation. Default is 400ms.
            /// </summary>
            /// <param name="durationMs">default is 400ms</param>
            if (!((durationMs || 0) > 0)) {
                durationMs = 1; // duration must be > 0, or easing functions won't work
            }
            this.durationMs = durationMs;
            return this;
        }
        OnProgress(callback) {
            /// <summary>
            /// send progres in percentage
            /// </summary>
            /// <param name="callback">function(animator, percent){  }, this is animator instance</param>
            this.onProgress = callback;
            return this;
        }
        OnStart(callback) {
            /// <summary>
            /// Send callbak on start.
            /// </summary>
            /// <param name="callback">function(animator){...}, this is animator instance</param>
            this.onStart = callback;
            return this;
        }
        OnComplete(callback) {
            /// <summary>
            /// Send callback on complete.
            /// </summary>
            /// <param name="callback">function(animator){...}, this is animator instance</param>
            this.onComplete = callback;
            return this;
        }
        OnAbort(callback) {
            /// <summary>
            /// Send callback on complete.
            /// </summary>
            /// <param name="callback">function(animator){...}, this is animator instance</param>
            this.onAbort = callback;
            return this;
        }
        Easing(easingType) {
            /// <summary>
            /// set easing method
            /// </summary>
            /// <param name="easingType">easing method. If not defined, default linear will be used.</param>
            if (typeof easingType == "string") {
                this.easing = easingType;
            }
            ////else if (typeof easingType == "function")
            ////{
            ////	// compatibility with old code where function is sent
            ////	this.easing = easingType;
            ////}
            else {
                this.easing = "linear";
            }
            return this;
        }
        initializeFirstRun(item) {
            if (item.element && Calysto.Type.TypeInspector.IsNullOrUndefined(item.elFinalValue)) {
                throw new Error("Error in Animator, no elFinalValue");
            }
            else if (item.element && item.elStyleName && item.elStyleName.Contains("color", true)) {
                // eg. backgroundColor
                // IE <= v8 returns named colors
                var vvv = Calysto.Utility.Dom.GetComputedStyle(item.element, item.elStyleName).StyleValue;
                item.rgbStart = Calysto.Colorspace.ColorConverter.ParseToRGB(vvv);
                var dd = document.createElement("div");
                dd.style.position = "absolute";
                dd.style.width = "1px";
                dd.style.height = "1px";
                dd.style.zIndex = "-1000";
                document.body.appendChild(dd); // must be in dom to be able to get computed style
                dd.style.backgroundColor = item.elFinalValue;
                var ccc = Calysto.Utility.Dom.GetComputedStyle(dd, "backgroundColor").StyleValue;
                if (dd.parentNode)
                    dd.parentNode.removeChild(dd);
                item.rgbFinal = Calysto.Colorspace.ColorConverter.ParseToRGB(ccc);
                ////console.log("start: " + item.startValue.ToHEX() + ", finalValue: " + item.finalValue.ToHEX());
                //item.isRGB = true; // animate RGB, HSV is not ok
                //item.isHSL = false;
                item.rgbCurrent = item.rgbStart.Clone();
            }
            else if (item.element && item.elStyleName == "clip") {
                var curr1 = Calysto.Utility.Dom.GetClip(item.element);
                item.clipStart = curr1; // {top, right, bottom, left}
                item.clipCurrent = Object.assign({}, curr1); // clone to avoid messing with startValue object
                item.clipFinal = Calysto.Utility.Dom.CalculateClip(item.element, item.elFinalValue);
                ////console.log(item.startValue);
                ////console.log(item.finalValue);
                //item.isClip = true;
            }
            else if (item.element && item.elStyleName == "transform") {
                // if current transform style is coumpound;
                // translate(100px, -100px) rotate(170deg) scale(0.2)"
                var currList = (Calysto.Utility.Dom.SelectTransform(item.element) || "")
                    .split(")")
                    .Where(o => !!o)
                    .Select(o => o.Trim() + ")")
                    .Select(o => ({
                    statement: o,
                    kind: ((o || "").match(new RegExp("[\\w]+")) || [])[0],
                    args: ((o || "").match(new RegExp("([\\-]?[\\.\\d]+)", "ig")) || []).Select(kk => parseFloat(kk)) // arguments: 100, -100
                }));
                var finalList = item.elFinalValue.split(")")
                    .Where(o => !!o)
                    .Select(o => o.Trim() + ")")
                    .Select(o => ({
                    statement: o,
                    kind: ((o || "").match(new RegExp("[\\w]+")) || [])[0],
                    args: ((o || "").match(new RegExp("([\\-]?[\\.\\d]+)", "ig")) || []).Select(kk => parseFloat(kk))
                }));
                // select transforms which are to be animated
                // start and finalVal args count has to be the same, if arguments are missing, add them
                var mainList = finalList.Select(finalVal => {
                    var curr = currList.Where(cc => cc.kind == finalVal.kind).pop();
                    if (!curr) {
                        curr = {
                            statement: finalVal.statement,
                            kind: finalVal.kind,
                            args: finalVal.args.Select(ff => finalVal.kind.indexOf("scale") == 0 ? 1 : 0)
                        };
                    }
                    // ako finalVal ima vise argumenata, uzeti statement as stringFormat iz finalValue, u protivnom, uzeti iz currValue
                    var finalHasMoreArgs = false;
                    while (curr.args.length < finalVal.args.length) {
                        finalHasMoreArgs = true;
                        curr.args.push(curr.args.length > 0 ? curr.args[curr.args.length - 1] : finalVal.kind.indexOf("scale") == 0 ? 1 : 0);
                    }
                    while (curr.args.length > finalVal.args.length) {
                        finalVal.args.push(finalVal.args.length > 0 ? finalVal.args[finalVal.args.length - 1] : finalVal.kind.indexOf("scale") == 0 ? 1 : 0);
                    }
                    return ({
                        startValuesArr: curr.args,
                        finalValuesArr: finalVal.args,
                        stringFormat: (finalHasMoreArgs ? finalVal.statement : curr.statement)
                    });
                });
                var index = 0;
                // create single item:
                item.transformStart = mainList.AsEnumerable().SelectMany(o => o.startValuesArr).ToArray();
                item.transformCurrent = item.transformStart.ToArray(); // array has to be cloned to avoid messing with startValue array
                item.transformFinal = mainList.AsEnumerable().SelectMany(o => o.finalValuesArr).ToArray();
                item.transformFormat = mainList.Select(o => o.stringFormat).join(" ").replace(new RegExp("([\\-]?[\\.\\d]+)", "ig"), function () { return "{" + (index++) + "}"; });
            }
            else if (item.element) // any other style value
             {
                let styleItem = Calysto.Utility.Dom.GetComputedStyle(item.element, item.elStyleName);
                item.numStart = styleItem.NumericValue;
                if (!item.elUnits) {
                    //item.units = styleItem.Units;
                    // take units from finalValue, eg. : 100%
                    if (typeof (item.elFinalValue) == "string" && item.elFinalValue.indexOf("%") > 0) {
                        item.elUnits = "%";
                    }
                    else {
                        item.elUnits = styleItem.Units;
                    }
                }
                let originalValue;
                if (item.elUnits == "%" && item.elStyleName.indexOf("margin") == 0) {
                    // we want to set margin in percent of element dimensions, eg. margin-top: 25%, we'll set top margin: 25% of element.offsetHeight
                    // margin is to be animated and finalValue is in percent, use element offset dimensions to calculate final value
                    item.elUnits = null;
                    switch (Calysto.Utility.Dom.ConvertCssNameToCamel(item.elStyleName)) {
                        case "marginTop":
                        case "marginBottom":
                            originalValue = item.element.offsetHeight;
                            break;
                        case "marginLeft":
                        case "marginRight":
                            originalValue = item.element.offsetWidth;
                            break;
                    }
                }
                // finalValue may be number, "+=10", "100px"
                if (Calysto.Type.TypeInspector.IsNullOrUndefined(item.elFinalValue)) {
                    throw new Error("Error in Animator, finalValue is not defined");
                }
                item.numFinal = Calysto.Utility.Dom.CalculateNumericValue(styleItem.NumericValue, item.elFinalValue);
                item.numCurrent = item.numStart;
                if (!Calysto.Type.TypeInspector.IsNumber(item.numStart) || !Calysto.Type.TypeInspector.IsNumber(item.numFinal)) {
                    throw new Error("Calysto.Animator error, invalid start/stop value. Name: " + item.elStyleName + ", styleFinal: " + item.elFinalValue + ", numStart: " + item.numStart + ", numFinal: " + item.numFinal);
                }
            }
            else if (item.isNumValue) {
                item.numCurrent = item.numStart;
            }
        }
        GetCurrent(elapsedTimeMs, startValue, finalValue) {
            return Animator.InvokeEasing(this.easing, startValue, finalValue, elapsedTimeMs / this.durationMs);
        }
        TimerTick(firstRun) {
            if (this.state != AnimState.Running) {
                return; // finish it
            }
            var isCompleted = false;
            var elapsedTime = 0;
            if (firstRun) {
                // first remove items with element property and with no styleName property (created from domquery with .ToAnimator() with no final values set in .ToAnimator(...final values...)
                this.items = this.items.Where(o => o.isNumValue || (!!o.element && !!o.elStyleName && !Calysto.Type.TypeInspector.IsNullOrUndefined(o.elFinalValue)));
                for (var nn = 0; nn < this.items.length; nn++) {
                    this.initializeFirstRun(this.items[nn]);
                }
                // after the init is done, save current time, it is used for calculations
                this.animateStartTicks = Date.now();
            }
            else {
                elapsedTime = Date.now() - (this.animateStartTicks || 0);
                isCompleted = (this.durationMs || 0) <= (elapsedTime || 0);
            }
            for (var nn = 0; nn < this.items.length; nn++) {
                var item = this.items[nn];
                if (item.onTick) {
                    item.onTick(this, item.numCurrent);
                }
                // hsl doesn't work well
                ////else if (item.rgbStart)
                ////{
                ////	Calysto.ForEach(["h", "s", "l", "a"], function (o)
                ////	{
                ////		var val = isOver ? item.finalValue[o] : (this.GetCurrent(elapsedTime, item.startValue[o], item.finalValue[o]));
                ////		item.currentValue[o] = o == "a" ? val : Math.floor(val); // hsl must be integers, "a" is decimal
                ////	}, this);
                ////	// apply to element
                ////	Calysto.Utility.Dom.SetStyleValue(item.element, item.elStyleName, item.currentValue.ToHslString(), null);
                ////}
                if (item.rgbStart) {
                    Calysto.Collections.ForEach(["r", "g", "b", "a"], o => {
                        var val = isCompleted ? item.rgbFinal[o] : (this.GetCurrent(elapsedTime, item.rgbStart[o], item.rgbFinal[o]));
                        item.rgbCurrent[o] = o == "a" ? val : Math.floor(val); // rgb must be integers, "a" is decimal
                    });
                    // apply to element
                    Calysto.Utility.Dom.SetStyleValue(item.element, item.elStyleName, item.rgbCurrent.ToRgbString());
                }
                else if (item.clipStart) {
                    Calysto.Collections.ForEach(["top", "right", "bottom", "left"], o => {
                        item.clipCurrent[o] = isCompleted ? item.clipFinal[o] : Math.floor(this.GetCurrent(elapsedTime, item.clipStart[o], item.clipFinal[o]));
                    });
                    // css clip: rect(0px 10px 100px 20px );
                    // applyt to element
                    Calysto.Utility.Dom.SetClip(item.element, item.clipCurrent);
                }
                else if (item.transformStart) {
                    var val = item.transformFormat;
                    for (var nn = 0; nn < item.transformCurrent.length; nn++) {
                        item.transformCurrent[nn] = isCompleted ? item.transformFinal[nn] : this.GetCurrent(elapsedTime, item.transformStart[nn], item.transformFinal[nn]);
                        val = val.replace("{" + nn + "}", item.transformCurrent[nn] + "");
                    }
                    // apply to element
                    $$calysto(item.element).ApplyTransform(val);
                }
                else // value item or element item
                 {
                    item.numCurrent = isCompleted ? item.numFinal : this.GetCurrent(elapsedTime, item.numStart, item.numFinal);
                    if (item.element) {
                        if (item.elUnits == "px" || item.elUnits == "%") {
                            item.numCurrent = Math.round(item.numCurrent);
                        }
                        //console.log(item.elStyleName + ": " + item.numCurrent);
                        // apply to element
                        Calysto.Utility.Dom.SetStyleValue(item.element, item.elStyleName, item.numCurrent, item.elUnits);
                    }
                }
                if (item.onTick) {
                    item.onTick(this, item.numCurrent);
                }
            }
            if (this.onProgress) {
                var percent = elapsedTime / this.durationMs * 100;
                if (percent > 100) {
                    percent = 100;
                }
                this.onProgress(this, percent); // send progress in percent
            }
            if (!isCompleted) {
                Calysto.Animator.RequestAnimationFrame(() => this.TimerTick(false));
            }
            else {
                // completed
                this.state = AnimState.Completed;
                // onComplete has to be invoked last because we may have this.Start() in onComplete to restart it all
                if (this.onComplete) {
                    this.onComplete(this);
                }
            }
        }
        IsRunning() {
            /// <summary>
            /// Is animator running. If it is waiting for start with Start(delay), it is not running yet.
            /// </summary>
            return this.state == AnimState.Running;
        }
        Start(delayMs = 0) {
            /// <summary>
            /// Call onStart() and start animating.
            /// </summary>
            /// <param name="delayMs" optional="true">delay animator start for delayMs miliseconds</param>
            if (this.IsRunning()) {
                throw new Error("animation is already running");
            }
            if (this._delayTimeoutId) {
                clearTimeout(this._delayTimeoutId);
                this._delayTimeoutId = null;
            }
            if (delayMs > 0) {
                this._delayTimeoutId = setTimeout(() => this.Start(), delayMs);
                return this;
            }
            this.state = AnimState.Running;
            if (this.onStart) {
                this.onStart(this);
            }
            this.TimerTick(true);
            return this;
        }
        Abort() {
            /// <summary>
            /// Stop animating at current position. Do not call onComplete(). Call onAbort()
            /// </summary>
            if (this._delayTimeoutId) {
                clearTimeout(this._delayTimeoutId);
                this._delayTimeoutId = null;
            }
            this.state = AnimState.Aborted;
            if (this.onAbort) {
                this.onAbort(this);
            }
            return this;
        }
    }
    Animator.InvokeEasing = EasingHelper.InvokeEasing;
    Calysto.Animator = Animator;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Preloaders;
    (function (Preloaders) {
        function Squares(color = "#98c7ef", backColor = "#4b84b5", rotateCCV = false) {
            let beginArr = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
            let en1 = rotateCCV
                ? beginArr.reverse().AsEnumerable().GetEnumerator()
                : beginArr.AsEnumerable().GetEnumerator();
            return `	<svg class="lds-blocks" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
		<rect x="17" y="17" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="40" y="17" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="63" y="17" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="63" y="40" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="63" y="63" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="40" y="63" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="17" y="63" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
		<rect x="17" y="40" width="20" height="20" fill="${backColor}">
			<animate attributeName="fill" values="${color};${backColor};${backColor}" keyTimes="0;0.125;1" dur="1s" repeatCount="indefinite" begin="${en1.GetNext().GetValue()}s" calcMode="discrete"></animate>
		</rect>
	</svg>`;
        }
        Preloaders.Squares = Squares;
        function Snake(color = "black", rotateCCV = false) {
            let values = "0 0 0; 45 0 0; 90 0 0; 135 0 0; 180 0 0; 225 0 0 ; 270 0 0; 315 0 0; 360 0 0";
            let rArr = [5.375, 6.438, 8.063, 10.063, 10.75, 12.531, 14.344, 16];
            let en1 = rArr.AsEnumerable().GetEnumerator();
            if (rotateCCV) {
                values = values.split(";").reverse().join(";");
                en1 = rArr.reverse().AsEnumerable().GetEnumerator();
            }
            return `<svg class="snake-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" x="384" y="0">
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(45 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(90 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(135 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(180 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(225 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(270 64 64)" />
				<circle cx="16" cy="64" r="${en1.GetNext().GetValue()}" fill="${color}" transform="rotate(315 64 64)" />
				<animateTransform attributeName="transform" type="rotate" calcMode="discrete" values="${values}" keyTimes="0;0.125;0.25;0.375;0.5;0.625;0.75;0.875;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
			</svg>`;
        }
        Preloaders.Snake = Snake;
        function BallsRing(color = "black", rotateCCV = false) {
            let values = "0 0 0; 45 0 0; 90 0 0; 135 0 0; 180 0 0; 225 0 0 ; 270 0 0; 315 0 0; 360 0 0";
            let aArr = [0.1, 0.2, 0.35, 0.5, 0.7, 0.8, 0.9];
            let en1 = aArr.AsEnumerable().GetEnumerator();
            if (rotateCCV) {
                values = values.split(";").reverse().join(";");
                en1 = aArr.reverse().AsEnumerable().GetEnumerator();
            }
            let main1 = Calysto.Colorspace.ColorConverter.ParseToRGB(color);
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" x="448" y="0">
			<circle cx="16" cy="64" r="16" fill="${main1.ToRgbString()}" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(45, 64, 64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(90,64,64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(135,64,64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(180,64,64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(225,64,64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(270,64,64)" />
			<circle cx="16" cy="64" r="16" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(315,64,64)" />
			<animateTransform attributeName="transform" type="rotate" calcMode="discrete" values="${values}" keyTimes="0;0.125;0.25;0.375;0.5;0.625;0.75;0.875;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
		</svg>`;
        }
        Preloaders.BallsRing = BallsRing;
        function MsRing(color = "black", backColor = "gainsboro", rotateCCV = false) {
            let values = "0 64 64; 45 64 64; 90 64 64; 135 64 64; 180 64 64; 225 64 64; 270 64 64; 315 64 64; 360 64 64";
            if (rotateCCV)
                values = values.split(";").reverse().join(";");
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" x="576" y="0">
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(45 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(90 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(135 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(180 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(225 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(270 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${backColor}" transform="rotate(315 64 64)" />
			<path d="M38.52 33.37L21.36 16.2A63.6 63.6 0 0 1 59.5.16v24.3a39.5 39.5 0 0 0-20.98 8.92z" fill="${color}">
				<animateTransform attributeName="transform" type="rotate" calcMode="discrete" values="${values}" keyTimes="0;0.125;0.25;0.375;0.5;0.625;0.75;0.875;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
			</path>
		</svg>`;
        }
        Preloaders.MsRing = MsRing;
        function TwoArrows(color = "black") {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 108 108" x="704" y="0">
			<path fill="${color}" d="M109.25 55.5h-36l12-12a29.54 29.54 0 0 0-49.53 12H18.75A46.04 46.04 0 0 1 96.9 31.84l12.35-12.34v36zm-90.5 17h36l-12 12a29.54 29.54 0 0 0 49.53-12h16.97A46.04 46.04 0 0 1 31.1 96.16L18.74 108.5v-36z">
			</path>
			<animateTransform attributeName="transform" type="rotate" calcMode="linear" values="0 0 0;360 0 0" keyTimes="0;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
		</svg>`;
        }
        Preloaders.TwoArrows = TwoArrows;
        function Flower(color = "black", rotateCCV = false) {
            let main1 = Calysto.Colorspace.ColorConverter.ParseToRGB(color);
            let aArr = [0.1, 0.1, 0.1, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
            let en1 = aArr.AsEnumerable().GetEnumerator();
            let values = "0 0 0;30 0 0;60 0 0;90 0 0;120 0 0;150 0 0;180 0 0;210 0 0;240 0 0;270 0 0;300 0 0;330 0 0;360 0 0";
            if (rotateCCV) {
                values = values.split(";").reverse().join(";");
                en1 = aArr.reverse().AsEnumerable().GetEnumerator();
            }
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" x="640" y="0">
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.ToRgbString()}" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(30 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(60 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(90 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(120 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(150 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(180 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(210 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(240 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(270 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(300 64 64)" />
			<path d="M59.6 0h8v40h-8V0z" fill="${main1.Set(o => o.a = en1.GetNext().GetValue()).ToRgbString()}" transform="rotate(330 64 64)" />
			<animateTransform attributeName="transform" type="rotate" calcMode="discrete" values="${values}" keyTimes="0;0.08;0.16;0.25;0.33;0.42;0.5;0.58;0.67;0.75;0.83;0.92;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
		</svg>`;
        }
        Preloaders.Flower = Flower;
        function ThreeArcs(color = "black", rotateCCV = false) {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" class="lds-dual-ring">
			<circle cx="50" cy="50" fill="none" stroke-linecap="round" r="40" stroke-width="15" stroke="${color}" stroke-dasharray="42.411500823462205 42.411500823462205" transform="rotate(60 50 50)">
				<animateTransform attributeName="transform" type="rotate" calcMode="linear" values="${rotateCCV ? 360 : 0} 50 50;${rotateCCV ? 0 : 360} 50 50" keyTimes="0;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform>
			</circle>
		</svg>`;
        }
        Preloaders.ThreeArcs = ThreeArcs;
        function ThreeDots(color = "black") {
            return `<svg viewBox="0 -45 120 120" xmlns="http://www.w3.org/2000/svg" fill="${color}">
    <circle cx="15" cy="15" r="15">
        <animate attributeName="r" from="15" to="15"
                 begin="0s" dur="0.8s"
                 values="15;9;15" calcMode="linear"
                 repeatCount="indefinite" />
        <animate attributeName="fill-opacity" from="1" to="1"
                 begin="0s" dur="0.8s"
                 values="1;.5;1" calcMode="linear"
                 repeatCount="indefinite" />
    </circle>
    <circle cx="60" cy="15" r="9" fill-opacity="0.3">
        <animate attributeName="r" from="9" to="9"
                 begin="0s" dur="0.8s"
                 values="9;15;9" calcMode="linear"
                 repeatCount="indefinite" />
        <animate attributeName="fill-opacity" from="0.5" to="0.5"
                 begin="0s" dur="0.8s"
                 values=".5;1;.5" calcMode="linear"
                 repeatCount="indefinite" />
    </circle>
    <circle cx="105" cy="15" r="15">
        <animate attributeName="r" from="15" to="15"
                 begin="0s" dur="0.8s"
                 values="15;9;15" calcMode="linear"
                 repeatCount="indefinite" />
        <animate attributeName="fill-opacity" from="1" to="1"
                 begin="0s" dur="0.8s"
                 values="1;.5;1" calcMode="linear"
                 repeatCount="indefinite" />
    </circle>
</svg>
`;
        }
        Preloaders.ThreeDots = ThreeDots;
        function BallTriangle(color = "black") {
            return `<svg viewBox="0 0 57 57" xmlns="http://www.w3.org/2000/svg" stroke="${color}">
    <g fill="none" fill-rule="evenodd">
        <g transform="translate(1 1)" stroke-width="2">
            <circle cx="5" cy="50" r="5">
                <animate attributeName="cy"
                     begin="0s" dur="2.2s"
                     values="50;5;50;50"
                     calcMode="linear"
                     repeatCount="indefinite" />
                <animate attributeName="cx"
                     begin="0s" dur="2.2s"
                     values="5;27;49;5"
                     calcMode="linear"
                     repeatCount="indefinite" />
            </circle>
            <circle cx="27" cy="5" r="5">
                <animate attributeName="cy"
                     begin="0s" dur="2.2s"
                     from="5" to="5"
                     values="5;50;50;5"
                     calcMode="linear"
                     repeatCount="indefinite" />
                <animate attributeName="cx"
                     begin="0s" dur="2.2s"
                     from="27" to="27"
                     values="27;49;5;27"
                     calcMode="linear"
                     repeatCount="indefinite" />
            </circle>
            <circle cx="49" cy="50" r="5">
                <animate attributeName="cy"
                     begin="0s" dur="2.2s"
                     values="50;50;5;50"
                     calcMode="linear"
                     repeatCount="indefinite" />
                <animate attributeName="cx"
                     from="49" to="49"
                     begin="0s" dur="2.2s"
                     values="49;5;27;49"
                     calcMode="linear"
                     repeatCount="indefinite" />
            </circle>
        </g>
    </g>
</svg>`;
        }
        Preloaders.BallTriangle = BallTriangle;
        function Bars(color = "black") {
            return `<svg viewBox="0 0 135 140" xmlns="http://www.w3.org/2000/svg" fill="${color}">
    <rect y="10" width="15" height="120" rx="6">
        <animate attributeName="height"
             begin="0.5s" dur="1s"
             values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear"
             repeatCount="indefinite" />
        <animate attributeName="y"
             begin="0.5s" dur="1s"
             values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear"
             repeatCount="indefinite" />
    </rect>
    <rect x="30" y="10" width="15" height="120" rx="6">
        <animate attributeName="height"
             begin="0.25s" dur="1s"
             values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear"
             repeatCount="indefinite" />
        <animate attributeName="y"
             begin="0.25s" dur="1s"
             values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear"
             repeatCount="indefinite" />
    </rect>
    <rect x="60" width="15" height="140" rx="6">
        <animate attributeName="height"
             begin="0s" dur="1s"
             values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear"
             repeatCount="indefinite" />
        <animate attributeName="y"
             begin="0s" dur="1s"
             values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear"
             repeatCount="indefinite" />
    </rect>
    <rect x="90" y="10" width="15" height="120" rx="6">
        <animate attributeName="height"
             begin="0.25s" dur="1s"
             values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear"
             repeatCount="indefinite" />
        <animate attributeName="y"
             begin="0.25s" dur="1s"
             values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear"
             repeatCount="indefinite" />
    </rect>
    <rect x="120" y="10" width="15" height="120" rx="6">
        <animate attributeName="height"
             begin="0.5s" dur="1s"
             values="120;110;100;90;80;70;60;50;40;140;120" calcMode="linear"
             repeatCount="indefinite" />
        <animate attributeName="y"
             begin="0.5s" dur="1s"
             values="10;15;20;25;30;35;40;45;50;0;10" calcMode="linear"
             repeatCount="indefinite" />
    </rect>
</svg>
`;
        }
        Preloaders.Bars = Bars;
        function Oval(color = "black", backColor = "gainsboro", rotateCCV = false) {
            return `<svg viewBox="0 0 38 38" xmlns="http://www.w3.org/2000/svg" stroke="${color}">
    <g fill="none" fill-rule="evenodd">
        <g transform="translate(1 1)" stroke-width="2">
            <circle stroke="${backColor}" stroke-opacity="1" cx="18" cy="18" r="18"/>
            <path d="M36 18c0-9.94-8.06-18-18-18">
                <animateTransform
                    attributeName="transform"
                    type="rotate"
                    from="${rotateCCV ? 360 : 0} 18 18"
                    to="${rotateCCV ? 0 : 360} 18 18"
                    dur="1s"
                    repeatCount="indefinite"/>
            </path>
        </g>
    </g>
</svg>`;
        }
        Preloaders.Oval = Oval;
        function Messenger(color) {
            return `<svg class="lds-message" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><g transform="translate(20 50)">
<circle cx="0" cy="0" r="7" fill="${color || "#e15b64"}" transform="scale(0.99275 0.99275)">
  <animateTransform attributeName="transform" type="scale" begin="-0.375s" calcMode="spline" keySplines="0.3 0 0.7 1;0.3 0 0.7 1" values="0;1;0" keyTimes="0;0.5;1" dur="1s" repeatCount="indefinite"></animateTransform>
</circle>
</g><g transform="translate(40 50)">
<circle cx="0" cy="0" r="7" fill="${color || "#f47e60"}" transform="scale(0.773605 0.773605)">
  <animateTransform attributeName="transform" type="scale" begin="-0.25s" calcMode="spline" keySplines="0.3 0 0.7 1;0.3 0 0.7 1" values="0;1;0" keyTimes="0;0.5;1" dur="1s" repeatCount="indefinite"></animateTransform>
</circle>
</g><g transform="translate(60 50)">
<circle cx="0" cy="0" r="7" fill="${color || "#f8b26a"}" transform="scale(0.42525 0.42525)">
  <animateTransform attributeName="transform" type="scale" begin="-0.125s" calcMode="spline" keySplines="0.3 0 0.7 1;0.3 0 0.7 1" values="0;1;0" keyTimes="0;0.5;1" dur="1s" repeatCount="indefinite"></animateTransform>
</circle>
</g><g transform="translate(80 50)">
<circle cx="0" cy="0" r="7" fill="${color || "#abbd81"}" transform="scale(0.113418 0.113418)">
  <animateTransform attributeName="transform" type="scale" begin="0s" calcMode="spline" keySplines="0.3 0 0.7 1;0.3 0 0.7 1" values="0;1;0" keyTimes="0;0.5;1" dur="1s" repeatCount="indefinite"></animateTransform>
</circle>
</g></svg>`;
        }
        Preloaders.Messenger = Messenger;
        function RotatingBalls(color) {
            return `<svg class="lds-microsoft" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><g transform="rotate(0)"><circle cx="81.73413361164941" cy="74.35045716034882" fill="${(color || "#e15b64")}" r="5" transform="rotate(340.001 49.9999 50)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="0s"></animateTransform>
</circle><circle cx="74.35045716034882" cy="81.73413361164941" fill="${(color || "#f47e60")}" r="5" transform="rotate(348.352 50.0001 50.0001)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.0625s"></animateTransform>
</circle><circle cx="65.3073372946036" cy="86.95518130045147" fill="${(color || "#f8b26a")}" r="5" transform="rotate(354.236 50 50)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.125s"></animateTransform>
</circle><circle cx="55.22104768880207" cy="89.65779445495241" fill="${(color || "#abbd81")}" r="5" transform="rotate(357.958 50.0002 50.0002)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.1875s"></animateTransform>
</circle><circle cx="44.77895231119793" cy="89.65779445495241" fill="${(color || "#849b87")}" r="5" transform="rotate(359.76 50.0064 50.0064)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.25s"></animateTransform>
</circle><circle cx="34.692662705396415" cy="86.95518130045147" fill="${(color || "#e15b64")}" r="5" transform="rotate(0.183552 50 50)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.3125s"></animateTransform>
</circle><circle cx="25.649542839651176" cy="81.73413361164941" fill="${(color || "#f47e60")}" r="5" transform="rotate(1.86457 50 50)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.375s"></animateTransform>
</circle><circle cx="18.2658663883506" cy="74.35045716034884" fill="${(color || "#f8b26a")}" r="5" transform="rotate(5.45126 50 50)">
  <animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;360 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s" begin="-0.4375s"></animateTransform>
</circle><animateTransform attributeName="transform" type="rotate" calcMode="spline" values="0 50 50;0 50 50" times="0;1" keySplines="0.5 0 0.5 1" repeatCount="indefinite" dur="1.5s"></animateTransform></g></svg>`;
        }
        Preloaders.RotatingBalls = RotatingBalls;
    })(Preloaders = Calysto.Preloaders || (Calysto.Preloaders = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    function CreateObject(columns, itemsArray) {
        var obj = {};
        for (var k = 0; k < columns.length; k++) {
            obj[columns[k]] = itemsArray[k];
        }
        return obj;
    }
    //#region FromObjectsArray
    function CreateColumns(obj) {
        var columns = [];
        if (columns.length == 0) {
            for (var p in obj) {
                columns.push(p);
            }
        }
        return columns;
    }
    function GetItemsArray(obj, columns) {
        var values = [];
        for (var n = 0; n < columns.length; n++) {
            values.push(obj[columns[n]]);
        }
        return values;
    }
    //#endregion
    class DataTable {
        constructor() {
            this.Columns = [];
            this.Rows = [];
        }
        ToObjectsArray() {
            /// <summary>
            /// to objects array, return array
            /// </summary>
            var arr = [];
            for (var n = 0; n < this.Rows.length; n++) {
                arr.push(CreateObject(this.Columns, this.Rows[n]));
            }
            return arr;
        }
        Clone() {
            /// <summary>
            /// clone this datatable, returns cloned data table
            /// </summary>
            var dt = new Calysto.DataTable();
            dt.Columns = this.Columns.slice(); // create copy of array
            dt.Rows = this.Rows.slice(); // create copy of array
            dt.TotalCount = this.TotalCount;
            dt.TableName = this.TableName;
            return dt;
        }
        fromObjectsArray(objArray) {
            for (var n = 0; n < objArray.length; n++) {
                var obj = objArray[n];
                if (n == 0) {
                    this.Columns = CreateColumns(obj);
                }
                var itemsArray = GetItemsArray(obj, this.Columns);
                this.Rows.push(itemsArray);
            }
        }
        fromDataTable(dataTable) {
            /// <summary>
            /// create from dataTable's data
            /// </summary>
            /// <param name="dataTable"></param>
            this.Columns = dataTable.Columns.slice(0);
            this.Rows = dataTable.Rows.slice(0);
            this.TotalCount = dataTable.TotalCount;
            this.TableName = dataTable.TableName;
        }
        static CreateFrom(data) {
            /// <summary>Constructor. The Calysto.DataTable Object that provides DataTable functionality</summary>
            /// <param name="data" optional="true" type="ArrayOfObjects|DataTable|Calysto.DataTable|Null">The ArrayOfObjects or DataTable that this instance will work with.</param>
            var dt = new DataTable();
            if (data) {
                if (data.Columns && data.Rows) {
                    dt.fromDataTable(data);
                }
                else if (data.push && data.pop) {
                    dt.fromObjectsArray(data);
                }
                else {
                    // invalid data
                    throw new Error("Calysto.DataTable: Invalid data, can't create data table");
                }
            }
            return dt;
        }
    }
    Calysto.DataTable = DataTable;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    function CreateArray(source) {
        if (!source)
            return [];
        else if (source.ToArray)
            return source.ToArray();
        else
            return Calysto.CalystoEnumerable.From(source).ToArray();
    }
    class List extends Calysto.CalystoEnumerable {
        constructor(source) {
            super(() => Calysto.CalystoEnumerator.From(this.array));
            this.array = [];
            if (typeof source == "string")
                throw new Error("List source can not be string"); // let's test if there is string sent from old code
            for (let item of CreateArray(source))
                this.array.push(item);
        }
        get InnerArray() { return this.array; }
        Add(value) {
            this.array.push(value);
            return this;
        }
        AddRange(arr) {
            this.array.AddRange(arr);
            return this;
        }
        Count() {
            return this.array.length;
        }
        Any() {
            return this.array.length > 0;
        }
        Insert(index, value) {
            this.array.splice(index, 0, value);
            return this;
        }
        ElementAt(index, defaultValue) {
            if (this.array.length > index)
                return this.array[index];
            else
                return defaultValue;
        }
        Remove(value) {
            return this.RemoveAt(this.IndexOf(value));
        }
        RemoveAt(index) {
            return this.RemoveRange(index, 1);
        }
        /**
         * in-place splice
         * @param {number} index
         * @param {number} count?
         * @returns
         */
        RemoveRange(index, count) {
            if (index > 0 || index == 0) {
                this.array.splice(index, count || 1); // in-place splice
            }
            return this;
        }
        /**
         * in place reverse
         * @returns
         */
        Reverse() {
            this.array.reverse(); // in place reverse
            return this;
        }
        IndexOf(value) {
            return this.array.indexOf(value);
        }
        Contains(value) {
            return this.IndexOf(value) >= 0;
        }
        Clear() {
            this.array.splice(0, this.array.length);
            return this;
        }
        /**
         * Returns new copy of inner array
         * @returns
         */
        ToArray() {
            return this.array.slice(0);
        }
        /** create new instance of List from sliced inner array. */
        ToList() {
            return new Calysto.List(this.array.slice(0));
        }
        ToStringJoined(separator) {
            return this.array.join(separator || "");
        }
        ForEach(action) {
            if (typeof action == "string")
                action = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(action);
            Calysto.Collections.ForEach(this.array, action);
            return this;
        }
        FirstOrDefault(defaultValue) {
            return this.array.length > 0 ? this.array[0] : defaultValue;
        }
        First() {
            var _a;
            if (((_a = this.array) === null || _a === void 0 ? void 0 : _a.length) > 0)
                return this.array[0];
            else
                throw new Error("Error in First(), no items");
        }
        LastOrDefault(defaultValue) {
            return this.array.length > 0 ? this.array[this.array.length - 1] : defaultValue;
        }
        Last() {
            var _a;
            if (((_a = this.array) === null || _a === void 0 ? void 0 : _a.length) > 0)
                return this.array[this.array.length - 1];
            else
                throw new Error("Error in Last(), no items");
        }
    }
    Calysto.List = List;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Utility;
    (function (Utility) {
        class ComprResult {
            constructor() {
                // int current pass
                this.Pass = -1;
            }
        }
        class StringCompressor {
            CompressImpl(text, currentPass) {
                /// <summary>
                /// 
                /// </summary>
                /// <param name="text" type="string"></param>
                /// <param name="currentPass" type="int"></param>
                var arr = new Calysto.Regex("(.+?)\\1+?").SelectSegments(text).Select(function (o) { return o.Value; }).Distinct().ToList();
                // largest match has to be removed
                var phrases = arr.OrderByDescending(function (o) { return o.length; }).Skip(arr.Take(2).Count() > 1 ? 1 : 0).ToList();
                var index = 0;
                var phraseIndex = phrases.AsEnumerable().ToDictionary(function (o) { return o; }, function (o) { return index++; }).ToRawObject(true);
                var strre = phrases.AsEnumerable().Select(function (o) { return "(" + RegExp.Escape(o) + ")"; }).ToStringJoined("|");
                var indexesArr = new Calysto.Regex(strre).SelectSegments(text).Select(function (o) {
                    if (!o.Success && !phraseIndex[o.Value]) {
                        // if largest match still exists, add it to the dictionary:
                        phraseIndex[o.Value] = index++;
                        phrases.Add(o.Value);
                    }
                    return phraseIndex[o.Value];
                }).ToArray();
                var obj = {
                    Dic: phrases.ToArray(),
                    Cont: indexesArr,
                    Pass: currentPass
                };
                return Calysto.Json.Serialize(obj);
            }
            Compress(text, passesMax) {
                /// <summary>
                /// Compress using x passes and return shortest compressed value.
                /// </summary>
                /// <param name="text" type="String"></param>
                /// <param name="passesMax" type="Number"></param>
                /// <returns type=""></returns>
                if (arguments.length < 2)
                    passesMax = 1;
                var pass = 0;
                var previousResult = text;
                while (pass <= passesMax) {
                    var result = this.CompressImpl(previousResult, pass); // first pass is 0
                    if (result.length > previousResult.length) {
                        // if first pass comppressed is larget than original, return uncompressed
                        return previousResult;
                    }
                    previousResult = result;
                    // increase pass and compress again
                    pass++;
                }
                return previousResult;
            }
            Decompress(json) {
                /// <summary>
                /// Decompress compressed json and returns raw string.
                /// </summary>
                /// <param name="json" type="String"></param>
                if (!json.Contains("\"Dic\"") || !json.Contains("\"Cont\"") || !json.Contains("\"Pass\"")) {
                    // not compressed
                    return json;
                }
                var obj = Calysto.Json.Deserialize(json);
                var index = 0;
                var indexPhrase = obj.Dic.AsEnumerable().ToDictionary(function (o) { return "n" + (index++); }, function (o) { return o; }).ToRawObject(true);
                var txt = obj.Cont.AsEnumerable().Select(function (o) { return indexPhrase["n" + o]; }).ToStringJoined();
                if (obj.Pass > 0) {
                    return this.Decompress(txt);
                }
                else {
                    // last pass is 0
                    return txt;
                }
            }
        }
        Utility.StringCompressor = StringCompressor;
    })(Utility = Calysto.Utility || (Calysto.Utility = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Security;
    (function (Security) {
        var Cryptography;
        (function (Cryptography) {
            class SimpleEncryptor {
                /**
                 * Simple encrypter. Creates remaping table 256 bytes to 256 bytes.
                 * @param password
                 */
                constructor(password) {
                    let _passConst = "!(&#@`#)#$%^*(_+~`";
                    password += _passConst;
                    var list1 = password.ToCharArray().AsEnumerable().Cycle(1000).Select((ch, fromByte) => ({
                        ch: ch.charCodeAt(0),
                        fromByte: fromByte
                    })).Take(256)
                        .OrderBy(o => o.ch)
                        .Select((o, toByte) => ({
                        ch: o.ch,
                        fromByte: o.fromByte,
                        toByte: toByte
                    })).ToList();
                    // key must be string, if key is int, it won't work
                    this._dicEncryption = list1.AsEnumerable().ToDictionary(o => o.fromByte + "_", o => o.toByte).ToRawObject(true); // key is source byte, value is destination byte
                    this._dicDecryption = list1.AsEnumerable().ToDictionary(o => o.toByte + "_", o => o.fromByte).ToRawObject(true); // key is source byte, value is destination byte
                }
                Encrypt(rawData) {
                    /// <summary>
                    /// byte[] to be encrypted, returns encrypted byte[]
                    /// </summary>
                    /// <param name="rawData" type="Array|String">byte[] or string</param>
                    if (typeof (rawData) == "string") {
                        rawData = Calysto.Utility.Encoding.UTF8.GetBytes(rawData);
                    }
                    return rawData.Select(o => this._dicEncryption[o + "_"]);
                }
                ;
                Decrypt(encryptedData) {
                    /// <summary>
                    /// byte[] encrypted data, returns decrypted byte[]
                    /// </summary>
                    /// <param name="encryptedData" type="Array">byte[]</param>
                    return encryptedData.Select(o => this._dicDecryption[o + "_"]);
                }
                DecryptToString(encryptedData) {
                    /// <summary>
                    /// byte[] encrypted data, returns decrypted string
                    /// </summary>
                    /// <param name="encryptedData" type="Array">byte[]</param>
                    return Calysto.Utility.Encoding.UTF8.GetString(this.Decrypt(encryptedData));
                }
            }
            Cryptography.SimpleEncryptor = SimpleEncryptor;
        })(Cryptography = Security.Cryptography || (Security.Cryptography = {}));
    })(Security = Calysto.Security || (Calysto.Security = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var TestTools;
    (function (TestTools) {
        var UnitTesting;
        (function (UnitTesting) {
            let Assert;
            (function (Assert) {
                function ShowError(msg) {
                    console.error(msg);
                    return false;
                }
                function ConvertToString(value) {
                    if (typeof value == "string")
                        return value;
                    if (value === undefined)
                        return "undefined";
                    else if (value === null)
                        return "null";
                    else if (isNaN(value))
                        return "NaN";
                    else // any other object
                        return JSON.stringify(value);
                }
                class MessageBuilder {
                    constructor(mainMsg) {
                        this._lines = [];
                        this._lines.push(mainMsg);
                    }
                    AddNameValue(name, value) {
                        this._lines.Add(name + ":<" + ConvertToString(value) + ">.");
                        return this;
                    }
                    AddCustom(message, parameters) {
                        if (message)
                            this._lines.Add(message.FormatWith(parameters));
                        return this;
                    }
                    ToStringFormated(separator = "\r\n") {
                        return this._lines.join(separator);
                    }
                }
                /**
                 * Test references and types with ===, than
                 * Compare values for reference types by serializing to json and compare json strings.
                 * @param expected
                 * @param actual
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function AreEqual(expected, actual, message, parameters) {
                    if (Calysto.Type.TypeInspector.AreValuesEqual(expected, actual))
                        return true;
                    else
                        return ShowError(new MessageBuilder("Assert.AreEqual failed.")
                            .AddNameValue("Expected", expected)
                            .AddNameValue("Actual", actual)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.AreEqual = AreEqual;
                function AreNotEqual(notExpected, actual, message, parameters) {
                    if (!Calysto.Type.TypeInspector.AreValuesEqual(notExpected, actual))
                        return true;
                    else
                        return ShowError(new MessageBuilder("Assert.AreNotEqual failed.")
                            .AddNameValue("NotExpected", notExpected)
                            .AddNameValue("Actual", actual)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.AreNotEqual = AreNotEqual;
                /**
                 * Test with if references and types are equal using ===.
                 * Doesn't compare values for reference types.
                 * @param expected
                 * @param actual
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function AreSame(expected, actual, message, parameters) {
                    if (expected === actual)
                        return true;
                    else
                        return ShowError(new MessageBuilder("Assert.AreSame failed.")
                            .AddNameValue("Expected", expected)
                            .AddNameValue("Actual", actual)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.AreSame = AreSame;
                /**
                 * Test with if references and types are equal using ===.
                 * Doesn't compare values for reference types.
                 * @param expected
                 * @param actual
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function AreNotSame(expected, actual, message, parameters) {
                    if (expected !== actual)
                        return true;
                    else
                        return ShowError(new MessageBuilder("Assert.AreNotSame failed.")
                            .AddNameValue("Expected", expected)
                            .AddNameValue("Actual", actual)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.AreNotSame = AreNotSame;
                function Fail(message, parameters) {
                    return ShowError(new MessageBuilder(`Assert.Fail.`)
                        .AddCustom(message, parameters)
                        .ToStringFormated());
                }
                Assert.Fail = Fail;
                function Inconclusive(message, parameters) {
                    return ShowError(new MessageBuilder(`Assert.Inconclusive.`)
                        .AddCustom(message, parameters)
                        .ToStringFormated());
                }
                Assert.Inconclusive = Inconclusive;
                /**
                 * Expects condition to be false.
                 * @param condition
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function IsFalse(condition, message, parameters) {
                    if (!(condition === false))
                        return true;
                    else
                        return ShowError(new MessageBuilder(`Assert.IsFalse failed.`)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.IsFalse = IsFalse;
                /**
                 * Expects condition to be true.
                 * @param condition
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function IsTrue(condition, message, parameters) {
                    if ((condition === true))
                        return true;
                    else
                        return ShowError(new MessageBuilder(`Assert.IsTrue failed.`)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.IsTrue = IsTrue;
                /**
                 * Is null, undefined or NaN
                 * @param value
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function IsNull(value, message, parameters) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true;
                    else
                        return ShowError(new MessageBuilder(`Assert.IsNull failed.`)
                            .AddNameValue("Actual", value)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.IsNull = IsNull;
                /**
                 * Is not null, undefined or NaN
                 * @param value
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function IsNotNull(value, message, parameters) {
                    if (!Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true;
                    else
                        return ShowError(new MessageBuilder(`Assert.IsNotNull failed.`)
                            .AddNameValue("Actual", value)
                            .AddCustom(message, parameters)
                            .ToStringFormated());
                }
                Assert.IsNotNull = IsNotNull;
                /**
                 * Test if action throws exception.
                 * @param action function
                 * @param message
                 * message {prop1} if parameters is object {prop1: "value"}
                 * or message {0}, {1} if parameters is array with values ["one", "two"]
                 * @param parameters array ["one", "two"] or object with properties {prop1: "value"}
                 */
                function ThrowsException(action, message, parameters) {
                    try {
                        action();
                    }
                    catch (err) {
                        return true;
                    }
                    return ShowError(new MessageBuilder(`Assert.ThrowsException failed. Exception was not thrown.`)
                        .AddCustom(message, parameters)
                        .ToStringFormated());
                }
                Assert.ThrowsException = ThrowsException;
            })(Assert = UnitTesting.Assert || (UnitTesting.Assert = {}));
        })(UnitTesting = TestTools.UnitTesting || (TestTools.UnitTesting = {}));
    })(TestTools = Calysto.TestTools || (Calysto.TestTools = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var TestTools;
    (function (TestTools) {
        var TestRunner;
        (function (TestRunner) {
            let _tests = [];
            function AddTest(fn) {
                _tests.push(fn);
            }
            TestRunner.AddTest = AddTest;
            function RunTests() {
                for (let fn of _tests) {
                    fn();
                }
                let res1 = "UnitTests complete: " + _tests.length;
                console.log(res1);
                return res1;
            }
            TestRunner.RunTests = RunTests;
            if (Calysto.Core.IsTddSpecific) {
                Calysto.Page.OnInteractive(() => TestRunner.RunTests());
            }
        })(TestRunner = TestTools.TestRunner || (TestTools.TestRunner = {}));
    })(TestTools = Calysto.TestTools || (Calysto.TestTools = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    let _css1 = `
.calystoConsole {
	position:fixed;
	top:0;
	left:0;
	width:400px;
	height:100px;
	overflow:auto;
	border:solid 1px black;
	background:#f3f37a;
	color:black;
	font-size:11px;
	z-index:1000000;
}

.calystoConsole * {
	font-size:inherit;
}
`;
    let _cssAdded = false;
    function EnsureCssAdded() {
        if (_cssAdded)
            return;
        _cssAdded = true;
        Calysto.ScriptLoader.LoadCSS(Calysto.Utility.Html.Minify(_css1));
    }
    class Console {
        constructor() {
            /** default: 1000 */
            this.LineMaxLength = 1000;
        }
        EnsureCreated() {
            // ovo smije raditi samo u debugu, ni slucajno ne smije raditi u releaseu da ne pocnu skakati konzole
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                if (this._consoleDiv)
                    return;
                EnsureCssAdded();
                let div1 = document.createElement("div");
                div1.innerHTML = "<div class='calystoConsole'></div>";
                this._consoleDiv = div1.childNodes[0];
                document.body.appendChild(this._consoleDiv);
            }
            //#endif
        }
        ApplyStyle(style) {
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                this.EnsureCreated();
                $$calysto(this._consoleDiv).ApplyStyle(style);
            }
            //#endif			
        }
        ConverToString(txt) {
            if (typeof (txt) == "string")
                return txt;
            else if (txt === undefined)
                return "undefined";
            else if (txt === null)
                return "null";
            else if (txt == NaN)
                return "NaN";
            else if (typeof (txt) == "function")
                return txt + "";
            else
                return JSON.stringify(txt);
        }
        WriteLine(txt) {
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                this.EnsureCreated();
                let str1 = this.ConverToString(txt);
                if (str1.length > this.LineMaxLength)
                    str1 = str1.substr(0, this.LineMaxLength) + "...[truncated]";
                $$calysto(this._consoleDiv).AddChildren(Calysto.DomQuery.CreateElement("div").AddChildren(str1));
                this._consoleDiv.scrollTop = this._consoleDiv.scrollHeight;
            }
            //#endif
        }
        /** Clear console content */
        Clear() {
            if (this._consoleDiv)
                this._consoleDiv.innerHTML = "";
        }
        /** Remove console from DOM */
        Destroy() {
            if (this._consoleDiv) {
                $$calysto(this._consoleDiv).RemoveFromDom();
                this._consoleDiv = null;
            }
        }
    }
    Console.Current = new Console();
    Calysto.Console = Console;
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var CacheProvider;
    (function (CacheProvider) {
        function AdjustExpiration(item) {
            if (item.SlidingDuration > 0)
                item.Expiration = Math.round(Date.now() + (1000 * item.SlidingDuration));
        }
        function IsExpired(item) {
            return item.Expiration && item.Expiration < Date.now();
        }
        /**
         * Set item into storage.
         * @param storage Storage to be used: localStorage or sessionStorage
         * @param key cache key
         * @param item item to be cached
         * @param expirationAfterSeconds
         * @param slidingDurationSeconds item will expire if not used more than x seconds
         */
        function Set(storage, key, item, expirationAfterSeconds, slidingDurationSeconds) {
            var expires = expirationAfterSeconds ? Math.round(Date.now() + (1000 * expirationAfterSeconds)) : null;
            let cached1 = {
                Content: item,
                Expiration: expires,
                SlidingDuration: slidingDurationSeconds
            };
            AdjustExpiration(cached1);
            let json1 = JSON.stringify(cached1);
            storage.setItem(key, json1);
        }
        CacheProvider.Set = Set;
        function Get(storage, key) {
            let json1 = storage.getItem(key);
            if (json1) {
                let cached1 = JSON.parse(json1);
                if (!IsExpired(cached1)) {
                    AdjustExpiration(cached1);
                    return cached1.Content;
                }
                else
                    storage.removeItem(key);
            }
            return null;
        }
        CacheProvider.Get = Get;
        function Remove(storage, key) {
            storage.removeItem(key);
        }
        CacheProvider.Remove = Remove;
        function Clear(storage) {
            storage.clear();
        }
        CacheProvider.Clear = Clear;
    })(CacheProvider = Calysto.CacheProvider || (Calysto.CacheProvider = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Mvc;
    (function (Mvc) {
        var AjaxForm;
        (function (AjaxForm) {
            let _isEnabled = false;
            let _isDisabled = false;
            function IsAjaxFormSubmitEnabled() {
                return _isEnabled && !_isDisabled;
            }
            AjaxForm.IsAjaxFormSubmitEnabled = IsAjaxFormSubmitEnabled;
            function UseAjaxFormSubmit(enable = true) {
                if (enable === false) {
                    _isDisabled = true;
                }
                else if (!_isEnabled) {
                    _isEnabled = true;
                    Calysto.Page.OnEndResponse(() => fnInitFormsInterceptor());
                }
            }
            AjaxForm.UseAjaxFormSubmit = UseAjaxFormSubmit;
            /**
             * Submit form without validation.
             * @param formSelector
             */
            function SubmitForm(formSelector, delay = 0) {
                setTimeout(() => {
                    let form = $$calysto(formSelector).First();
                    fnCreateAndSendRequest(form);
                }, delay);
            }
            AjaxForm.SubmitForm = SubmitForm;
            function fnInitFormsInterceptor() {
                // init forms
                $$calysto("form")
                    .Where(f => !f.$$CalystoInterceptor)
                    .ForEach(frm => {
                    frm.$$CalystoInterceptor = true;
                    let f1 = frm;
                    f1.submitBase = f1.submit;
                    // this code handles when form.submit() is invoked
                    f1.submit = function (ev) {
                        let _safethis14 = this;
                        setTimeout(() => fnHandleSubmitRequest(_safethis14), 1);
                        return false;
                    };
                }).On("submit", (sender, ev) => {
                    // this code handles when button type=submit inside form is clicked
                    setTimeout(() => fnHandleSubmitRequest(sender), 1);
                    return false;
                });
            }
            function fnHandleSubmitRequest(sender) {
                var _a;
                if (!IsAjaxFormSubmitEnabled())
                    return false;
                // if form not valid, return
                if ((_a = Calysto.DataAnnotations.FindValidationService(sender)) === null || _a === void 0 ? void 0 : _a.Validate().Render().Interactive(true).HasErrors())
                    return false;
                fnCreateAndSendRequest(sender);
                return false;
            }
            function fnCreateAndSendRequest(frm) {
                var _a;
                if (!frm)
                    throw new Error("Form is null.");
                // hander: function(content){} or lambda (content)=> {} or just function name in global scope
                let receivedHandler1 = frm.getAttribute(Calysto.Constants.CalystoDomAttributes.CalystoFormHandler);
                let targetSel1 = frm.getAttribute(Calysto.Constants.CalystoDomAttributes.CalystoFormTarget);
                if (!targetSel1 && !receivedHandler1) {
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        console.log("Form has no target and no received handler.");
                    }
                    //#endif
                    return;
                }
                // if we have receivedHandler1, targetSel1 is null, so use frm element
                let selectorId = Calysto.Utility.Dom.EnsureElementId(targetSel1 || frm);
                // we need to know container root selector to create validation errors for container only
                let appendArr = [{ Key: "__RootSelectorKey", Value: selectorId }];
                // must include disabled elements for validation on server to work correctly
                let items1 = Calysto.Forms.SerializeContainer(frm);
                for (let item1 of items1) {
                    if ((_a = item1.Element) === null || _a === void 0 ? void 0 : _a.disabled) {
                        appendArr.push({ Key: item1.Name, Value: item1.Value });
                    }
                }
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log(appendArr);
                }
                //#endif
                let mode1 = frm.getAttribute(Calysto.Constants.CalystoDomAttributes.CalystoFormMode);
                let timeout1 = parseInt(frm.getAttribute("calysto-timeout")) || 90000;
                let spinner1 = Calysto.Mvc.UseCalystoSpinner(frm, false);
                let actionUrl = frm.getAttribute(Calysto.Constants.CalystoDomAttributes.CalystoFormDestination);
                if (!!actionUrl)
                    actionUrl = Calysto.Utility.Encoding.CalystoBase64.DecodeBase64StringToString(actionUrl);
                else
                    throw new Error("Invalid action url.");
                Calysto.Page.OnBeginRequest.Invoke();
                return new Calysto.Net.WebClient(actionUrl)
                    .AddRequestHeader(Calysto.Constants.WsjsHeaderConstants.XCalystoAjaxFormKey, Calysto.Constants.WsjsHeaderConstants.XCalystoAjaxFormValue)
                    .SetTimeout(timeout1)
                    .UploadHtmlForm(frm, appendArr)
                    .OnError((wclient, ev) => {
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        Calysto.Dialog.CreateError(ev + "").Show();
                    }
                    //#endif
                })
                    .OnLoad((wclient, ev) => {
                    let txt = wclient.GetResponseText();
                    let loc1 = wclient.xhr.getResponseHeader("location");
                    if (loc1) {
                        location.assign(loc1);
                        return;
                    }
                    spinner1.Remove();
                    if (wclient.xhr.status < 200 || wclient.xhr.status >= 300) {
                        // Full description is send only if app.UseDeveloperExceptionPage(); is set at Startup.cs
                        // else, will use error page defined in startup.cs with app.UseExceptionHandler($"/controller/action");
                        // if error page not found, returns 404
                        let title1 = wclient.xhr.status + " " + (wclient.xhr.statusText || Calysto.Net.HttpStatusCode[wclient.xhr.status] || "");
                        let body1 = txt || title1;
                        Calysto.Dialog.CreateError(body1, title1).Show();
                    }
                    else if (wclient.xhr.getResponseHeader(Calysto.Constants.WsjsHeaderConstants.XCalystoResponseContainerKey) == Calysto.Constants.WsjsHeaderConstants.XCalystoResponseContainerValue) {
                        // it is CalystoResponse object
                        let state = fnCreateResponseState();
                        Calysto.Net.WebService.AjaxResponseReceivedHandler(wclient, state);
                    }
                    else {
                        if (receivedHandler1) {
                            let result = new Calysto.BoxValue();
                            if (receivedHandler1.Contains("=>")) {
                                let fn1 = Calysto.Utility.Expressions.CompileLambdaNoReturnCheck(receivedHandler1);
                                fn1(txt);
                            }
                            else if (Calysto.DataBinder.TryGetValue(window, receivedHandler1, result)) {
                                result.GetValue()(txt);
                            }
                            else {
                                throw new Error("Received handler supported: " + receivedHandler1);
                            }
                        }
                        if (targetSel1) {
                            mode1 = mode1 || "ReplaceChildren";
                            // we may have multiple target selectors
                            for (let sel1 of targetSel1.split(',')) {
                                sel1 = sel1.Trim();
                                // find for the sel1 selector in both source and target than replace target selector children with content
                                // important: if there is no selector in received content, use complete received content and insert it into target element
                                // this way we have debug feedback
                                let items = Calysto.DomQuery.FromHtml(txt).Query(`${sel1}, //${sel1}`).Distinct().ChildNodes().ToArray();
                                $$calysto(targetSel1)[mode1]((items === null || items === void 0 ? void 0 : items.Any()) ? items : txt);
                            }
                        }
                    }
                    Calysto.Page.OnEndResponse.Invoke();
                }).Start();
            }
            function fnCreateResponseState() {
                return ({
                    fnErrorCallback: (a) => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            Calysto.Dialog.CreateError(a).Show();
                        }
                        //#endif
                    },
                    fnResponseContainerCallback: (a) => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            console.log("fnResponseContainerCallback", a);
                        }
                        //#endif
                    },
                    fnReturnValueCallback: (a) => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            console.log("fnReturnValueCallback", a);
                        }
                        //#endif
                    },
                    fnResponseEndCallback: () => {
                        //#if DEBUG
                        if (Calysto.Core.IsDebugDefined) {
                            console.log("fnResponseEndCallback");
                        }
                        //#endif
                    }
                });
            }
        })(AjaxForm = Mvc.AjaxForm || (Mvc.AjaxForm = {}));
    })(Mvc = Calysto.Mvc || (Calysto.Mvc = {}));
})(Calysto || (Calysto = {}));
/* this has to be invoked in your code:
    Calysto.Mvc.AjaxForm.UseAjaxFormSubmit();
*/
var Calysto;
(function (Calysto) {
    var Mvc;
    (function (Mvc) {
        class CalystoSpinner {
            constructor() {
            }
            /**
            * Search for calysto-spinner elements inside container and use them.
            * @param containerSelector
            * @param autoRemoval
            */
            static Start(containerSelector, autoRemoval) {
                let disabledElements = $$calysto(containerSelector).Query("//button, //a").WhereEnabled(true).SetEnabled(false);
                let spinners = $$calysto(containerSelector).Query("//div.calysto-spinner").ToArray();
                let timers = [];
                for (let spinner1 of spinners) {
                    let spinnerDelay = parseInt(spinner1.getAttribute("calysto-spinner-delay")) || 300;
                    let timer = new Calysto.Timer(s2 => {
                        spinner1.className += " calysto-visible";
                    }).Start(spinnerDelay);
                    timers.push(timer);
                }
                let spinner1 = new CalystoSpinner();
                let cb1 = spinner1.Remove = () => {
                    for (let timer of timers)
                        timer === null || timer === void 0 ? void 0 : timer.Abort();
                    spinners.AsEnumerable().AsDomQuery().RemoveClass("calysto-visible");
                    disabledElements.SetEnabled(true);
                };
                if (autoRemoval)
                    Calysto.Page.OnEndResponse.MCD.AddOnce(cb1);
                return spinner1;
            }
            Remove() { }
        }
        /**
         * Search for calysto-spinner elements inside container and use them.
         * @param containerSelector
         * @param autoRemoval
         */
        function UseCalystoSpinner(containerSelector, autoRemoval) {
            return CalystoSpinner.Start(containerSelector, autoRemoval);
        }
        Mvc.UseCalystoSpinner = UseCalystoSpinner;
    })(Mvc = Calysto.Mvc || (Calysto.Mvc = {}));
})(Calysto || (Calysto = {}));
/// <reference path="Mvc.AjaxForm.ts" />
/// <reference path="Mvc.Spinner.ts" />
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        let TemplateKind;
        (function (TemplateKind) {
            TemplateKind[TemplateKind["NoData"] = 1] = "NoData";
            TemplateKind[TemplateKind["Header"] = 2] = "Header";
            TemplateKind[TemplateKind["Footer"] = 3] = "Footer";
            TemplateKind[TemplateKind["Separator"] = 4] = "Separator";
            TemplateKind[TemplateKind["Item"] = 5] = "Item";
            TemplateKind[TemplateKind["AlternatingItem"] = 6] = "AlternatingItem";
        })(TemplateKind = Binding.TemplateKind || (Binding.TemplateKind = {}));
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        var Setup;
        (function (Setup) {
            class BindingSetup {
                constructor() {
                    this.Bindings = [];
                    this.ViewListeners = [];
                    this.Repeaters = [];
                    this.Templates = [];
                    this.DataListeners = [];
                    this.Sources = [];
                }
            }
            class BindingService {
                constructor(uid, factory) {
                    this._uid = uid;
                    this._setup = factory;
                }
                GetCsvValues(csv) {
                    if (!csv)
                        return [];
                    else if (typeof (csv) == "string") {
                        var arr = csv === null || csv === void 0 ? void 0 : csv.Split(',').Select(o => o.Trim()).Where(o => !String.IsNullOrEmpty(o)).ToArray();
                        if (arr && arr.length > 1)
                            throw new Error("Single string value is expected or string[]. Provided CSV: " + csv);
                        return arr.Any() ? arr : null;
                    }
                    else if (Calysto.Type.TypeInspector.IsArray(csv)) {
                        return csv;
                    }
                    else {
                        throw new Error("Invalid argument, requires string or string[]. Provided: " + csv);
                    }
                }
                Root() {
                    if (this._setup.RootUid)
                        throw new Error("Root is already defined.");
                    this._setup.RootUid = this._uid;
                    return this;
                }
                /**
                 * 2-way binding, 1 to 1
                 * @param elementPath single element path, e.g. value, style.backgroundColor, etc.
                 * @param dataSourcePath single data source path, e.g. path1.sub1, @.path.sub, path2, path3,...
                 * @param jsSetConvert
                 *		1. Lambda: (dataSourceValue) => returns value which will be assigned to element property.
                 *		2. Data source handler path. Function should accept passed arguments and return value which will be assigned to element property.
                 *		3. External func name only. Function should accept passed arguments and return value which will be assigned to element property.
                 * @param jsGetConvert
                 *		1. Lambda: (elementValue) => returns value which will be assigned to data source property.
                 *		2. Data source handler path. Function should accept passed arguments and return value which will be assigned to element property.
                 *		3. External func name only. Function should accept passed arguments and return value which will be assigned to element property.
                 * @param eventNames
                 *		default is 'change', use CSV DOM events names, e.g. mouseover, mouseout, click, input, change
                 */
                Bind(elementPath, dataSourcePath, jsSetConvert, jsGetConvert, eventNames) {
                    let elPaths1 = this.GetCsvValues(elementPath);
                    if ((elPaths1 === null || elPaths1 === void 0 ? void 0 : elPaths1.length) != 1)
                        throw new Error("Single element property path is required, but provided: " + elementPath);
                    let dsPaths1 = this.GetCsvValues(dataSourcePath);
                    if ((dsPaths1 === null || dsPaths1 === void 0 ? void 0 : dsPaths1.length) != 1)
                        throw new Error("Single data source property path is required, but provided: " + dataSourcePath);
                    this._setup.Bindings.push({
                        Uid: this._uid,
                        ElementPath: elPaths1[0],
                        DataSourcePath: dsPaths1[0],
                        JsSetConvert: jsSetConvert,
                        JsGetConvert: jsGetConvert,
                        EventNames: this.GetCsvValues(eventNames)
                    });
                    return this;
                }
                /**
                 * Create listener for data source values.
                 * @param dataSourcePaths CSV: path1, @.path2.sub, path3...
                 * @param jsHandler
                 *		1. Lambda: (context, path1Value, @.path2.subValue, path3Value) => { }
                 *		2. Data source handler path. Function should accept passed arguments, e.g. (context, path1Value, @.path2.subValue, path3Value).
                 *			This inside is object in which handler function is defined.
                 *		3. External func name only. Function should accept passed arguments, e.g. (context, path1Value, @.path2.subValue, path3Value).
                 */
                ListenData(dataSourcePaths, jsHandler) {
                    this._setup.DataListeners.push({
                        Uid: this._uid,
                        DataSourcePaths: this.GetCsvValues(dataSourcePaths),
                        JsHandler: jsHandler
                    });
                    return this;
                }
                /**
                 * Create DOM listener.
                 * @param eventNames CSV: name1, name2, name3, ...
                 * @param jsHandler
                 *		1. Lambda: (context) => { }
                 *		2. Data source handler path. Function should accept (context) arguments.
                 * 			This inside is object in which handler func is defined.
                 *		3. External func name only. Function should accept (context) arguments.
                 */
                ListenView(eventNames, jsHandler) {
                    this._setup.ViewListeners.push({
                        Uid: this._uid,
                        EventNames: this.GetCsvValues(eventNames),
                        JsHandler: jsHandler
                    });
                    return this;
                }
                /**
                 * Create data source path at current element.
                 * @param dataSourcePath
                 */
                Source(dataSourcePath) {
                    this._setup.Sources.push({
                        Uid: this._uid,
                        DataSourcePath: dataSourcePath,
                    });
                    return this;
                }
                Repeater(dataSourcePath) {
                    this._setup.Repeaters.push({
                        Uid: this._uid,
                        DataSourcePath: dataSourcePath,
                    });
                    return this;
                }
                Template(kind) {
                    this._setup.Templates.push({
                        Uid: this._uid,
                        TemplateKind: kind,
                    });
                    return this;
                }
            }
            class BindingFactory {
                constructor() {
                    this._setup = new BindingSetup();
                }
                GetSetup() { return this._setup; }
                GetRoot() { return this._setup.RootUid; }
                Assign(uid, action) {
                    let service = new BindingService(uid, this._setup);
                    action(service);
                    return this;
                }
            }
            Setup.BindingFactory = BindingFactory;
        })(Setup = Binding.Setup || (Binding.Setup = {}));
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        var Attributes;
        (function (Attributes) {
            //export const RootElement = "calysto-binding-root";
            Attributes.ComponentSetting = "calysto-binding-component";
            Attributes.Uid = "calysto-binding-uid";
            //export const ElementSetting = "calysto-binding-setting";
        })(Attributes = Binding.Attributes || (Binding.Attributes = {}));
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        var BindingCache;
        (function (BindingCache) {
            let globalRepeatersDic = {};
            function GetRepeaterSetting(element) {
                let uid = GetElementUid(element);
                return globalRepeatersDic[uid];
            }
            BindingCache.GetRepeaterSetting = GetRepeaterSetting;
            let globalElementsDic = {};
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                window["$$globalRepeatersDic"] = globalRepeatersDic;
                window["$$globalElementsDic"] = globalElementsDic;
            }
            //#endif
            function GetBindingElement(uid) {
                return globalElementsDic[uid];
            }
            BindingCache.GetBindingElement = GetBindingElement;
            function GetElementUid(element) {
                return element.getAttribute(Binding.Attributes.Uid);
            }
            BindingCache.GetElementUid = GetElementUid;
            function FindSettings(rootElement) {
                let json1 = $$calysto(rootElement)
                    .Query(`//div[${Calysto.Binding.Attributes.ComponentSetting}=*]`)
                    .SelectInnerHtml()
                    .FirstOrDefault();
                return Calysto.Json.Deserialize(json1);
            }
            function InitializeBindings(rootElement, settings) {
                let fullSettings = settings || FindSettings(rootElement);
                rootElement.$$observable_RootSetting = fullSettings;
                // svi elementi sa uid atributom
                let elementsArr = $$calysto(rootElement).Query(`[${Calysto.Binding.Attributes.Uid}], //[${Calysto.Binding.Attributes.Uid}]`)
                    .Select(o => ({
                    Uid: o.getAttribute(Calysto.Binding.Attributes.Uid),
                    Element: o
                })).ToArray();
                // add to globalElementsDic
                elementsArr.ForEach(o => {
                    //console.log(o.Uid);
                    if (!o.Uid)
                        throw new Error(`Uid is undefined for ${o.Element.tagName} element`);
                    if (globalElementsDic[o.Uid])
                        throw new Error(`Multiple elements with the same uid: ${o.Uid}`);
                    let sett1 = {
                        RootUid: fullSettings.RootUid,
                        Bindings: fullSettings.Bindings.Where(k => k.Uid == o.Uid).ToArray(),
                        ViewListeners: fullSettings.ViewListeners.Where(k => k.Uid == o.Uid).ToArray(),
                        DataListeners: fullSettings.DataListeners.Where(k => k.Uid == o.Uid).ToArray(),
                        Sources: fullSettings.Sources.Where(k => k.Uid == o.Uid).ToArray(),
                        Repeaters: fullSettings.Repeaters.Where(k => k.Uid == o.Uid).ToArray(),
                        Templates: fullSettings.Templates.Where(k => k.Uid == o.Uid).ToArray()
                    };
                    // if there is no setting for an element, let's throw exception
                    if (!sett1.RootUid
                        && !sett1.Bindings.Any()
                        && !sett1.ViewListeners.Any()
                        && !sett1.DataListeners.Any()
                        && !sett1.Sources.Any()
                        && !sett1.Repeaters.Any()
                        && !sett1.Templates.Any())
                        throw new Error(`No settings found for element with uid: ${o.Uid}`);
                    globalElementsDic[o.Uid] = {
                        Element: o.Element,
                        Settings: sett1
                    };
                });
                let elementsDic = elementsArr.AsEnumerable().ToRawObject(o => o.Uid, o => o.Element);
                let templates = fullSettings.Templates.AsEnumerable()
                    .Select(o => {
                    let repeater1;
                    try {
                        repeater1 = elementsDic[o.Uid].parentElement;
                    }
                    catch (err) {
                        throw new Error(err + ", Uid: " + o.Uid);
                    }
                    return ({
                        Template: o,
                        Element: elementsDic[o.Uid],
                        RepeaterElement: repeater1,
                        RepeaterUid: repeater1.getAttribute(Calysto.Binding.Attributes.Uid)
                    });
                }).ToArray();
                let invalidTemplates = templates.Where(o => !o.RepeaterUid).ToArray();
                if (invalidTemplates.Any())
                    throw new Error("Template has no parent element.");
                let invalidRepeaters = templates.Where(o => $$calysto(o.RepeaterElement).WhereVisible().Any()).ToArray();
                if (invalidRepeaters.Any())
                    throw new Error("Repeater must have style='display:none'");
                let fnGetTemplate = (repeaterUid, templateKind) => {
                    return templates.AsEnumerable()
                        .Where(o => o.RepeaterUid == repeaterUid && o.Template.TemplateKind == templateKind)
                        .Select(o => o.Element)
                        .FirstOrDefault();
                };
                // add to globalRepeatersDic
                fullSettings.Repeaters.ForEach(rep => {
                    if (!globalRepeatersDic[rep.Uid]) {
                        globalRepeatersDic[rep.Uid] = {
                            header: fnGetTemplate(rep.Uid, Binding.TemplateKind.Header),
                            item: fnGetTemplate(rep.Uid, Binding.TemplateKind.Item),
                            alternating: fnGetTemplate(rep.Uid, Binding.TemplateKind.AlternatingItem),
                            separator: fnGetTemplate(rep.Uid, Binding.TemplateKind.Separator),
                            footer: fnGetTemplate(rep.Uid, Binding.TemplateKind.Footer),
                            nodata: fnGetTemplate(rep.Uid, Binding.TemplateKind.NoData),
                        };
                    }
                });
                // now remove templates from DOM
                // it will remove repeaters nested inside templates
                $$calysto(templates.Select(o => o.Element).ToArray()).RemoveFromDom();
            }
            BindingCache.InitializeBindings = InitializeBindings;
        })(BindingCache = Binding.BindingCache || (Binding.BindingCache = {}));
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        class BindingDataSource {
            constructor(dataSource) {
                this.dsListeners = new Binding.BindingDictionaryTree();
                this.dataSource = {};
                if (dataSource)
                    this.SetDataSource(dataSource);
                window["dsListeners"] = this.dsListeners;
            }
            SetDataSource(dataSource) {
                this.dataSource = dataSource || {};
                return this;
            }
            ;
            GetDataSource() {
                return this.dataSource;
            }
            SetValue(path, value, dontNotify) {
                if (dontNotify) {
                    Calysto.DataBinder.SetValue(this.dataSource, path, value);
                }
                else {
                    // get current value
                    var curr = Calysto.DataBinder.GetValue(this.dataSource, path);
                    // set new value, but only if it is different
                    // send notify only if value was changed, ignoring reference diference
                    if (!Calysto.Type.TypeInspector.AreValuesEqual(curr, value)) {
                        Calysto.DataBinder.SetValue(this.dataSource, path, value);
                        this.NotifyPropertyChanged(path);
                    }
                }
                return this;
            }
            GetValue(path) {
                return Calysto.DataBinder.GetValue(this.dataSource, path);
            }
            /**
             * SetValue without calling NotifyPropertyChanged.
             * @param dataProperty
             * @param value
             */
            SetValueSilent(dataProperty, value) {
                return this.SetValue(dataProperty, value, true);
            }
            /**
             * SetValue and force call NotifyPropertyChanged, even if new value is the same as the old one.
             * @param dataProperty
             * @param value
             */
            SetValueLoud(dataProperty, value) {
                this.SetValue(dataProperty, value, true);
                this.NotifyPropertyChanged(dataProperty);
                return this;
            }
            /**
             *
             * @param propertyPath
             * @param listenersArr if not set, will notify all listeners, required for initial binding
             */
            NotifyPropertyChanged(propertyPath) {
                if (!propertyPath || propertyPath.length == 0) {
                    throw new Error("NotifyPropertyChanged(...) requires an argument");
                }
                let listenersArr = this.dsListeners.GetListenersAndDescendants(propertyPath);
                for (let item of listenersArr) {
                    //console.log(item.FullPath);
                    item.CallbackFunc(item.FullPath);
                }
                return this;
            }
        }
        Binding.BindingDataSource = BindingDataSource;
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        class DataSourceListenerItem {
            constructor(Owner, Element, FullPath, CallbackFunc) {
                this.Owner = Owner;
                this.Element = Element;
                this.FullPath = FullPath;
                this.CallbackFunc = CallbackFunc;
            }
            RemoveListener() {
                this.Owner.$$$_listeners.Remove(this);
                this.Owner.$$$_ownerTree.InvalidateCache();
            }
        }
        Binding.DataSourceListenerItem = DataSourceListenerItem;
        class TreeNode {
            /**
             * create tree structure of listeners
            * other properties which are added to current tree node are children and their path contains parent path + their segment
             * @param {string} fullPath
             */
            constructor(ownerTree, fullPath) {
                this.$$$_ownerTree = ownerTree;
                this.$$$_fullPath = fullPath;
                this.$$$_listeners = [];
            }
            AddListener(item) {
                this.$$$_listeners.push(item);
            }
        }
        class BindingDictionaryTree {
            constructor() {
                // caching: to speed up getting listeners
                // cache is invalidated when new listener is added and when new listener is removed from collection
                this.itemsCache = {};
            }
            /**
             * Get tree node by path or create new one if node not found.
             * @param {type} path @ means root, eg. @.level1.level2.level3
             * @returns
             */
            GetTreeNode(propertyPath) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log("GetTreeNode: " + propertyPath);
                }
                //#endif
                if (!this.rootNode)
                    this.rootNode = new TreeNode(this, "@");
                if (!propertyPath)
                    throw new Error("GetTreeNode(path) requires an argument");
                if (propertyPath == "@" || propertyPath == "@.")
                    return this.rootNode;
                var obj = Calysto.DataBinder.GetValue(this.rootNode, propertyPath);
                if (!obj) {
                    // warning: create complete hierarchy of nodes, it it not ok to call setValue with binder because it won't create TreeNode items
                    let tmpParent = this.rootNode;
                    let arr2 = [];
                    propertyPath.split(".").ForEach(propertyPath => {
                        arr2.push(propertyPath);
                        let p2 = arr2.join(".");
                        obj = Calysto.DataBinder.GetValue(tmpParent, p2);
                        if (!obj) {
                            obj = new TreeNode(this, p2);
                            Calysto.DataBinder.SetValue(this.rootNode, p2, obj);
                        }
                    });
                }
                return obj;
            }
            AddListener(propertyPath, element, callback) {
                if (!propertyPath || propertyPath.length == 0)
                    throw new Error("AddListener(...) requires an argument");
                let treeNode = this.GetTreeNode(propertyPath);
                let listener = new DataSourceListenerItem(treeNode, element, treeNode.$$$_fullPath, callback);
                treeNode.AddListener(listener);
                this.InvalidateCache();
                return listener;
            }
            GetListeners(node, includeDescendants) {
                // get current node listeners
                var arr = node && node.$$$_listeners ? node.$$$_listeners.slice(0) : [];
                if (node && includeDescendants) {
                    // foreach children nodes
                    Calysto.Collections.ForEachOwnProperties(node, (name, value, index) => {
                        if (name.indexOf("$$$_") == 0)
                            return;
                        // ostale propertije smatramo keyevima pa ih enumeriramo
                        // get child node listeners
                        var descArr = this.GetListeners(node[name], includeDescendants);
                        if (descArr)
                            arr.AddRange(descArr);
                    });
                }
                return arr;
            }
            /**
             * get listeners from current path and all descendants
             * @param {type} path required, use @ for root
             * @returns
             */
            GetListenersAndDescendants(propertyPath) {
                /// <param name="pathsArr" type="String|Array">required, use @ for root</param>
                if (!propertyPath || propertyPath.length == 0)
                    throw new Error("GetDescendantListeners(...) requires an argument");
                var items = this.GetFromCache(propertyPath);
                if (items) {
                    //#if DEBUG
                    if (Calysto.Core.IsDebugDefined) {
                        //	console.log(propertyPath + ": listeners from cache: " + items.length);
                    }
                    //#endif
                    return items;
                }
                items = this.GetListeners(this.GetTreeNode(propertyPath), true);
                this.AddToCache(propertyPath, items);
                return items;
            }
            InvalidateCache() {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log("InvalidateCache");
                }
                //#endif
                this.itemsCache = {};
            }
            AddToCache(propertyPath, items) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //	console.log("AddToCache");
                }
                //#endif
                this.itemsCache[propertyPath + ""] = items; // if propertyPath is array, []+"" will join elements and create string "word1,word2"
            }
            GetFromCache(propertyPath) {
                return this.itemsCache[propertyPath + ""];
            }
        }
        Binding.BindingDictionaryTree = BindingDictionaryTree;
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        /** Single path resolver is created for single element */
        class BindingElementPathResolver {
            constructor(Element) {
                this.Element = Element;
                this._pathCache = {};
            }
            static GetInstance(element) {
                return element.$$observable_PathResolver || (element.$$observable_PathResolver = new BindingElementPathResolver(element));
            }
            FindDataBinder() {
                if (this._binder)
                    return this._binder;
                let el = this.Element;
                while (el) {
                    if (el.$$observable_Binder)
                        return (this._binder = el.$$observable_Binder);
                    el = el.parentNode;
                }
                return this._binder;
            }
            GetDataBinder() {
                let binder = this.FindDataBinder();
                if (binder)
                    return binder;
                throw new Error("Data binder not found");
            }
            ResolveAbsolutePath(relativePath) {
                let partsArr = relativePath.split(".");
                if (partsArr[0] == "DataItem")
                    partsArr.shift();
                let el = this.Element;
                while (el) {
                    if (el.$$observable_DataPath) {
                        let tmpArr = el.$$observable_DataPath.split(".");
                        partsArr.unshift(...tmpArr);
                    }
                    if (partsArr[0] == "@")
                        return partsArr;
                    else if (el.$$observable_Binder)
                        break; // @ not found
                    else
                        el = el.parentNode;
                }
                throw new Error("Data path can not be resolved for: " + relativePath);
            }
            CreateAbsoluteDataPath(relativePath) {
                let res1 = this._pathCache[relativePath];
                if (res1)
                    return res1;
                if (relativePath && relativePath.charAt(0) == "@") {
                    this._pathCache[relativePath] = relativePath;
                    return relativePath; // already is absolute
                }
                let resolvedArr = this.ResolveAbsolutePath(relativePath);
                let resolvedPath = resolvedArr.join(".");
                return (this._pathCache[relativePath] = resolvedPath);
            }
            ;
        }
        Binding.BindingElementPathResolver = BindingElementPathResolver;
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Binding;
    (function (Binding) {
        /**
         * DOM element custom properties: visible, invisible, enabled, disabled
         * Data custom properties inside repeater: DataItem, ItemIndex
         *
        */
        class BindingObservable extends Binding.BindingDataSource {
            constructor() {
                super();
                this._cachedDataSourceTypes = {};
                this._recursions = 0;
            }
            WriteLog(element, line) {
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    if (!element.$$observable_Log)
                        element.$$observable_Log = [];
                    element.$$observable_Log.push(line);
                }
                //#endif
            }
            SetElementValue(element, elProperty, value) {
                //console.log("SetElementValue", elProperty, value, element);
                this.WriteLog(element, `SetElementValue(${elProperty}, ${value})`);
                if (elProperty == "options" && element.tagName.toLowerCase() == "select") {
                    element.innerHTML = "";
                    var items = value;
                    for (let o of items.ToArray()) {
                        let opt = document.createElement("option");
                        opt.innerHTML = o.Text;
                        opt.value = Calysto.Type.TypeConverter.ToStringFormated(o.Value, element.getAttribute(Calysto.AttrName.CalystoFormat)); // option value is attribute, so value is string
                        element.appendChild(opt);
                        opt.selected = !!o.Selected;
                    }
                }
                else if (elProperty == "enabled" || elProperty == "disabled") {
                    // to be able to use calysto-bind="enabled:true/false"
                    // to be able to use calysto-bind="disabled:true/false"
                    if ((!value && elProperty == "enabled") || (value && elProperty == "disabled")) {
                        // disable element
                        element.setAttribute("disabled", "disabled");
                        element.disabled = true;
                    }
                    else {
                        // enable element
                        element.removeAttribute("disabled");
                        element.disabled = false;
                    }
                }
                else if (elProperty == "visible") {
                    // to be able to use calysto-bind="visible:true/false"
                    // to be able to use calysto-bind="visible:true/false" instead of writing (visible)=> this.style.display = visible ? "" : "none"
                    element.style.display = value ? "" : "none";
                }
                else if (elProperty == "invisible") {
                    // to be able to use calysto-bind="invisible:true/false"
                    element.style.display = value ? "none" : "";
                }
                else if (elProperty == "innerHTML" || elProperty == "value") {
                    // value must be string, eg. innerHTML = 1 won't work unless 1 is string
                    // convert to string if property is "innerHTML" or "value"
                    // el. property "innerHTML" or "value" may bind only string or value which can be converted to string
                    // lets throw exception if GetDotNetTypeName can not convert val to string
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value)) {
                        value = "";
                    }
                    else if (typeof (value) != "string") {
                        value = Calysto.Type.TypeConverter.ToStringFormated(value);
                    }
                    element[elProperty] = value;
                }
                else {
                    // we may not use ToStringFormated, e.g. if we bind element._movieID = 343, so 343 must be integer, as-is
                    // sometimes we're bounding compound object to element's property, so it doesn't have to be converted (and can not be converted)
                    // elProperty may be compound path: style.backgroundColor
                    Calysto.DataBinder.SetValue(element, elProperty, value);
                }
            }
            /**
             * Remove element from DOM, remove listeners from ObservableDictionaryTree
             * @param element
             */
            RemoveElementAndListeners(element) {
                // remove DOM event listeners
                Calysto.Event.Detach(element);
                // remove from DOM
                Calysto.Utility.Dom.RemoveNodeFromDom(element);
                // remove from Calysto.DataObserver
                if (element.$$observable_DataSourceListeners)
                    element.$$observable_DataSourceListeners.ForEach(listener => listener.RemoveListener());
            }
            CloneNodeSafe(el) {
                let el1 = el.cloneNode(true);
                el1.style.display = "none";
                return el1;
            }
            BindDataToRepeater(repeaterEl, absoluteDataPath, sourceList) {
                repeaterEl.$$observable_DataPath = absoluteDataPath;
                this.WriteLog(repeaterEl, `BindDataToRepeater(${absoluteDataPath}, ${sourceList})`);
                let repeater = Binding.BindingCache.GetRepeaterSetting(repeaterEl);
                if (sourceList && sourceList.ToArray)
                    sourceList = sourceList.ToArray();
                ////#if DEBUG
                //if (Calysto.Core.IsDebugDefined)
                //{
                //	console.log({ repeater: absoluteDataPath, source: sourceList });
                //}
                ////#endif
                var total = sourceList && sourceList.length ? sourceList.length : 0;
                // moramo zadrzati trenutnu visinu repeatera da se ne mijenja scroll pozicija elementa kad se svi itemi obrisu pa prije nego se kreiraju novi
                repeaterEl.style.minHeight = repeaterEl.offsetHeight + "px";
                // moramo izbaciti sve prethodne repeater elemente i ponovo ih kreirati jer imamo i separator iteme i header i footer...
                // ali moramo uklniti i sve listenere
                $$calysto(repeaterEl).DescendantNodes().ToArray().ForEach(el => this.RemoveElementAndListeners(el));
                // da budemo ziher da su izbaceni i text nodovi:
                repeaterEl.innerHTML = "";
                let items3 = [repeaterEl];
                if (!(total > 0)) {
                    if (repeater.nodata) {
                        let nn;
                        repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.nodata));
                        nn.$$observable_DataPath = absoluteDataPath;
                        items3.push(nn);
                    }
                }
                else {
                    let nn;
                    if (repeater.header) {
                        repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.header));
                        nn.$$observable_DataPath = absoluteDataPath;
                        items3.push(nn);
                    }
                    for (let index = 0; index < sourceList.length; index++) {
                        let item = sourceList[index];
                        if (repeater.separator && index > 0) {
                            repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.separator));
                            nn.$$observable_DataPath = absoluteDataPath + "." + index;
                            nn.$$observable_ItemIndex = index;
                            items3.push(nn);
                        }
                        if (repeater.alternating && index % 2 == 1) {
                            repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.alternating));
                            nn.$$observable_DataPath = absoluteDataPath + "." + index;
                            nn.$$observable_ItemIndex = index;
                            items3.push(nn);
                        }
                        else if (repeater.item) {
                            repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.item));
                            nn.$$observable_DataPath = absoluteDataPath + "." + index;
                            nn.$$observable_ItemIndex = index;
                            items3.push(nn);
                        }
                    }
                    if (repeater.footer) {
                        repeaterEl.appendChild(nn = this.CloneNodeSafe(repeater.footer));
                        nn.$$observable_DataPath = absoluteDataPath;
                        items3.push(nn);
                    }
                }
                let items2 = $$calysto(repeaterEl).Query(`//[${Binding.Attributes.Uid}]`).ToArray();
                for (let item of items2) {
                    this.WriteLog(item, `Inside repeater, init listeners`);
                    this.CreateViewListeners(item);
                    this.CreateDataListeners(item);
                }
                // trigger data binding
                for (let item of items2) {
                    // trigger all, except current repeaterEl
                    if (item != repeaterEl && item.$$observable_DataSourceListeners && item.$$observable_DataSourceListeners.Any()) {
                        for (let listener of item.$$observable_DataSourceListeners) {
                            listener.CallbackFunc(listener.FullPath);
                        }
                    }
                }
                // make visible
                items3.ForEach(o => o.style.display = "");
                // nakon sto je kreirao i nested repeatere, smijemo ukloniti min-height
                repeaterEl.style.minHeight = "";
            }
            GetUpperPath(path) {
                let arr1 = path.split('.').ToArray();
                arr1.RemoveAt(arr1.length - 1);
                return arr1.join(".");
            }
            /**
             * 1. test if lambda
             * 2. test if exists in window
             * 3. search in dataSource
             * @param absoluteDataPath
             */
            ResolveHandlerFunction(jsHandler, pathResolver) {
                if (typeof (jsHandler) == "function")
                    return ({ Func: jsHandler });
                // 1. try lambda
                if (jsHandler.Contains("=>"))
                    return ({ Func: Calysto.Utility.Expressions.CompileLambdaExpression(jsHandler) });
                // 2. try from data source, traverse from current path up to the root
                let absoluteDataPath = pathResolver.CreateAbsoluteDataPath(jsHandler);
                let arr1 = absoluteDataPath.split(".");
                let tmpPath;
                let fn1;
                while ((tmpPath = arr1.join(".")) && !Calysto.Type.TypeInspector.IsFunction(fn1 = this.GetValue(tmpPath))) {
                    fn1 = null;
                    // upper path, e.g. @.path1.path2.jsHandler, we have to remove path2 and in the next iteration path1
                    if (arr1.length > 1)
                        arr1.splice(arr1.length - 2, 1);
                    else if (arr1.length > 0)
                        arr1.splice(0, 1);
                }
                if (!fn1) {
                    // 3. try global fuction
                    let fn1 = Calysto.DataBinder.GetValue(window, jsHandler);
                    if (fn1) {
                        if (Calysto.Type.TypeInspector.IsFunction(fn1))
                            return ({ Func: fn1 });
                        else
                            throw new Error("Handler path is not function: " + jsHandler);
                    }
                }
                if (!fn1)
                    throw new Error("Function is expected at " + absoluteDataPath + ", but found: " + fn1);
                // find context, path up 1 level
                let context1 = this.GetValue(this.GetUpperPath(tmpPath));
                return ({
                    Func: fn1,
                    HandlerContext: context1
                });
            }
            CreateHtmlEventContext(context, element, eventsNames, event, dsDataPath) {
                return ({
                    Binder: this,
                    Element: element,
                    DataSource: this.GetDataSource(),
                    DataPath: dsDataPath,
                    HandlerContext: context,
                    ListeningEventsNames: eventsNames,
                    Event: event
                });
            }
            CreateViewListeners(element) {
                if (element.$$observable_hasHtmlListenersAttached)
                    return;
                element.$$observable_hasHtmlListenersAttached = true;
                if (!element.$$observable_Uid)
                    element.$$observable_Uid = Binding.BindingCache.GetElementUid(element);
                let pathResolver = Binding.BindingElementPathResolver.GetInstance(element);
                let settings = element.$$observable_ElementSetting = Binding.BindingCache.GetBindingElement(element.$$observable_Uid).Settings;
                this.WriteLog(element, `inside CreateHtmlListeners`);
                if (settings.ViewListeners) {
                    settings.ViewListeners.ForEach(item1 => {
                        this.WriteLog(element, "Create HtmlListeners: " + item1.EventNames + ", jsHandler: " + item1.JsHandler);
                        // nek resolva handler prije kreiranja listenera, tako samo sigurni da on postoji
                        let fnHandler = this.ResolveHandlerFunction(item1.JsHandler, pathResolver);
                        let dsDataPath = pathResolver.CreateAbsoluteDataPath("DataItem");
                        $$calysto(element).On(item1.EventNames, (sender, ev) => {
                            // (sender, event, binder) => ..., this in lamba is context
                            // external function paht, this is context
                            // @.state.DivClick it is function inside data model, this is object @.state in which @.state.DivClick function is defined
                            return fnHandler.Func(this.CreateHtmlEventContext(fnHandler.HandlerContext, element, item1.EventNames, ev, dsDataPath));
                        });
                    });
                }
                let tagName = element.tagName.toLowerCase();
                let isInput = (tagName == "input" || tagName == "select" || tagName == "textarea");
                if (settings.Bindings && isInput) {
                    settings.Bindings.ForEach(item1 => {
                        let absoluteDsPath = pathResolver.CreateAbsoluteDataPath(item1.DataSourcePath);
                        let bindEvents = item1.EventNames;
                        if (!bindEvents || bindEvents.length == 0) {
                            if (element.type == "checkbox" || element.type == "radio") {
                                bindEvents = ["change"];
                            }
                            else {
                                bindEvents = ["change"];
                            }
                        }
                        this.WriteLog(element, "Create Binding DomListeners: " + bindEvents);
                        // nek resolva handler prije kreiranja listenera, tako samo sigurni da on postoji
                        let fnGetConvert;
                        if (item1.JsGetConvert)
                            fnGetConvert = this.ResolveHandlerFunction(item1.JsGetConvert, pathResolver);
                        $$calysto(element).On(bindEvents, (sender, ev) => {
                            let value = undefined;
                            let hasValue = false;
                            // sender == element
                            if (tagName == "select" && item1.ElementPath == "options") {
                                let obj1 = this.GetValue(absoluteDsPath);
                                [].AddRange(sender["options"]).ForEach((o, n) => {
                                    // do not call NotifyPropertyChanged untill all options are set
                                    Calysto.DataBinder.SetValue(obj1, n + ".Selected", !!o.selected);
                                });
                                // original object obj1 is modified, so we have to invoke manually notify changed
                                this.NotifyPropertyChanged(absoluteDsPath);
                                return;
                            }
                            else if (tagName == "input" && item1.ElementPath == "checked") {
                                if (element.name && (element.type == "radio" || element.type == "checkbox")) {
                                    // if it is radio group, all other must be unchecked
                                    // if it is checkbox, do not uncheck anything, just change current element state
                                    // search 2 upper paths: @.data.0.Selected -> collection is @.data
                                    let upperPath = this.GetUpperPath(absoluteDsPath);
                                    let ds1 = this.GetValue(upperPath);
                                    if (!Calysto.Type.TypeInspector.IsArray(ds1)) {
                                        upperPath = this.GetUpperPath(upperPath);
                                        ds1 = this.GetValue(upperPath);
                                    }
                                    if (Calysto.Type.TypeInspector.IsArray(ds1)) {
                                        if (element.type == "radio") {
                                            // uncheck all items
                                            ds1.ForEach(o => o[item1.DataSourcePath] = false);
                                        }
                                        else if (element.type == "checkbox") {
                                            // do not uncheck anything, it may have multiple checkbox checked
                                        }
                                        this.SetValueSilent(absoluteDsPath, element.checked);
                                        // invoke notify on upper path just to be sure if something else is bound to the same collection
                                        this.NotifyPropertyChanged(upperPath);
                                        // stop the execution
                                        return;
                                    }
                                }
                                // if there is no collection bound, set single value
                                // checkbox or radio without name attribute
                                value = element[item1.ElementPath];
                                hasValue = true;
                            }
                            else if (item1.ElementPath == "enabled") {
                                value = !element["disabled"];
                                hasValue = true;
                            }
                            else if (item1.ElementPath == "disabled") {
                                value = !!element["disabled"];
                                hasValue = true;
                            }
                            else if (item1.ElementPath == "visible") {
                                value = $$calysto(element).WhereVisible(true).Any();
                                hasValue = true;
                            }
                            else if (item1.ElementPath == "invisible") {
                                value = !$$calysto(element).WhereVisible(true).Any();
                                hasValue = true;
                            }
                            else if (item1.ElementPath == "value") {
                                value = element[item1.ElementPath];
                                hasValue = true;
                            }
                            else {
                                throw new Error("Not supported: " + item1.ElementPath);
                            }
                            if (hasValue) {
                                if (item1.JsGetConvert) {
                                    value = fnGetConvert.Func(this.CreateHtmlEventContext(fnGetConvert.HandlerContext, element, bindEvents || [], ev, absoluteDsPath), value);
                                }
                                else {
                                    // change type to data source type
                                    let dsType = this._cachedDataSourceTypes[absoluteDsPath];
                                    if (!dsType) {
                                        // detect type from current value in datasource
                                        let dsValue = this.GetValue(absoluteDsPath);
                                        if (!Calysto.Type.TypeInspector.IsNullOrUndefined(dsValue)) {
                                            dsType = Calysto.Type.TypeDescriptor.FromValue(dsValue);
                                            this._cachedDataSourceTypes[absoluteDsPath] = dsType;
                                        }
                                    }
                                    if (dsType) {
                                        value = Calysto.Type.TypeConverter.ChangeType(value, dsType);
                                    }
                                }
                                // set value to data source
                                this.SetValue(absoluteDsPath, value);
                            }
                        });
                    });
                }
            }
            CreateDataSourceContext(context, element, listeningDataPaths, dataPath, values) {
                return ({
                    Binder: this,
                    Element: element,
                    DataSource: this.GetDataSource(),
                    DataPath: dataPath,
                    HandlerContext: context,
                    ListeningDataPaths: listeningDataPaths,
                    Values: values
                });
            }
            GetDataSourceValue(element, dataSourcePath) {
                if (dataSourcePath.EndsWith("ItemIndex")) {
                    var tmpel = element;
                    while (tmpel && tmpel != document) {
                        if (tmpel.$$observable_ItemIndex == 0 || tmpel.$$observable_ItemIndex > 0)
                            return tmpel.$$observable_ItemIndex;
                        tmpel = tmpel.parentNode;
                    }
                    throw new Error("ItemIndex not found");
                }
                return super.GetValue(dataSourcePath);
            }
            CreateDataListeners(element) {
                if (element.$$observable_hasDataListenersAttached)
                    return;
                element.$$observable_hasDataListenersAttached = true;
                if (!element.$$observable_Uid)
                    element.$$observable_Uid = Binding.BindingCache.GetElementUid(element);
                if (!element.$$observable_DataSourceListeners)
                    element.$$observable_DataSourceListeners = [];
                let listenersItems = element.$$observable_DataSourceListeners;
                let settings = element.$$observable_ElementSetting = Binding.BindingCache.GetBindingElement(element.$$observable_Uid).Settings;
                this.WriteLog(element, `inside CreateDataSourceListeners`);
                let pathResolver = Binding.BindingElementPathResolver.GetInstance(element);
                if (settings.Sources) {
                    settings.Sources.ForEach(item => {
                        element.$$observable_DataPath = item.DataSourcePath;
                    });
                }
                if (settings.DataListeners) {
                    settings.DataListeners.ForEach(item1 => {
                        // create absolute paths
                        let absoluteDataPaths = item1.DataSourcePaths.Select(o => pathResolver.CreateAbsoluteDataPath(o));
                        absoluteDataPaths.ForEach(path1 => {
                            this.WriteLog(element, "Create DataListener: " + path1);
                            // nek resolva handler prije kreiranja listenera, tako samo sigurni da on postoji
                            let fnHandler = this.ResolveHandlerFunction(item1.JsHandler, pathResolver);
                            listenersItems.Add(this.dsListeners.AddListener(path1, element, (dataPath) => {
                                if (!Calysto.Utility.Dom.IsElementInDom(element)) {
                                    this.RemoveElementAndListeners(element);
                                    return;
                                }
                                let valuesArr = absoluteDataPaths.Select(o => this.GetDataSourceValue(element, o));
                                return fnHandler.Func(this.CreateDataSourceContext(fnHandler.HandlerContext, element, absoluteDataPaths, dataPath, valuesArr), ...valuesArr);
                            }));
                        });
                    });
                }
                if (settings.Bindings) {
                    settings.Bindings.ForEach(item1 => {
                        // create absolute paths
                        let absolutePath = pathResolver.CreateAbsoluteDataPath(item1.DataSourcePath);
                        this.WriteLog(element, "Create Binding DataSourceListener: " + absolutePath);
                        // nek resolva handler prije kreiranja listenera, tako samo sigurni da on postoji
                        let fnSetConvert;
                        if (item1.JsSetConvert)
                            fnSetConvert = this.ResolveHandlerFunction(item1.JsSetConvert, pathResolver);
                        listenersItems.Add(this.dsListeners.AddListener(absolutePath, element, (currentPath) => {
                            if (!Calysto.Utility.Dom.IsElementInDom(element)) {
                                this.RemoveElementAndListeners(element);
                                return;
                            }
                            let value = this.GetDataSourceValue(element, absolutePath);
                            if (item1.JsSetConvert) {
                                value = fnSetConvert.Func(this.CreateDataSourceContext(fnSetConvert.HandlerContext, element, [absolutePath], currentPath, [value]), value);
                            }
                            this.SetElementValue(element, item1.ElementPath, value);
                        }));
                    });
                }
                if (settings.Repeaters) {
                    settings.Repeaters.ForEach(item => {
                        // create absolute paths
                        let absolutePath = pathResolver.CreateAbsoluteDataPath(item.DataSourcePath);
                        this.WriteLog(element, "Create Repeater DataSourceListener: " + absolutePath);
                        listenersItems.Add(this.dsListeners.AddListener(absolutePath, element, () => {
                            if (!Calysto.Utility.Dom.IsElementInDom(element)) {
                                this.RemoveElementAndListeners(element);
                                return;
                            }
                            let value = this.GetDataSourceValue(element, absolutePath);
                            this.BindDataToRepeater(element, absolutePath, value);
                        }));
                    });
                }
            }
            EnsureRootElement() {
                var _a;
                if (this._rootElement)
                    return;
                if (!this._rootSelector)
                    throw new Error("Root selector not defined.");
                var root = $$calysto(this._rootSelector).Take(2).ToList(); // "body" ili lower, don't search "html" node since we have templates inside
                if (root.Count() > 1)
                    throw new Error("DataBind selector selects " + root.Count() + " elements");
                this._rootElement = root.FirstOrDefault();
                if (!this._rootElement)
                    throw new Error("DataBind root element not found: " + this._rootElement);
                this._rootElement.$$observable_Binder = this;
                this._rootElement.$$observable_DataPath = "@";
                // will remove repeater's templates from DOM
                Binding.BindingCache.InitializeBindings(this._rootElement, (_a = this._factory) === null || _a === void 0 ? void 0 : _a.GetSetup());
                // once the templates are removed from DOM, assign datasource listeners
                var arr1 = $$calysto(this._rootElement).Query("*, //*")
                    .Query(`[${Calysto.Binding.Attributes.Uid}=*]`)
                    .Cast()
                    .ToArray();
                for (var el of arr1) {
                    this.CreateDataListeners(el);
                    this.CreateViewListeners(el);
                }
            }
            NotifyPropertyChanged(propertyPath) {
                if (!propertyPath || propertyPath.length == 0)
                    throw new Error("NotifyPropertyChanged(...) requires an argument");
                this._recursions++;
                if (Math.abs(this._recursions) > 100)
                    throw Error("NotifyPropertyChanged recursion overflow");
                this.EnsureRootElement();
                super.NotifyPropertyChanged(propertyPath); // uses cached items
                this._recursions--;
                return this;
            }
            SetRootElement(calystoSelector) {
                this._rootSelector = calystoSelector;
                return this;
            }
            SetFactory(factory) {
                this._factory = factory;
                let root = factory.GetRoot();
                if (root)
                    this._rootSelector = `[${Binding.Attributes.Uid}=${factory.GetRoot()}]`;
                return this;
            }
            DataBind() {
                /// <summary>
                /// bind this ObservableBinder to elements by calystoSelector. if not set it is bound to document.
                /// </summary>
                // WARNING: bind data after listeners are bound, this way we'll not append listeners twice inside of repeater elements
                // NotifyPropertyChanged has to be invoked at the end
                this.NotifyPropertyChanged("@");
                return this;
            }
        }
        Binding.BindingObservable = BindingObservable;
    })(Binding = Calysto.Binding || (Calysto.Binding = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Web;
    (function (Web) {
        class CalystoVirtualPathHelper {
            constructor(path) {
                this._path = path;
            }
            ToAppRelativeUrlPath() { var _a; return (_a = this._appRelative) !== null && _a !== void 0 ? _a : (this._appRelative = CalystoVirtualPathHelper.CreateAppRelativePath(this._path)); }
            ToVirtualUrlPath() { var _a; return (_a = this._virtualPath) !== null && _a !== void 0 ? _a : (this._virtualPath = CalystoVirtualPathHelper.CombineToVirtualPath([CalystoVirtualPathHelper.GetBasePath(), this.ToAppRelativeUrlPath()])); }
            //#endregion
            //#region public static methods
            /// <summary>
            /// create ~/path...
            /// </summary>
            /// <param name="anyPath"></param>
            /// <returns></returns>
            static CreateAppRelativePath(anyPath) {
                let str1 = anyPath;
                let index;
                if ((index = anyPath.lastIndexOf("/~/")) >= 0) {
                    // image files in css are prefixed with ~/ so url created on client looks like this:
                    // ~/_resources/SiteSpecific/eregistar/css/~/_resources/images/background/bg-43252.jpg
                    // http://localhost/ArizonaWebCore/_resources/SiteSpecific/eregistar/css/~/_resources/images/background/bg-43252.jpg
                    str1 = anyPath.Substring(index + 1);
                }
                if (str1.StartsWith("~/"))
                    return str1;
                // remove base part
                let basePath = CalystoVirtualPathHelper.GetBasePath();
                if (anyPath.StartsWith(basePath, true))
                    str1 = anyPath.Substring(basePath.length);
                if (str1.StartsWith("~/"))
                    return str1;
                else if (str1.StartsWith("/"))
                    return "~" + str1;
                else
                    return "~/" + str1;
            }
            /// <summary>
            /// Combine app relative or virtual paths.
            /// Replaces multiple slashes with single one.
            /// Replaces left slahs with right one.
            /// </summary>
            /// <param name="paths"></param>
            /// <returns></returns>
            static CombineToVirtualPath(paths) {
                let str1 = paths.join("/")
                    .ReplaceAll("~/", "/")
                    .ReplaceAll("\\", "/")
                    .TrimEnd(['/']);
                if (String.IsNullOrEmpty(str1) || str1 == "~")
                    str1 += "/";
                return str1.replace(new RegExp("[/]{2,}", "g"), "/");
            }
            static GetBasePath() {
                let basePath = Calysto.Core.Constants.UrlPathBase || "";
                if (basePath == "/")
                    return "";
                else if (basePath.EndsWith("/"))
                    return basePath.TrimEnd(['/']);
                else
                    return basePath;
            }
        }
        Web.CalystoVirtualPathHelper = CalystoVirtualPathHelper;
    })(Web = Calysto.Web || (Calysto.Web = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var DataAnnotations;
    (function (DataAnnotations) {
        var Validators;
        (function (Validators) {
            function GetValidators(sender, context) {
                let validators = [];
                let dic = $$calysto(sender).SelectAttributesAll().First();
                for (let name in dic) {
                    switch (name) {
                        case "data-val-required":
                            validators.push(new RequiredValidator(dic[name]));
                            break;
                        case "data-val-email":
                            validators.push(new EmailAddressValidator(dic[name]));
                            break;
                        case "data-val-length":
                            validators.push(new StringLengthValidator(dic[name], parseInt(sender.getAttribute("data-val-length-min")), parseInt(sender.getAttribute("data-val-length-max"))));
                            break;
                        case "data-val-regex":
                            validators.push(new RegularExpressionValidator(dic[name], sender.getAttribute("data-val-regex-pattern")));
                            break;
                        case "data-val-range":
                            validators.push(new RangeValidator(dic[name], parseFloat(sender.getAttribute("data-val-range-min")), parseFloat(sender.getAttribute("data-val-range-max"))));
                            break;
                        case "data-val-minlength":
                            validators.push(new MinLengthValidator(dic[name], parseFloat(sender.getAttribute("data-val-minlength-min"))));
                            break;
                        case "data-val-maxlength":
                            validators.push(new MaxLengthValidator(dic[name], parseFloat(sender.getAttribute("data-val-maxlength-max"))));
                            break;
                        case "data-val-fileextensions":
                            validators.push(new FileExtensionsValidator(dic[name], sender.getAttribute("data-val-fileextensions-extensions")));
                            break;
                        case "data-val-equalto":
                            validators.push(new CompareValidator(dic[name], sender.getAttribute("data-val-equalto-other"), context));
                            break;
                    }
                }
                return validators;
            }
            Validators.GetValidators = GetValidators;
            //#region Validators
            class RequiredValidator {
                constructor(ErrorText) {
                    this.ErrorText = ErrorText;
                }
                IsValid(value) {
                    // must be non null or empty or NaN and length > 0
                    return !Calysto.Type.TypeInspector.IsNullOrUndefined(value) && !String.IsNullOrWhiteSpace(value + "");
                }
            }
            class EmailAddressValidator {
                constructor(ErrorText) {
                    this.ErrorText = ErrorText;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    let str1 = value + "";
                    return new RegExp("[^@]+[@][^@]+").test(str1);
                }
            }
            class StringLengthValidator {
                constructor(ErrorText, MinimumLength, MaximumLength) {
                    this.ErrorText = ErrorText;
                    this.MinimumLength = MinimumLength;
                    this.MaximumLength = MaximumLength;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    // if not null, lenght must be in range
                    let str1 = value + "";
                    return str1.length >= (this.MinimumLength || 0) && str1.length <= (this.MaximumLength || Number.MAX_VALUE);
                }
            }
            class RegularExpressionValidator {
                constructor(ErrorText, RegexPattern) {
                    this.ErrorText = ErrorText;
                    this.RegexPattern = RegexPattern;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    let str1 = value + "";
                    if (String.IsNullOrEmpty(str1))
                        return true;
                    return new RegExp(this.RegexPattern).test(str1);
                }
            }
            class RangeValidator {
                constructor(ErrorText, Minimum, Maximum) {
                    this.ErrorText = ErrorText;
                    this.Minimum = Minimum;
                    this.Maximum = Maximum;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    // if not null, lenght must be in range
                    let val1 = parseFloat(value + "");
                    if (!Calysto.Type.TypeInspector.IsNumber(val1))
                        return false;
                    return val1 >= (this.Minimum || Number.MIN_VALUE) && val1 <= (this.Maximum || Number.MAX_VALUE);
                }
            }
            class MinLengthValidator {
                constructor(ErrorText, Length) {
                    this.ErrorText = ErrorText;
                    this.Length = Length;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    // if not null, lenght must be in range
                    let str1 = value + "";
                    return str1.length >= (this.Length || 0);
                }
            }
            class MaxLengthValidator {
                constructor(ErrorText, Length) {
                    this.ErrorText = ErrorText;
                    this.Length = Length;
                }
                IsValid(value) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(value))
                        return true; // null is valid
                    // if not null, lenght must be in range
                    let str1 = value + "";
                    return str1.length <= (this.Length || Number.MAX_VALUE);
                }
            }
            class FileExtensionsValidator {
                /**
                 *
                 * @param ErrorText
                 * @param Extensions example: "png,jpg,jpeg,gif"
                 */
                constructor(ErrorText, Extensions) {
                    this.ErrorText = ErrorText;
                    this.Extensions = Extensions;
                }
                IsValid(filename) {
                    if (Calysto.Type.TypeInspector.IsNullOrUndefined(filename))
                        return true; // null is valid
                    let str1 = filename + "";
                    let match1 = str1.match(new RegExp("[\\w]+$")); // extract extension
                    if (match1 && match1[0]) {
                        let extension = match1[0];
                        return ("," + this.Extensions + ",").Contains("," + extension + ",");
                    }
                    return false;
                }
            }
            class CompareValidator {
                constructor(ErrorText, OtherProperty, Context) {
                    this.ErrorText = ErrorText;
                    this.OtherProperty = OtherProperty;
                    this.Context = Context;
                }
                IsValid(value2) {
                    var _a;
                    // OtherProperty: *.NewPassword
                    let prop2 = this.OtherProperty.ReplaceAll("*", "");
                    for (let prop1 in this.Context.inputs) {
                        if (prop1 == prop2 || (prop2.charAt(0) == "." && prop1.EndsWith(prop2))) {
                            let value1 = (_a = this.Context.inputs[prop1]) === null || _a === void 0 ? void 0 : _a.value;
                            return Calysto.Type.TypeInspector.AreValuesEqual(value2, value1);
                        }
                    }
                    return false;
                }
            }
            //#endregion
        })(Validators = DataAnnotations.Validators || (DataAnnotations.Validators = {}));
    })(DataAnnotations = Calysto.DataAnnotations || (Calysto.DataAnnotations = {}));
})(Calysto || (Calysto = {}));
/// <reference path="calystovalidators.ts" />
var Calysto;
(function (Calysto) {
    var DataAnnotations;
    (function (DataAnnotations) {
        class CalystoValidationService {
            constructor(Context) {
                this.Context = Context;
            }
            /** validate form */
            Validate() {
                this.Context.errors.Clear();
                for (let name in this.Context.inputs)
                    RunValidationSingle(this.Context, this.Context.inputs[name]);
                return this;
            }
            /** Render errors */
            Render() {
                RenderErrorsWorker(this.Context);
                return this;
            }
            HasErrors() { return this.Context.errors.Any(); }
            /**
             * Enable or disable
             * @param enable
             */
            Interactive(enable) {
                this.Context.isInteractive = !!enable;
                if (enable)
                    InitializeInteractiveValidation(this.Context);
                return this;
            }
        }
        function FindContainerForm(sender) {
            if (!sender.$$validationContainer) {
                if (sender.tagName.toLowerCase() == "form")
                    sender.$$validationContainer = sender;
                else
                    sender.$$validationContainer = $$calysto(sender).AncestorNodes("form").First();
            }
            return sender.$$validationContainer;
        }
        /**
        * Find parent form and create new CalystoValidationService where form is container.
        * Returns null if client side validation is not enabled.
        * @param element
        */
        function FindValidationService(element) {
            let form = FindContainerForm(element);
            return UseValidationService(form);
        }
        DataAnnotations.FindValidationService = FindValidationService;
        function UseValidationService(containerSelector) {
            let form = $$calysto(containerSelector).First();
            let context = GetOrCreateValidationContext(form);
            return new CalystoValidationService(context);
        }
        DataAnnotations.UseValidationService = UseValidationService;
        let _contextCache = {};
        function GetOrCreateValidationContext(form) {
            let guid = form.$$validationGuid || (form.$$validationGuid = Calysto.Utility.Generators.GenerateLabel(20));
            let context = _contextCache[guid] || (_contextCache[guid] = {});
            context.form = form;
            context.errors = context.errors || [];
            context.inputsArr = $$calysto(form).Query("//[data-val=true][name]").ToArray();
            // input, textarea, select
            context.inputs = $$calysto(context.inputsArr).ToRawObject(o => o.name);
            // placeholders for error messages
            context.spans = $$calysto("[data-valmsg-for]").ToRawObject(o => o.getAttribute("data-valmsg-for"), o => o);
            // validation summary
            context.summary = $$calysto("[data-valmsg-summary]").ToArray();
            return context;
        }
        function InitializeInteractiveValidation(context) {
            // assing events if they are not assigned
            $$calysto(context.inputsArr)
                .Where(o => !o.$$validationInitialized)
                .ForEach(o => o.$$validationInitialized = true)
                .ForEach(o => o.$$validationContext = context)
                ////.OnChange((sender, ev) => RunValidationSingle(sender))
                .OnInput((sender, ev) => {
                if (!context.isInteractive)
                    return;
                //#if DEBUG
                if (Calysto.Core.IsDebugDefined) {
                    //console.log(sender.name, ev.type);
                }
                //#endif
                RunValidationSingle(context, sender);
                RenderErrorsWorker(context);
            }); // all elements have this event, after paste, ddl change
        }
        function RunValidationSingle(context, sender) {
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                //	console.log("RunValidation@ " + sender.name + ": " + sender.value);
            }
            //#endif
            context.errors.RemoveBy(o => o.FormsNamePath == sender.name);
            // empty string must be converted to null for validations to work properly (it is logic from C# validators)
            let value1 = sender.value === "" ? null : sender.value;
            // it is important to keep the same order as in data model, but seem that attributes are backwarded
            let validators = sender.$$validationValidators || (sender.$$validationValidators = DataAnnotations.Validators.GetValidators(sender, context).Reverse());
            for (let validator of validators) {
                if (!validator.IsValid(value1)) {
                    context.errors.Add({
                        FormsNamePath: sender.name,
                        ErrorText: validator.ErrorText
                    });
                }
            }
            //#if DEBUG
            if (Calysto.Core.IsDebugDefined) {
                //	console.log(context.errors);
            }
            //#endif
        }
        function RenderErrorsWorker(context) {
            let state = new Calysto.Web.UI.Direct.CalystoMvcModelState();
            state.RootSelector = context.form;
            for (let err1 of context.errors)
                state.Errors.push(new Calysto.KeyValue(err1.FormsNamePath, err1.ErrorText));
            state.Render();
        }
    })(DataAnnotations = Calysto.DataAnnotations || (Calysto.DataAnnotations = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var WebControls;
    (function (WebControls) {
        var CalystoTable;
        (function (CalystoTable) {
            let _cssLoaded = false;
            function EnsureCss() {
                if (!_cssLoaded) {
                    _cssLoaded = true;
                    let url = new Calysto.Web.CalystoVirtualPathHelper(`~/Engine/Src/Core/WebControls/Table/Table.css?v=${Calysto.Core.Constants.ModuleVersion}`).ToVirtualUrlPath();
                    Calysto.ScriptLoader.LoadCSSFile(url);
                }
            }
            let SortDirection;
            (function (SortDirection) {
                SortDirection[SortDirection["None"] = 0] = "None";
                SortDirection[SortDirection["Desc"] = 1] = "Desc";
                SortDirection[SortDirection["Asc"] = 2] = "Asc";
            })(SortDirection || (SortDirection = {}));
            function MakeSortable(tableSlector) {
                EnsureCss();
                $$calysto(tableSlector)
                    .AddClass("calystoSortableTable")
                    .Where(o => !o.$$tableIsSortable)
                    .ForEach(o => {
                    o.$$tableIsSortable = true;
                    MakeTableSortable(o);
                });
            }
            CalystoTable.MakeSortable = MakeSortable;
            function MakeTableSortable(table) {
                let headTds = $$calysto(table).Query("table tr:take(1)")
                    .Query(">td, >th").ForEach((td, index) => td.$$columnIndex = index)
                    .ToArray();
                headTds.AsEnumerable().AsDomQuery().OnHover((sender, ev) => {
                    sender.style.cursor = "pointer";
                    sender.style.textDecoration = "underline";
                }, (sender, ev) => {
                    sender.style.cursor = "";
                    sender.style.textDecoration = "";
                })
                    .OnClick((sender, ev) => {
                    SortBy(sender, table, headTds);
                });
            }
            function GetSortClass(sort) {
                switch (sort) {
                    case SortDirection.Asc: return "sortasc";
                    case SortDirection.Desc: return "sortdesc";
                    default: return "";
                }
            }
            function SortBy(headTd, table, headTds) {
                if ((headTd.$$sortDirection || SortDirection.None) == SortDirection.None) {
                    if (table.$$unsortedRows) {
                        // restore original order
                        table.$$unsortedRows.ForEach(tr => { var _a; return (_a = tr.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(tr); });
                    }
                    else {
                        table.$$unsortedRows = $$calysto(table).Query("table tr:skip(1)").ToArray();
                    }
                }
                headTd.$$sortDirection = ((headTd.$$sortDirection || SortDirection.None) + 1) % 3;
                // remove sort from other columns
                headTds.Where(o => o != headTd).ForEach(o => o.$$sortDirection = SortDirection.None);
                // add class to current sort column
                $$calysto(headTds).RemoveClass("sortasc").RemoveClass("sortdesc")
                    .Where(o => o == headTd)
                    .ForEach(o => o.className += " " + GetSortClass(o.$$sortDirection));
                // skip first row and select
                var items = $$calysto(table).Query("table tr:skip(1)").Select(tr => {
                    var val = $$calysto(tr).ChildNodes("td")
                        .Where((o, n) => n == headTd.$$columnIndex)
                        .Select(o => Calysto.Utility.Dom.GetInnerText(o))
                        .FirstOrDefault();
                    var numStr = (val || "").ReplaceAll(",", ".").ReplaceAll(" ", "").ReplaceAll(" " /*xA0 or &nbsp;*/, ""); // eg. - 55,66 convert to US and remove space: -5566
                    var number = parseFloat(numStr);
                    var txt = val.toLowerCase();
                    var considerNumber = numStr == "" || numStr == " " /*&nbsp;*/ || numStr == (number + "") || numStr.indexOf(number + "") == 0;
                    return {
                        tr: tr,
                        str: txt,
                        num: isNaN(number) || (considerNumber && isNaN(number)) ? Number.MIN_VALUE : number,
                        isNum: considerNumber
                    };
                }).ToList().AsDomQuery();
                var numericSort = items.All(o => o.isNum);
                let sortedRows;
                // sort in reversed order than was the first time
                // asc or desc
                let sortDesc = headTd.$$sortDirection == SortDirection.Desc;
                if ((headTd.$$sortDirection || 0) == SortDirection.None) {
                    sortedRows = table.$$unsortedRows;
                }
                else {
                    sortedRows = items.OrderBy(o => numericSort ? o.num : o.str, sortDesc).Select(o => o.tr).ToArray();
                }
                // the same tr will be set at different position, no cloning, no removal from DOM
                sortedRows.ForEach(tr => { var _a; return (_a = tr.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(tr); });
            }
        })(CalystoTable = WebControls.CalystoTable || (WebControls.CalystoTable = {}));
    })(WebControls = Calysto.WebControls || (Calysto.WebControls = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var Web;
    (function (Web) {
        var UI;
        (function (UI) {
            var Direct;
            (function (Direct) {
                let Kind;
                (function (Kind) {
                    /// <summary>
                    /// black text
                    /// </summary>
                    //[StringValue("black")]
                    Kind[Kind["Message"] = 0] = "Message";
                    /// <summary>
                    /// red text
                    /// </summary>
                    //[StringValue("red")]
                    Kind[Kind["Error"] = 1] = "Error";
                    /// <summary>
                    /// orange text
                    /// </summary>
                    //[StringValue("orange")]
                    Kind[Kind["Warning"] = 2] = "Warning";
                    /// <summary>
                    /// green text
                    /// </summary>
                    //[StringValue("green")]
                    Kind[Kind["Success"] = 3] = "Success";
                    /// <summary>
                    /// blue tekst
                    /// </summary>
                    //[StringValue("blue")]
                    Kind[Kind["Info"] = 4] = "Info";
                })(Kind = Direct.Kind || (Direct.Kind = {}));
                function GetKindColor(kind) {
                    switch (kind) {
                        case "Message": return "black";
                        case "Error": return "red";
                        case "Warning": return "orange";
                        case "Success": return "green";
                        case "Info": return "blue";
                        default: return "black";
                    }
                }
                class CalystoHtmlBuilder {
                    constructor() {
                        this._messages = [];
                    }
                    AddMessage(kind, text) {
                        this._messages.Add(new Calysto.KeyValue(kind, text));
                        return this;
                    }
                    GetMessagesTags() {
                        let _this11 = this;
                        let fn1 = function* () {
                            for (var item of _this11._messages) {
                                let color = GetKindColor(item.Key);
                                yield `<div class="calysto-html-builder-message-${color}" style="color:${color}">${Calysto.Utility.Html.HtmlEncode(item.Value)}</div>`;
                            }
                        };
                        return new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.From(fn1));
                    }
                    GetHtmlElements() {
                        return this.GetMessagesTags();
                    }
                    HasElements() { return this.GetHtmlElements().Any(); }
                    /**
                     * Create parentTag element and add items as children.
                     * @param parentTag
                     * @param parentClass
                     */
                    ToHtml() {
                        return this.GetHtmlElements().ToStringJoined();
                    }
                }
                Direct.CalystoHtmlBuilder = CalystoHtmlBuilder;
            })(Direct = UI.Direct || (UI.Direct = {}));
        })(UI = Web.UI || (Web.UI = {}));
    })(Web = Calysto.Web || (Calysto.Web = {}));
})(Calysto || (Calysto = {}));
/// <reference path="CalystoHtmlBuilder.ts" />
var Calysto;
(function (Calysto) {
    var Web;
    (function (Web) {
        var UI;
        (function (UI) {
            var Direct;
            (function (Direct) {
                class CalystoMvcModelState {
                    /**
                     * ctor is used in C# CalystoMvcModelState.ToJavaScript()
                     * @param raw
                     * @param rootSelector
                     * @param errors
                     * @param values
                     */
                    constructor(raw, rootSelector, errors, values) {
                        this.Errors = [];
                        this.Values = [];
                        this.Raw = raw || {};
                        if (rootSelector)
                            this.RootSelector = rootSelector;
                        if (errors)
                            this.Errors = errors;
                        if (values)
                            this.Values = values;
                    }
                    AddError(pathExpression, errorMsg) {
                        this.Errors.push(new Calysto.KeyValue(Calysto.Utility.Expressions.ParsePath(pathExpression), errorMsg));
                    }
                    SetValue(pathExpression, value) {
                        let path = Calysto.Utility.Expressions.ParsePath(pathExpression);
                        let item = this.Values.Where(o => o.Key == path).pop();
                        if (item)
                            item.Value = value;
                        else
                            this.Values.push(new Calysto.KeyValue(path, value + ""));
                        Calysto.DataBinder.SetValue(this.Raw, path, value);
                    }
                    /**
                     * Query DOM elements.
                     * @param pathExpression
                     */
                    Query(pathExpression) {
                        let path = Calysto.Utility.Expressions.ParsePath(pathExpression);
                        return $$calysto("[name=" + path + "]");
                    }
                    UseDirectQuery(selector, action) {
                        let query;
                        if (this.RootSelector)
                            query = $$calysto(this.RootSelector).Query("*, //*").Query(selector);
                        else
                            query = $$calysto(selector);
                        action(query);
                        return this;
                    }
                    ClearErrors() {
                        // clean previous validators messages and summary message
                        this.UseDirectQuery("input[name], textarea[name], select[name]", a => a.RemoveClass("input-validation-error"))
                            .UseDirectQuery("span[data-valmsg-for]", a => a.SetInnerHtml(null).RemoveClass("field-validation-error").AddClass("field-validation-valid"))
                            .UseDirectQuery("div[data-valmsg-summary]", a => a.SetInnerHtml(null).RemoveClass("validation-summary-errors").AddClass("validation-summary-valid"));
                    }
                    RenderErrors() {
                        // create new errors
                        this.Errors.AsEnumerable().GroupBy(o => o.Key).ToList().ForEach(group => {
                            // name may have index: Color[2].Size, so we must use qery attribute by name
                            this.UseDirectQuery(`[name=${group.Key}]`, a => a.AddClass("input-validation-error"));
                            this.UseDirectQuery(`[data-valmsg-for=${group.Key}]`, a => a.AddClass("field-validation-error")
                                .AddChildren(group.Select(err => `<span>${Calysto.Utility.Html.HtmlEncodeSimple(err.Value)}</span>`).ToStringJoined("<br/>")));
                        });
                        // create validation summary
                        if (this.Errors.Any()) {
                            let lis = this.Errors.Select(err => `<li>${Calysto.Utility.Html.HtmlEncodeSimple(err.Value)}</li>`).ToStringJoined();
                            this.UseDirectQuery("div[data-valmsg-summary]", a => a.AddChildren(`<ul>${lis}</ul>`)
                                .RemoveClass("validation-summary-valid")
                                .AddClass("validation-summary-errors"));
                        }
                    }
                    RenderValues() {
                        // build js command to set values to elements
                        for (let val1 of this.Values) {
                            this.UseDirectQuery(`[name=${val1.Key}]`, a => a.SetValueOrInnerHtml(val1.Value));
                        }
                    }
                    Render() {
                        this.ClearErrors();
                        this.RenderErrors();
                        this.RenderValues();
                    }
                }
                Direct.CalystoMvcModelState = CalystoMvcModelState;
            })(Direct = UI.Direct || (UI.Direct = {}));
        })(UI = Web.UI || (Web.UI = {}));
    })(Web = Calysto.Web || (Calysto.Web = {}));
})(Calysto || (Calysto = {}));
var Calysto;
(function (Calysto) {
    var WebControls;
    (function (WebControls) {
        /* CalystoScroller html example:
            
            create div with long content horizontaly or verticaly like this:
                <div class="calystoScroller" style="overflow:hidden;position:relative;width:200px;height:120px;;border:solid 1px green;">
                    <div class="calystoScrollerContent" style="background-color:lavenderblush;height:200px;width:800px;">ovo je veliki sadrzaj</div>
                </div>
        
            and it will add controls into div.calystoScroller
         
            how to use it:
            Calysto.Page.OnInteractive.Add(function ()
            {
                Calysto.Web.UI.WebControls.CalystoScroller.Create(".calystoScroller");
            });
        */
        let _cssLoaded = false;
        function EnsureCss() {
            if (!_cssLoaded) {
                _cssLoaded = true;
                let url = new Calysto.Web.CalystoVirtualPathHelper(`~/Engine/Src/Core/WebControls/Scroller/Scroller.css?v=${Calysto.Core.Constants.ModuleVersion}`).ToVirtualUrlPath();
                Calysto.ScriptLoader.LoadCSSFile(url);
            }
        }
        var _html = `<div class="calystoScrollerCtrl calystoScrollerY">
			<div class="calystoScrollerMarker"></div>
		</div>
		<div class="calystoScrollerCtrl calystoScrollerX">
			<div class="calystoScrollerMarker"></div>
		</div>`;
        class CalystoScroller {
            constructor(mainElement) {
                /** scrollbar min opacity, 0 - 100 */
                this.MinOpacity = 10;
                /** scrollbar max opacity, 0 - 100 */
                this.MaxOpacity = 100;
                this.firstInitDone = false;
                this.contentElWidth = -1;
                this.contentElHeight = -1;
                this.mainElWidth = -1;
                this.mainElHeight = -1;
                EnsureCss();
                this.mainEl = mainElement;
            }
            /** current top position (negative number) */
            get CurrentTop() { return this._currentTop; }
            set CurrentTop(value) { this.SetScrollPosition(value, null); }
            /** current left position (negative number) */
            get CurrentLeft() { return this._currentLeft; }
            set CurrentLeft(value) { this.SetScrollPosition(null, value); }
            //#region mouse wheel handling
            ScrollersAdjustContent(top, left) {
                // contentEl je siri od mainEl
                // slider ima hod jednak sirini mainEl pa se top i left moraju povecati tako da kad dodje do kraja mainEl-a, contentEl se cijeli pomakne
                let top1 = -1 * (top / this.maxMarkerTop) * (this.contentEl.scrollHeight - this.mainEl.clientHeight);
                let left1 = -1 * (left / this.maxMarkerLeft) * (this.contentEl.scrollWidth - this.mainEl.clientWidth);
                return this.SetScrollPosition(top1, left1);
            }
            SetScrollPosition(top, left) {
                if (typeof (top) == "number") {
                    this.minContentTop = this.mainEl.clientHeight - this.contentEl.scrollHeight; // let's calculate every time, it is safer
                    if (top > 0) {
                        top = 0;
                    }
                    if (top < this.minContentTop) {
                        top = this.minContentTop;
                    }
                    top = Math.round(top);
                    this._currentTop = top;
                    this.contentEl.style.marginTop = top + "px";
                    var markerTop = -1 * (this.contentEl.offsetTop / this.contentEl.scrollHeight * (this.vSliderEl.offsetHeight));
                    this.vMarkerEl.style.top = Math.round(markerTop) + "px";
                }
                if (typeof (left) == "number") {
                    this.minContentLeft = this.mainEl.clientWidth - this.contentEl.scrollWidth;
                    if (left > 0) {
                        left = 0;
                    }
                    if (left < this.minContentLeft) {
                        left = this.minContentLeft;
                    }
                    left = Math.round(left);
                    this._currentLeft = left;
                    this.contentEl.style.marginLeft = left + "px";
                    var markerLeft = -1 * (this.contentEl.offsetLeft / this.contentEl.scrollWidth * (this.hSliderEl.offsetWidth));
                    this.hMarkerEl.style.left = Math.round(markerLeft) + "px";
                }
                return { endH: left == 0 || left == this.minContentLeft, endV: top == 0 || top == this.minContentTop }; // means scroll is at the end, so continue scrolling page
            }
            WheelAdjustSliderX(sender, ev) {
                if (this.showHorizontal) {
                    ev = ev || {};
                    var deltaX = 0;
                    if ("deltaX" in ev) {
                        deltaX = ev.deltaX;
                    }
                    else if ("wheelDeltaX" in ev) {
                        deltaX = -(ev.wheelDeltaX);
                    }
                    // ev.deltaMode: 0=pixel, 1=line, 2=page
                    // ev.axis: 1=horizontal, 2=vertical
                    if (ev.deltaMode == 1) {
                        deltaX *= 30;
                    }
                    var left = this.contentEl.offsetLeft - deltaX;
                    this.SetScrollPosition(null, left);
                }
            }
            WheelAdjustSliderY(sender, ev) {
                // ako je shift key, mouse wheel koristimo za pomicanje lijevo-desno
                if (this.showVertical || (ev === null || ev === void 0 ? void 0 : ev.shiftKey)) {
                    ev = ev || {};
                    var deltaY = 0;
                    if ("deltaY" in ev) {
                        deltaY = ev.deltaY;
                    }
                    else if ("wheelDeltaY" in ev) {
                        deltaY = -(ev.wheelDeltaY);
                    }
                    // ev.deltaMode: 0=pixel, 1=line, 2=page
                    // ev.axis: 1=horizontal, 2=vertical
                    if (ev.deltaMode == 1) {
                        deltaY *= 30;
                    }
                    if (ev.shiftKey) {
                        // use mouse wheel to move left-right
                        var left = this.contentEl.offsetLeft - deltaY;
                        this.SetScrollPosition(null, left);
                    }
                    else {
                        // move up-down
                        var top = this.contentEl.offsetTop - deltaY;
                        this.SetScrollPosition(top, null);
                    }
                }
            }
            WheelAdjustSliders(sender, ev) {
                this.WheelAdjustSliderX(sender, ev);
                this.WheelAdjustSliderY(sender, ev);
            }
            //#endregion
            //#region velocity handling
            /**
             *
             * @param sender
             * @param velocity pixel/second
             * @param isAxisY
             */
            CreateAnimator(sender, velocity, isAxisY) {
                this.accelerationAbort = false;
                var lastVal = 0;
                // izgleda prirodno za ovu kombinaciju: velocity/3, easeOutQuart, duration 1000
                var animator = new Calysto.Animator().AddValue(0, velocity / 3, (anim, currVal) => {
                    if (this.accelerationAbort) {
                        anim.Abort();
                    }
                    else {
                        var obj = {};
                        obj[isAxisY ? "deltaY" : "deltaX"] = lastVal - currVal;
                        if (isAxisY) {
                            this.WheelAdjustSliderY(sender, obj);
                        }
                        else {
                            this.WheelAdjustSliderX(sender, obj);
                        }
                        lastVal = currVal;
                    }
                }).Easing("easeOutQuart").Duration(1000).Start();
            }
            CalculateVelocity(sender, statArr) {
                var dt = new Date().getTime();
                var list = new Calysto.List(statArr).Reverse().Take(10).ToList();
                var first = list.FirstOrDefault();
                var last = list.LastOrDefault();
                if (first && last && first.ev && last.ev && first.time && last.time) {
                    return {
                        deltaX: last.ev.pageX - first.ev.pageX,
                        deltaY: last.ev.pageY - first.ev.pageX,
                        /**pixel/second*/
                        velocityX: (last.ev.pageX - first.ev.pageX) / (last.time - first.time) * 1000 || 0,
                        /**pixel/second*/
                        velocityY: (last.ev.pageY - first.ev.pageY) / (last.time - first.time) * 1000 || 0,
                        items: statArr === null || statArr === void 0 ? void 0 : statArr.length
                    };
                }
                return undefined;
            }
            HandleAcceleration(sender, statArr) {
                var velocityObj = this.CalculateVelocity(sender, statArr);
                if (!velocityObj) {
                    return;
                }
                if (this.showVertical && velocityObj.velocityY && Math.abs(velocityObj.deltaY || 0) > 10) {
                    this.CreateAnimator(sender, velocityObj.velocityY, true);
                }
                if (this.showHorizontal && velocityObj.velocityX && Math.abs(velocityObj.deltaX || 0) > 10) {
                    this.CreateAnimator(sender, velocityObj.velocityX, false);
                }
            }
            //#endregion
            //#region initialize
            InitElements() {
                /// <summary>
                /// Has to mesure elements and adjust scrollbars. Has to be invoked again if container dimensions are changed.
                /// </summary>
                var _a, _b, _c, _d;
                // ova funkcija se poziva na kraju iz timera skvakih 1-2 sekunde ako se content resiza da se postave kontrole scrollera ispravno
                if (!this.firstInitDone) {
                    this.firstInitDone = true;
                    // this.mainEl is scroll-container
                    // make sure it has overflow:hidden and position relative since sliders are absolute
                    this.contentEl = $$calysto(this.mainEl).ApplyStyle("overflow:hidden;position:relative;")
                        .ChildNodes().Where(function (o) { return o.nodeType == 1; }).First(); // first level child only
                    $$calysto(this.mainEl).AddChildren(_html);
                }
                // iPhone problem i rjesenje:
                // treba gledati contentEl.scrollWidth jer on prikazuje pravu sirinu contenta koji je siri od mainEl contenta
                // da bi radio contentEl.style.marginLeft, treba postaviti contentEl.style.width = contentEl.scrollWidth + "px"
                let contentWidth = this.contentEl.scrollWidth; // radi iPhonea gledati scrollWidth jer pokazuje stvranu sirinu
                this.contentEl.style.width = contentWidth + "px";
                this.hSliderEl = $$calysto(this.mainEl).Query("//.calystoScrollerX").SetOpacity(0).ApplyStyle("display", "block").First();
                this.hMarkerEl = $$calysto(this.hSliderEl).Query("//.calystoScrollerMarker").First();
                this.hAR = this.mainEl.clientWidth / contentWidth;
                this.showHorizontal = this.hAR < 1;
                let contentHeight = this.contentEl.scrollHeight;
                this.contentEl.style.height = contentHeight + "px";
                this.vSliderEl = $$calysto(this.mainEl).Query("//.calystoScrollerY").SetOpacity(0).ApplyStyle("display", "block").First();
                this.vMarkerEl = $$calysto(this.vSliderEl).Query("//.calystoScrollerMarker").First();
                this.vAR = this.mainEl.clientHeight / contentHeight;
                this.showVertical = this.vAR < 1;
                $$calysto(this.vSliderEl).SetOpacity(this.MinOpacity).ApplyStyle("display", this.showVertical ? "block" : "none");
                $$calysto(this.hSliderEl).SetOpacity(this.MinOpacity).ApplyStyle("display", this.showHorizontal ? "block" : "none");
                this.hMarkerEl.style.width = Math.round(this.hSliderEl.offsetWidth * this.hAR) + "px";
                this.maxMarkerLeft = ((_b = (_a = this.hMarkerEl) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b["clientWidth"]) - this.hMarkerEl.offsetWidth;
                this.vMarkerEl.style.height = Math.round(this.vSliderEl.offsetHeight * this.vAR) + "px";
                this.maxMarkerTop = ((_d = (_c = this.vMarkerEl) === null || _c === void 0 ? void 0 : _c.parentNode) === null || _d === void 0 ? void 0 : _d["clientHeight"]) - this.vMarkerEl.offsetHeight;
            }
            // on iPhone event object is reused, so create it's copy
            // na iPhoneu se event objekt reusa pa treba skopirati vrijednosti:
            CopyEvent(ev) {
                if (ev) {
                    return { pageX: ev.pageX, pageY: ev.pageY, clientX: ev.clientX, clientY: ev.clientX };
                }
                return null;
            }
            InitializeEvents() {
                // this.hMarkerEl, this.vMarkerEl
                $$calysto([this.hMarkerEl, this.vMarkerEl]).On(["mousedown", "touchstart"], (sender, ev) => {
                    this.markerDragging = sender;
                });
                let faderAnimator;
                let currentShowState = "None";
                let fnScrollbarsShow = () => {
                    if (currentShowState == "Showing")
                        return;
                    currentShowState = "Showing";
                    faderAnimator === null || faderAnimator === void 0 ? void 0 : faderAnimator.Abort();
                    faderAnimator = $$calysto([this.hSliderEl, this.vSliderEl]).ToAnimator({ opacity: this.MaxOpacity }).Start();
                };
                let fnScrollbarsHide = () => {
                    if (currentShowState == "Hiding")
                        return;
                    currentShowState = "Hiding";
                    faderAnimator === null || faderAnimator === void 0 ? void 0 : faderAnimator.Abort();
                    faderAnimator = $$calysto([this.hSliderEl, this.vSliderEl]).ToAnimator({ opacity: this.MinOpacity }).Start();
                };
                // this.mainEl
                $$calysto(this.mainEl).ForEach((el, n) => {
                    // create initial slider and apply settings
                    $$calysto([this.hSliderEl, this.vSliderEl]).SetOpacity(this.MinOpacity);
                    this.WheelAdjustSliders(el, null);
                }).On(["hover", "mouseover", "mousemove", "wheel"], (sender, ev) => {
                    fnScrollbarsShow();
                }).On(["hout"], (sender, ev) => {
                    // on mobile, mouseout triggers when we click something else, different element from element where touchstart was triggered
                    // on mobile on touch events are triggered: touchstart, toucheend, mouseover, mousedown, so it would keep 100% opaciti, so use hack:
                    fnScrollbarsHide();
                }).On(["scroll", "mousewheel", "wheel", "DOMMouseScroll"], (sender, ev) => {
                    let doAdjust = false;
                    if (this.showVertical && (ev.type == "wheel" || ev.type == "mousewheel")) {
                        doAdjust = true;
                    }
                    else if (this.showHorizontal && (ev === null || ev === void 0 ? void 0 : ev["shiftKey"])) {
                        doAdjust = true;
                    }
                    else if (this.showHorizontal && (Math.abs(ev === null || ev === void 0 ? void 0 : ev["deltaX"]) > 0 || Math.abs(ev === null || ev === void 0 ? void 0 : ev["wheelDeltaX"]) > 0)) {
                        doAdjust = true;
                    }
                    if (doAdjust) {
                        this.WheelAdjustSliders(sender, ev);
                        return false; // stop propagation
                    }
                    return true;
                    ////}).On(["keydown"], function (sender, ev)
                    ////{
                    ////	// WRITE THE CODE: up, down, left, right, page up, page down
                }).On(["mousedown", "touchstart"], (sender, ev) => {
                    if (ev.type == "touchstart") {
                        ev = ev.touches[0];
                    }
                    this.moveStatistics = [];
                    this.accelerationAbort = true;
                    this.startCondition = {
                        event: this.CopyEvent(ev),
                        contentLeft: this.contentEl.offsetLeft,
                        contentTop: this.contentEl.offsetTop,
                        vMarkerTop: this.vMarkerEl.offsetTop,
                        hMarkerLeft: this.hMarkerEl.offsetLeft
                    };
                    // return true or nothing to propagate click event if it is touchstart
                    // return true; // stop propagation
                });
                // document
                $$calysto(document).On(["mouseup", "touchend"], (sender, ev) => {
                    if (this.moveStatistics && !this.markerDragging) {
                        this.HandleAcceleration(this.mainEl, this.moveStatistics);
                    }
                    this.moveStatistics = null;
                    this.markerDragging = null;
                    this.startCondition = null;
                });
                // As stated by Google, they've changed the behavior of passive event listeners only for window, document or body elements.
                // so make touchmove event bind to div element intead, not document
                // trebamo event na document da bi radilo povlacenje scrollbara dobro
                // trebamo event na mainEl da bi na mobitelu radilo povlacenje contenta dobro
                $$calysto([document, this.mainEl]).On(["mousemove", "touchmove"], (sender, ev) => {
                    if (!this.startCondition) {
                        return true;
                    }
                    if (ev.type == "touchmove") {
                        ev = ev.touches[0];
                    }
                    fnScrollbarsShow();
                    this.moveStatistics.push({ time: new Date().getTime(), ev: this.CopyEvent(ev) });
                    if (this.markerDragging == this.hMarkerEl) {
                        var left = Math.round(this.startCondition.hMarkerLeft - (this.startCondition.event.pageX - ev.pageX));
                        this.ScrollersAdjustContent(null, left);
                        return false; // stop propagation
                    }
                    else if (this.markerDragging == this.vMarkerEl) {
                        var top = Math.round(this.startCondition.vMarkerTop - (this.startCondition.event.pageY - ev.pageY));
                        this.ScrollersAdjustContent(top, null);
                        return false; // stop propagation
                    }
                    else if (!this.markerDragging) {
                        // content dragging
                        var deltaY = this.startCondition.event.pageY - ev.pageY;
                        var deltaX = this.startCondition.event.pageX - ev.pageX;
                        var top = Math.round(this.startCondition.contentTop - deltaY);
                        var left = Math.round(this.startCondition.contentLeft - deltaX);
                        var res = this.SetScrollPosition(top, left);
                        // on Android, we may return true always, if it is at the scroll end, it will contine with page scroll
                        // this is required on iPhone because it scrolls scroll element and page at the same time
                        // if comes to scroll end, continue event propagation to the page
                        // if didn't come to scoll end, stop propagation, return false
                        // iPhone is reusing event object
                        if (Math.abs(deltaX) > 10 && (res === null || res === void 0 ? void 0 : res.endH)) {
                            return true; // continue with page scroll
                        }
                        else if (Math.abs(deltaY) > 10 && (res === null || res === void 0 ? void 0 : res.endV)) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                });
            }
            Start() {
                this.InitElements();
                this.InitializeEvents();
                var _interval1 = setInterval(() => {
                    if (!this.contentEl || !this.mainEl || !(this.contentEl.scrollHeight > 0) || !(this.contentEl.scrollWidth > 0)) {
                        // if removed from DOM, don't clear timeout, it may be reattached to dom later
                        return;
                    }
                    if (this.contentEl.scrollWidth != this.contentElWidth
                        || this.contentEl.scrollHeight != this.contentElHeight
                        || this.mainEl.clientWidth != this.mainElWidth
                        || this.mainEl.clientHeight != this.mainElHeight) {
                        this.contentElWidth = this.contentEl.scrollWidth;
                        this.contentElHeight = this.contentEl.scrollHeight;
                        this.mainElWidth = this.mainEl.clientWidth;
                        this.mainElHeight = this.mainEl.clientHeight;
                        this.InitElements();
                    }
                }, 2000);
            }
            //#endregion
            /**
            * Initialize calystoScroller. If content or container are resized, scroller is refreshed every 1 second.
            * @param selector if not provided, will select all elements with class calystoScroller
            */
            static Create(selector) {
                $$calysto(selector || ".calystoScroller").Where(function (o) { return !o.__calystoScroller; })
                    .ForEach(function (o) { o.__calystoScroller = true; })
                    .ForEach(function (o) {
                    let scr1 = new CalystoScroller(o);
                    scr1.Start();
                    o.__calystoScroller = scr1;
                });
            }
        }
        WebControls.CalystoScroller = CalystoScroller;
    })(WebControls = Calysto.WebControls || (Calysto.WebControls = {}));
})(Calysto || (Calysto = {}));
// tests moved to Calysto.Enumerable.TEST
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    //var en1 = Calysto.CalystoEnumerator.FromString("ovo je string");
    //var en2 = Calysto.CalystoEnumerator.From([1, 2, 3, 4]);
    //var en4 = new Calysto.CalystoEnumerable(() => Calysto.CalystoEnumerator.FromString("ovo je moj string"));
    //console.log(en4.Select(o => o).ToArray());
    //console.log(en4.ToArray());
    //console.log(en4.ToStringJoined("-"));
    var res1 = [{ Ime: "ante", Godine: [1, 2, 3, 4] }, { Ime: "ante2", Godine: [13, 2, 3, 4] }, { Ime: "ante", Godine: [5, 43, 4] }].AsEnumerable().SelectMany(o => o.Godine).ToArray();
    var res2 = ["fsdagasd", "fdder", "ff", "tt", "oc", "one", "one", "one", "two", "two", "nemza", "temza", "aa", "bb", "cc"]
        .AsEnumerable()
        //.Distinct()
        .OrderBy(o => o.length, true)
        .ThenBy(o => o, true)
        .ThenBy(o => o.length, true)
        //.GroupBy(o => o.length)
        //.Select(o => "Key: " + o.Key + ", Values: [" + o.ToStringJoined(", ") + "]")
        .Skip(1).Take(4)
        .ToStringJoined("; ");
    console.log("CalystoEnumerable test successful");
});
//#endif
// tests are in Calysto.Type.TEST
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var dic = new Calysto.Dictionary();
    dic.Add("dva", "fasdf");
    dic.Add(1, 3);
    dic.Add(5, 342352362344237623453734);
    dic.Add(51, 344237623453734);
    dic.Add(true, 344237623453734);
    dic.Add(false, 344237623453734);
    //dic.Add(() => { }, "novi");
    //dic.Add(() => { }, "novi");
    //dic.Add(() => { }, "novi");
    //dic.Add(() => { }, "novi");
    //console.log(dic.GetKeys());
    //console.log(dic.GetHashKeys()); // hash se mijenja za ref objekte, kao funkcije
    //console.log(dic.GetValues());
    //console.log(dic.GetItems());
    var res1 = [
        dic.Count(),
        dic.GetValue(5),
        dic.ContainsKey(51),
        dic.ContainsKey("51"),
        dic.GetKeys().join(","),
        dic.GetValues().join(",")
    ].join(";");
    let exp1 = "6;3.423523623442376e+23;true;false;dva,1,5,51,true,false;fasdf,3,3.423523623442376e+23,344237623453734,344237623453734,344237623453734";
    Calysto.TestTools.UnitTesting.Assert.AreEqual(exp1, res1);
    var dic2 = new Calysto.Dictionary();
    dic2.Add("name", "first").Add("last", "lastname");
    var res2 = [
        dic2.Count(),
        dic2.GetValues().join(","),
        dic2.GetKeys().join(",")
    ].join(";");
    Calysto.TestTools.UnitTesting.Assert.AreEqual("2;first,lastname;name,last", res2);
    console.log("Dictionary test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var res1 = [
        Calysto.Enum.GetNames(Calysto.Type.KnownType).join(","),
        Calysto.Enum.GetValues(Calysto.Type.KnownType).join(","),
        Calysto.Enum.GetValue(Calysto.Type.KnownType, "Boolean"),
        Calysto.Enum.GetValue(Calysto.Type.KnownType, "Number"),
        Calysto.Enum.GetName(Calysto.Type.KnownType, 3),
        Calysto.Enum.GetName(Calysto.DayOfWeek, 2),
        Calysto.Enum.GetValue(Calysto.DayOfWeek, "Monday"),
        Calysto.Enum.HasName(Calysto.DayOfWeek, "Monday"),
        Calysto.Enum.HasName(Calysto.DayOfWeek, "somename"),
        Calysto.Enum.HasName(Calysto.DayOfWeek, ""),
        Calysto.Enum.HasValue(Calysto.DayOfWeek, 3),
        Calysto.Enum.HasValue(Calysto.DayOfWeek, 33),
        Calysto.Enum.HasValue(Calysto.DayOfWeek, NaN)
    ].join(";");
    if (res1 != "String,Boolean,Decimal,Number,Integer,Array,Function,DateTime,Date,Any;1,2,3,4,5,6,7,8,9,10;2;4;Decimal;Tuesday;1;true;false;false;true;false;false") {
        throw new Error("Error in Calysto.Enum tests, result: " + res1);
    }
    console.log("Enum tests successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    function UsingCulture(culture, func) {
        // radi formatiranja brojeva u string:
        var original = Calysto.Globalization.CultureInfo.CurrentCulture;
        Calysto.Globalization.CultureInfo.CurrentCulture = culture || Calysto.Globalization.CultureInfo.USCulture; // set US culture as default
        func();
        Calysto.Globalization.CultureInfo.CurrentCulture = original; // restore culture
    }
    UsingCulture(Calysto.Globalization.CultureInfo.USCulture, function () {
        var isOldMsie = Calysto.Features.GetBrowser().KindName == "MSIE" && Calysto.Features.GetBrowser().Version <= 8;
        if (isOldMsie)
            return;
        //************************************************************************************************
        var list = new Calysto.List();
        Calysto.Collections.ForEachProperties(Calysto.Type.KnownType, function (name, value, index) {
            list.Add(name + ":" + value);
        });
        var res1 = list.ToStringJoined("; ");
        let exp1 = "1:String; 2:Boolean; 3:Decimal; 4:Number; 5:Integer; 6:Array; 7:Function; 8:DateTime; 9:Date; 10:Any; String:1; Boolean:2; Decimal:3; Number:4; Integer:5; Array:6; Function:7; DateTime:8; Date:9; Any:10";
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp1, res1);
        //************************************************************************************************
        var vals1 = [
            "s1",
            "",
            null,
            "true",
            true,
            false,
            undefined,
            2.34,
            5.41e+5,
            64,
            [3, 4, 2],
            document.documentElement.childNodes,
            function One() { return 3; },
            //document.documentElement.appendChild, // in IE8 this is object
            Calysto.DateTime.Now(),
            new Date(),
            { custom: "fsdfsad" }
        ];
        var list = new Calysto.List();
        for (var n = 0; n < vals1.length; n++) {
            try {
                list.Add(Calysto.Type.TypeDescriptor.FromValue(vals1[n]).NullableTypeName);
            }
            catch (e) {
                list.Add("unresolved");
            }
        }
        let exp2 = "String; String; Any?; String; Boolean; Boolean; Any?; Decimal; Decimal; Decimal; Array; Array; Function; DateTime; Date; unresolved";
        var res2 = list.ToStringJoined("; ");
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp2, res2);
        //************************************************************************************************
        // test convertion of all types to string
        // Calysto.TimeSpan testing
        //************************************************************************************************
        var vals2 = [
            "s1",
            "",
            null,
            "true",
            true,
            false,
            undefined,
            { value: 2.34, calystoFormat: "N3" },
            { value: 5.41345, calystoFormat: "n2" },
            { value: 5.41e+5, calystoFormat: "N4" },
            { value: 5.41e+5, calystoFormat: "C4" },
            { value: 5.41e+5, calystoFormat: "C4", culture: Calysto.Globalization.CultureInfo.HRCulture },
            64,
            [3, 4, 2],
            { value: Calysto.DateTime.ParseDateTime("18.5.2016. 22:44:26", "dd.MM.yyyy. HH:mm:ss"), culture: Calysto.Globalization.CultureInfo.USCulture },
            { value: Calysto.DateTime.ParseDateTime("18.5.2016. 22:44:26", "dd.MM.yyyy. HH:mm:ss"), culture: Calysto.Globalization.CultureInfo.HRCulture },
            { value: Calysto.DateTime.ParseDateTime("18.5.2016. 22:44:26", "dd.MM.yyyy. HH:mm:ss"), calystoFormat: "dd.MM.yyyy. HH:mm:ss.ff" },
            { value: new Calysto.DateTime("2016-05-19 02:44:00"), calystoFormat: "MM/dd/yyyy HH:mm" },
            { custom: "fsdfsad" },
            new Calysto.TimeSpan()
                .AddDays(2) // 172800s
                .AddHours(28) // 100800s
                .AddMinutes(14) // 840s
                .AddSeconds(156) // 156s
                .AddMilliseconds(1463) // 1.463s
                .AddTicks(234534) // 234.534s
        ];
        var list = new Calysto.List();
        for (var n = 0; n < vals2.length; n++) {
            try {
                var o1 = vals2[n];
                UsingCulture(o1 && o1.culture ? o1.culture : null, function () {
                    if (o1 && (o1.calystoFormat || o1.culture)) {
                        list.Add(Calysto.Type.TypeConverter.ToStringFormated(o1.value, o1.calystoFormat)); // if calystoFormat not provided, use default formating
                    }
                    else {
                        list.Add(Calysto.Type.TypeConverter.ToStringFormated(o1));
                    }
                });
            }
            catch (e) {
                list.Add("unresolved");
            }
        }
        var res3 = list.ToStringJoined("; ");
        let exp3 = "s1; ; ; true; true; false; ; 2.340; 5.41; 541,000.0000; $541,000.0000; 541.000,0000 kn; 64; [3,4,2]; 5/18/2016 10:44:26 PM; 18.5.2016. 22:44:26; 18.05.2016. 22:44:26.00; 05/19/2016 02:44; unresolved; 76:20:31.997";
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp3, res3);
        //************************************************************************************************
        // test conversion of all types to other types
        // test Calysto.DataBinder
        // test Calysto.DateTime.Parse
        //************************************************************************************************
        class BoxStack extends Calysto.BoxValue {
            constructor() {
                super(...arguments);
                this.Items = [];
            }
            SetValue(value) {
                this.Items.push(value);
            }
        }
        var temp1 = {};
        Calysto.DataBinder.SetValue(temp1, "prop1.prop2.prop3.prop4.prop5", 234);
        Calysto.DataBinder.SetValue(temp1, "prop1.prop2.prop3.Value5", 111);
        var refOutArr = new BoxStack();
        var res4 = [
            Calysto.Type.TypeConverter.ChangeType("True", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType("true", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType("false", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType("False", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType("0", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType("1", "Boolean"),
            Calysto.Type.TypeConverter.ChangeType(0, "Boolean"),
            Calysto.Type.TypeConverter.ChangeType(1, "Boolean"),
            Calysto.Type.TypeConverter.ChangeType(undefined, "Boolean?"),
            Calysto.Type.TypeConverter.ChangeType(undefined, "Integer", true),
            Calysto.Type.TypeConverter.ChangeType("", "Decimal", true),
            Calysto.Type.TypeConverter.ChangeType("", "Boolean", true),
            Calysto.Type.TypeConverter.ChangeType("", "String", true),
            Calysto.Type.TypeConverter.ChangeType(null, "String", true),
            Calysto.Type.TypeConverter.ChangeType(undefined, "String?"),
            //Calysto.Type.TypeConverter.ChangeType(function One() { return 4; }, Calysto.DotNetTypeName.String), // firefox will add "use string" to body so this can not be used
            Calysto.Type.TypeConverter.ChangeType("-2.53", "Decimal"),
            Calysto.Type.TypeConverter.ChangeType("-12.553", "Number"),
            Calysto.Type.TypeConverter.ChangeType("-42.1234", "Integer"),
            Calysto.Type.TypeConverter.ChangeType(-432.23432, "Decimal"),
            Calysto.Type.TypeConverter.ChangeType(-4435.53241, "Integer"),
            Calysto.Type.TypeConverter.ChangeType("[34,53,4325]", "Array"),
            Calysto.DateTime.ParseDateTime("18.05.2016. 22:44:26.42", "dd.MM.yyyy"),
            Calysto.DateTime.ParseDateTime("18.05.2016. 22:44:26.42", "dd.MM.yyyy"),
            Calysto.DateTime.ParseDateTime("18.05.2016. 22:44:26.42", "dd.MM.yyyy. HH:mm:ss.ff"),
            "valueTypeTest",
            Calysto.Type.TypeInspector.IsValueType(null),
            Calysto.Type.TypeInspector.IsValueType(""),
            Calysto.Type.TypeInspector.IsValueType(function () { }),
            Calysto.Type.TypeInspector.IsValueType({}),
            Calysto.Type.TypeInspector.IsValueType(2),
            Calysto.Type.TypeInspector.IsValueType(true),
            "containPropertyTest",
            Calysto.Type.TypeInspector.ContainsProperty({ dva: 43 }, "dva"),
            Calysto.Type.TypeInspector.ContainsProperty({ dvatri: 43 }, "dva"),
            "dataBinderTryGetValueTest",
            Calysto.DataBinder.TryGetValue({ dva: 2, trie: 3 }, "dva2", refOutArr),
            Calysto.DataBinder.TryGetValue({ dva: 2, trie: { dva: 2, trie: { dva: 2, trie: 3 } } }, "trie.trie.dva", refOutArr),
            Calysto.DataBinder.TryGetValue({ dva: 2, trie: 3 }, "dva", refOutArr),
            Calysto.DataBinder.TryGetValue({}, "dva", refOutArr),
            "temp1isnext",
            temp1,
            "trygetvalue11",
            Calysto.DataBinder.TryGetValue(temp1, "prop1.prop2.prop3.prop4.prop5", refOutArr),
            Calysto.DataBinder.TryGetValue(temp1, "prop1.prop2.prop3.Value5", refOutArr),
            Calysto.DataBinder.TryGetValue(temp1, "prop1.prop2", refOutArr),
            Calysto.DataBinder.TryGetValue(temp1, "prop1.prop2.", refOutArr),
            Calysto.DataBinder.TryGetValue(temp1, "prop1.prop4", refOutArr),
            "refOutArrStart",
            refOutArr.Items
        ];
        let exp5 = '[true,true,false,false,false,true,false,true,null,null,null,null,"",null,null,-2.53,-12.553,-42,-432.23432,-4435,["34","53","4325"],{"__calystotype":"Calysto_Date","Date":"2016-05-18T00:00:00.000"},{"__calystotype":"Calysto_Date","Date":"2016-05-18T00:00:00.000"},{"__calystotype":"Calysto_Date","Date":"2016-05-18T22:44:26.420"},"valueTypeTest",false,true,false,false,true,true,"containPropertyTest",true,false,"dataBinderTryGetValueTest",false,true,true,false,"temp1isnext",{"prop1":{"prop2":{"prop3":{"prop4":{"prop5":234},"Value5":111}}}},"trygetvalue11",true,true,true,true,false,"refOutArrStart",[2,2,234,111,{"prop3":{"prop4":{"prop5":234},"Value5":111}},{"prop3":{"prop4":{"prop5":234},"Value5":111}}]]';
        var res5 = Calysto.Json.Serialize(res4);
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp5, res5);
        //************************************************************************************************
        //************************************************************************************************
        console.log("DataBinder.SetValue test successful");
        console.log("DataBinder.TryGetValue test successful");
        console.log("DateTime.Parse test successful");
        console.log("Type.ChangeType test successful");
        console.log("Type test successful");
    });
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var net = "dGhpcyBpcyBteSB0ZXh0IGFuZCBjaGFycyDFvsSHxI3EkcWhxJDFoMW9xIbEjD8=";
    var text1 = "this is my text and chars žćčđšĐŠŽĆČ?";
    var ss = Calysto.Utility.Encoding.RfcBase64.EncodeToBase64String(text1);
    if (ss != net) {
        throw new Error("Calysto.Utility.Encoding.RfcBase64.EncodeToBase64String() self test error. Result: " + ss);
    }
    var dd = Calysto.Utility.Encoding.RfcBase64.DecodeBase64StringToString(ss);
    if (dd != text1) {
        throw new Error("Calysto.Utility.Encoding.RfcBase64.DecodeBase64StringToString() self test error. Result: " + dd);
    }
    var text2 = "http://sitežlkjđšžćč.com/?čščćžđaša fds žhsdf";
    var hh = Calysto.Utility.Html.UrlEncode(text2);
    if (hh != "http%3A%2F%2Fsite%C3%85%C2%BElkj%C3%84%C2%91%C3%85%C2%A1%C3%85%C2%BE%C3%84%C2%87%C3%84%C2%8D.com%2F%3F%C3%84%C2%8D%C3%85%C2%A1%C3%84%C2%8D%C3%84%C2%87%C3%85%C2%BE%C3%84%C2%91a%C3%85%C2%A1a%20fds%20%C3%85%C2%BEhsdf") {
        throw new Error("Calysto.Utility.Html.UrlEncode() self test error. Result: " + hh);
    }
    var aa1 = Calysto.Utility.Html.UrlDecode(hh);
    if (aa1 != text2) {
        throw new Error("Calysto.Utility.Html.UrlDecode() self test error. Result: " + hh);
    }
    var txt1 = "this is my žćčđšŽĆČĐŠ string";
    var bytes = Calysto.Utility.Encoding.UTF8.GetBytes(txt1);
    var res1 = Calysto.Utility.Encoding.UTF8.GetString(bytes);
    if (res1 != txt1) {
        throw new Error("Calysto.Utility.Encoding.UTF8.GetString() self test error. Result: " + res1 + ", expected: " + txt1);
    }
    var base64 = new Calysto.Utility.Encoding.CalystoBaseConverter().EncodeToBaseString(bytes, 6);
    var res2 = new Calysto.Utility.Encoding.CalystoBaseConverter().DecodeBaseStringToString(base64, 6);
    if (res2 != txt1) {
        throw new Error("Calysto.Utility.Encoding.CalystoBaseConverter.DecodeBaseStringToString() self test error. Result: " + res2 + ", expected: " + txt1);
    }
    var res4 = [
        Calysto.Utility.Path.GetQueryString("\\fasdfs\\hhdfg\\yerrre.cs?fsfs=twerew"),
        Calysto.Utility.Path.GetDirectoryName("\\fasdfs\\hhdfg\\yerrre.cs?fsfs=twerew"),
        Calysto.Utility.Path.GetFilePath("\\fasdfs\\hhdfg\\yerrre.cs?fsfs=twerew"),
        Calysto.Utility.Path.GetFileName("\\fasdfs\\hhdfg\\yerrre.cs?fsfs=twerew"),
        Calysto.Utility.Path.GetExtension("\\fasdfs\\hhdfg\\yerrre.cs?fsfs=twerew")
    ].join(", ");
    var res5 = "?fsfs=twerew, \\fasdfs\\hhdfg, \\fasdfs\\hhdfg\\yerrre.cs, yerrre.cs, .cs";
    if (res4 != res5) {
        throw new Error("Calysto.Utility.Path selftest error. Result: " + res4 + ", expected: " + res5);
    }
    if (Calysto.Utility.CalystoTools.ByteArrayToLong(Calysto.Utility.CalystoTools.LongToByteArray(20042362354623561)) != 20042362354623561) {
        throw new Error("Selftest ByteArrayToLong failed");
    }
    console.log("Utility test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var res1 = [
        "hretygsadfewh/ghsd/.?gsadf".EndsWith("adf"),
        "hretygsadfewh/ghsd/.?gsadf".EndsWith("aDf", true),
        "hretygsadfewh/ghsd/.?gsadf".EndsWith("aDf"),
        "hretygshreadfewh/ghsd/.?gsadf".StartsWith("hre"),
        "hretygshreadfewh/ghsd/.?gsadf".StartsWith("hRe", true),
        "hretygshreadfewh/ghsd/.?gsadf".StartsWith("hRe"),
        "hretygsadfewh/ghsd/.?gsadf".Contains("gh"),
        "hretygsadfewh/ghsd/.?gsadf".Contains("G"),
        "hretygsadfewh/ghsd/.?gsadf".Contains("GH", true),
        "hretygsadfewh/ghsd/.?gsadf".GetHashCode(),
        "hretygsadfewh/ghsd/.?gsadf".Remove(4),
        "hretygsadfewh/ghsd/.?gsadf".Remove(324),
        "hretygsadfewh/ghsd/.?gsadf".Repeat(3),
        "hretygsadfewh/ghsd/.?gsadf".Repeat(0)
    ].join("_");
    if (res1 != "true_true_false_true_true_false_true_false_true_-914965447_hret_hretygsadfewh/ghsd/.?gsadf_hretygsadfewh/ghsd/.?gsadfhretygsadfewh/ghsd/.?gsadfhretygsadfewh/ghsd/.?gsadf_") {
        throw new Error("Error in String test1, result: " + res1);
    }
    var res2 = [
        "testfunction(){reutrn false; {name1} was not {cars.1} {years.birth} {cars.2} hretygsadfewh/ghsd/.?gsadf}".FormatWith({ name1: "John Bravo", years: { birth: 22, school: 8 }, cars: ["ford", "bmw", "audi"] }),
        "hretygsadfewh/ghsd/.?gsadf".ReplaceAll("h", "1"),
        "hretygsadfewh/ghsd/.?gsadf".TakeFirst(5),
        "hretygsadfewh/ghsd/.?gsadf".TakeFirst(5, "..."),
        "hretyy".TakeFirst(5, "..."),
        "hrety".TakeFirst(5, "..."),
        "hretyy".TakeFirst(4, "..."),
        "hretygsadfewh/ghsd/.?gsadf".TakeLast(5),
        "hretygsadfewh/ghsd/.?gsadf".TakeLast(5, "..."),
        "hretyg".TakeLast(7, "..."),
        "hretyg".TakeLast(6, "..."),
        "hretyg".TakeLast(5, "..."),
        "this is my word number one".TakeLast(15, "..."),
        "this is my word number one".TakeLast(15, "...", true),
        "this is my word number one".TakeFirst(15, "...", true),
        "this is my word number one".TakeFirst(14, "...", true),
        "this is my word number one".TakeFirst(16, "...", true),
        String.IsNullOrEmpty(),
        String.IsNullOrEmpty(""),
        String.IsNullOrEmpty("d"),
        String.IsNullOrEmpty("gsdf"),
        String.IsNullOrWhiteSpace(),
        String.IsNullOrWhiteSpace("false"),
        String.IsNullOrWhiteSpace(""),
        String.IsNullOrWhiteSpace(" "),
        String.IsNullOrWhiteSpace(" e"),
        String.IsNullOrWhiteSpace(" \r\n\t"),
        String.IsNullOrWhiteSpace("\t"),
        String.IsNullOrWhiteSpace("\t\n")
    ].join("_");
    if (res2 != "testfunction(){reutrn false; John Bravo was not bmw 22 audi hretygsadfewh/ghsd/.?gsadf}_1retygsadfew1/g1sd/.?gsadf_hrety_hr..._hr..._hr..._h..._gsadf_...df_hretyg_...tyg_...yg_...d number one_...number one_this is my..._this is my..._this is my..._true_true_false_false_true_false_true_true_false_true_true_true") {
        throw new Error("Error in String test2, result: " + res2);
    }
    console.log("String test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    function UsingCulture2(culture, func) {
        // formating numbers to string, we need US culture
        var original = Calysto.Globalization.CultureInfo.CurrentCulture;
        Calysto.Globalization.CultureInfo.CurrentCulture = culture || Calysto.Globalization.CultureInfo.USCulture; // set US culture as default
        func();
        Calysto.Globalization.CultureInfo.CurrentCulture = original; // restore culture
    }
    ;
    UsingCulture2(Calysto.Globalization.CultureInfo.USCulture, function () {
        let res1 = [
            (-36324263299.492342423532423532).ToStringFormated("n6"),
            (-36324263299.492342423532423532).ToStringFormated("n8"),
            (-36324263299.492342423532423532).ToStringFormated("n7"),
            (-3.6324263299492342423532423532).ToStringFormated("n15"),
            (-3.6324263299492342423532423532).ToStringFormated("n12"),
            (-3.6324263299492342423532423532).ToStringFormated("n13"),
            (-3.6324263299492342423532423532).ToStringFormated("n10"),
            (-3.6324263299492342423532423532).ToStringFormated("n9"),
            (-3.6324263299492342423532423532).ToStringFormated("n3"),
            (-3.6324263299492342423532423532).ToStringFormated("n2"),
            (-3.6324263299492342423532423532).ToStringFormated("n1"),
            (-3.6324263299492342423532423532).ToStringFormated("n0"),
            (-3.6324263299492342423532423532).ToStringFormated("n6"),
            (-3.6324263299492342423532423532).ToStringFormated("n5"),
            (3.6324263299492342423532423532).ToStringFormated("n5"),
            (3.6324263299492342423532423532).ToStringFormated("n6"),
            (3.6324263299492342423532423532).ToStringFormated("n3"),
            (3.6324263299492342423532423532).ToStringFormated("n1"),
            (3.6324263299492342423532423532).ToStringFormated("n0"),
            (3.6324263299492342423532423532).ToStringFormated("n")
        ];
        let expected1 = [
            "-36,324,263,299.492350",
            "-36,324,263,299.49234000",
            "-36,324,263,299.4923400",
            "-3.632426329949234",
            "-3.632426329949",
            "-3.6324263299492",
            "-3.6324263299",
            "-3.632426330",
            "-3.632",
            "-3.63",
            "-3.6",
            "-4",
            "-3.632426",
            "-3.63243",
            "3.63243",
            "3.632426",
            "3.632",
            "3.6",
            "4",
            "3.63"
        ];
        let s1 = res1.join(";");
        let exp1 = expected1.join(";");
        if (s1 != exp1) {
            throw new Error("Error in Number test1, result: " + s1 + ", expected: " + exp1);
        }
        console.log("Number test successful");
    });
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var aa1 = new Calysto.QueryString("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&sig=fsdaf");
    var res1 = aa1.GetUrl();
    if ("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&sig=fsdaf" != res1) {
        throw new Error("Calysto.QueryString #1 selftest error. Result: " + res1 + ", expected: " + "http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&sig=fsdaf");
    }
    var aa1 = new Calysto.QueryString("http://toolnix.com/widgetcontent");
    var res1 = aa1.GetUrl();
    if ("http://toolnix.com/widgetcontent" != res1) {
        throw new Error("Calysto.QueryString #2 selftest error. Result: " + res1 + ", expected: " + "http://toolnix.com/widgetcontent");
    }
    var aa1 = new Calysto.QueryString("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&#fasdf#fasdf");
    aa1.SetValue("mmm", 1043);
    aa1.RemoveValue("balloon");
    var res1 = aa1.GetUrl();
    if ("http://toolnix.com/widgetcontent?marker=1&width=400&height=200&mid=2004&mmm=1043#fasdf#fasdf" != res1) {
        throw new Error("Calysto.QueryString #3 selftest error. Result: " + res1 + ", expected: " + "http://toolnix.com/widgetcontent?marker=1&width=400&height=200&mid=2004&mmm=1043");
    }
    var aa1 = new Calysto.QueryString("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&#fasdf#fasdf");
    aa1.SetValue("mmm", 1043);
    aa1.RemoveValue("balloon");
    var res1 = aa1.GetUrl();
    if ("http://toolnix.com/widgetcontent?marker=1&width=400&height=200&mid=2004&mmm=1043#fasdf#fasdf" != res1) {
        throw new Error("Calysto.QueryString #4 selftest error. Result: " + res1 + ", expected: " + "http://toolnix.com/widgetcontent?marker=1&width=400&height=200&mid=2004&mmm=1043#fasdf#fasdf");
    }
    var aa1 = new Calysto.QueryString("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=200&mid=2004&");
    aa1.SetValue("height", 42353);
    var res1 = aa1.GetUrl();
    if ("http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=42353&mid=2004" != res1) {
        throw new Error("Calysto.QueryString #5 selftest error. Result: " + res1 + ", expected: " + "http://toolnix.com/widgetcontent?marker=1&balloon=0&width=400&height=42353&mid=2004");
    }
    console.log("QueryString test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var str = "fasdg423675wefdfhuioyfasdyqpoeriu7234rfdsdhlkj6rfa234fdashasdf";
    var res1 = new Calysto.Regex("fa").Matches(str).AsEnumerable().Select(function (o) { return o.Value + ", " + o.Success + ", " + o.Index; }).ToStringJoined(";");
    if (res1 != "fa, true, 0;fa, true, 21;fa, true, 48") {
        throw new Error("Calysto.Regex selftest #1 failed, res: " + res1);
    }
    var res2 = new Calysto.Regex("fa").SelectMatches(str).Select(function (o) { return o.Value + ", " + o.Success + ", " + o.Index; }).ToStringJoined(";");
    if (res2 != "fa, true, 0;fa, true, 21;fa, true, 48") {
        throw new Error("Calysto.Regex selftest #2 failed, res: " + res2);
    }
    var res3 = new Calysto.Regex("fa").SelectSegments(str).Select(function (o) { return o.Value + ", " + o.Success + ", " + o.Index; }).ToStringJoined(";");
    if (res3 != "fa, true, 0;sdg423675wefdfhuioy, false, 2;fa, true, 21;sdyqpoeriu7234rfdsdhlkj6r, false, 23;fa, true, 48;234fdashasdf, false, 50") {
        throw new Error("Calysto.Regex selftest #3 failed, res: " + res3);
    }
    var res4 = new Calysto.Regex("fa").SelectSegments(str).Select(function (o) { return o.Value; }).ToStringJoined(";");
    if (res4 != "fa;sdg423675wefdfhuioy;fa;sdyqpoeriu7234rfdsdhlkj6r;fa;234fdashasdf") {
        throw new Error("Calysto.Regex selftest #4 failed, res: " + res4);
    }
    var res5 = new Calysto.Regex("fa").SelectSegments(str).Select(function (o) { return o.Value; }).ToStringJoined("");
    if (res5 != "fasdg423675wefdfhuioyfasdyqpoeriu7234rfdsdhlkj6rfa234fdashasdf") {
        throw new Error("Calysto.Regex selftest #5 failed, res: " + res5);
    }
    var res6 = "pos-bottom-center, pos-bottom-center2".ReplaceAll("pos-", "replacedText");
    if (res6 != "replacedTextbottom-center, replacedTextbottom-center2") {
        throw new Error("Calysto.Regex selftest #6 failed, res: " + res6);
    }
    console.log("Regex test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var isOldMsie = Calysto.Features.GetBrowser().KindName == "MSIE" && Calysto.Features.GetBrowser().Version <= 8;
    if (isOldMsie)
        return;
    var js1 = '{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}';
    var o1 = Calysto.Json.Deserialize(js1);
    var o2 = new Calysto.Json.JsonNode(o1);
    var res55 = Calysto.Json.Serialize(o2.Descendants(true).Skip(1).Take(2).ToArray());
    var res55exp = `[{"Property":"msg","Level":1,"Type":1,"Value":"hasdfs","Parent":{"Property":"@","Level":0,"Type":2,"Value":{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}}},{"Property":"files","Level":1,"Type":3,"Value":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}],"Parent":{"Property":"@","Level":0,"Type":2,"Value":{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}}}]`;
    Calysto.TestTools.UnitTesting.Assert.AreEqual(res55exp, res55, "#ref res55exp");
    var res56 = Calysto.Json.Serialize(o2.Children(true).Take(2).ToArray());
    var res56exp = `[{"Property":"@","Level":0,"Type":2,"Value":{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}},{"Property":"msg","Level":1,"Type":1,"Value":"hasdfs","Parent":{"Property":"@","Level":0,"Type":2,"Value":{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}}}]`;
    Calysto.TestTools.UnitTesting.Assert.AreEqual(res56exp, res56, "#ref res56exp");
    var all = o2.Descendants(true)
        .Where(o => o.Index > 0 || o.Index == 0)
        .Select(o => o)
        .Where(o => !!o);
    var arr1 = all.ToArray();
    var all1 = o2.Descendants(true).Where(o => o.Index > 0 || o.Index == 0).Skip(2).Take(1).ToArray();
    var all2 = o2.Descendants(true).ToArray();
    var complete1 = [all1];
    var res1 = Calysto.Json.Serialize(complete1); // use JSON.stringify
    var res11 = Calysto.Json.Serialize(complete1, 100); // force Calysto serializer
    var res11exp = `[[{"Index":2,"Property":"2","Level":2,"Type":2,"Value":{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},"Parent":{"Property":"files","Level":1,"Type":3,"Value":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}],"Parent":{"Property":"@","Level":0,"Type":2,"Value":{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}}}}]]`;
    Calysto.TestTools.UnitTesting.Assert.AreEqual(res11exp, res11, "#ref res11exp");
    var lastOne = all.Last();
    var arr22 = lastOne.Ancestors(true).ToArray();
    var cnt11 = arr22.length;
    Calysto.TestTools.UnitTesting.Assert.AreEqual(3, cnt11, "#ref cnt11");
    var arr23 = lastOne.Ancestors(false).ToArray();
    var cnt13 = arr23.length;
    Calysto.TestTools.UnitTesting.Assert.AreEqual(2, cnt13, "#ref cnt13");
    Calysto.TestTools.UnitTesting.Assert.AreEqual(res1, res11, "#ref res11");
    var obj1 = { a: new Calysto.DateTime("2016-07-02T11:08:25.244Z"), b: window.tqwefdhdasrtyqwer, c: null, d: parseInt(window.tqweyshasdfsg) };
    var json1 = Calysto.Json.Serialize(obj1);
    var json2 = Calysto.Json.Serialize(obj1, 100); // force Calysto serializer
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`{"a":{"__calystotype":"Calysto_Date","Date":"2016-07-02T11:08:25.244"},"b":null,"c":null,"d":null}`, json1, "#ref json1");
    Calysto.TestTools.UnitTesting.Assert.AreEqual(json1, json2);
    console.log("JsonNode1 test successful");
});
Calysto.TestTools.TestRunner.AddTest(() => {
    let data1 = {
        Ime: "janko",
        Prezime: "bobetko",
        Sub1: {
            Name: "sub1",
            Sub2: {
                Name: "sub2",
                One: "jedan",
                Size: 25
            }
        },
        Age: 150,
        List1: [{ a: 10 }, { a: 20 }, { a: 30 }],
        List2: [1, 2, 3, 4, 5]
    };
    let tree1 = new Calysto.Json.JsonNode(data1);
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`{"Property":"@","Level":0,"Type":2,"Value":{"Ime":"janko","Prezime":"bobetko","Sub1":{"Name":"sub1","Sub2":{"Name":"sub2","One":"jedan","Size":25}},"Age":150,"List1":[{"a":10},{"a":20},{"a":30}],"List2":[1,2,3,4,5]}}`, JSON.stringify(tree1), "#reference tree1");
    let d3 = tree1.Children(true).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}},{\"Property\":\"Ime\",\"Level\":1,\"Type\":1,\"Value\":\"janko\",\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"Prezime\",\"Level\":1,\"Type\":1,\"Value\":\"bobetko\",\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"Age\",\"Level\":1,\"Type\":1,\"Value\":150,\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"List1\",\"Level\":1,\"Type\":3,\"Value\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"List2\",\"Level\":1,\"Type\":3,\"Value\":[1,2,3,4,5],\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}}]`, JSON.stringify(d3), "#reference d3");
    let d2 = tree1.Descendants(true).Where(o => o.Level >= 2).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(16, d2.length, "#reference d2");
    let d5 = tree1.Descendants(false).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(22, d5.length, "#reference d5");
    let d1 = tree1.Descendants().Where(o => o.Property == "Sub1").Select(o => o.Value).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(1, d1.length, "#reference d1");
    let d2a = tree1.Descendants(true).Where(o => o.Level >= 2).First();
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Name", d2a.Property, "#reference d2a");
    let chain = d2a.SelectChain("Nest.Tamo.@.Sub1.Sub2.Size.Next.Home").ToArray();
    let chain22 = chain.Select(o => ({ Property: o.Property, Level: o.Level, Value: o.Value + "" })).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`[]`, JSON.stringify(chain22), "#reference chain22");
    let chain2 = tree1.SelectChain("List1.2.a.c").ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{"Property":"List1","Level":1,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}],"Parent":{"Property":"@","Level":0,"Type":2,"Value":{"Ime":"janko","Prezime":"bobetko","Sub1":{"Name":"sub1","Sub2":{"Name":"sub2","One":"jedan","Size":25}},"Age":150,"List1":[{"a":10},{"a":20},{"a":30}],"List2":[1,2,3,4,5]}}},{"Index":2,"Property":"2","Level":2,"Type":2,"Value":{"a":30},"Parent":{"Property":"List1","Level":1,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}],"Parent":{"Property":"@","Level":0,"Type":2,"Value":{"Ime":"janko","Prezime":"bobetko","Sub1":{"Name":"sub1","Sub2":{"Name":"sub2","One":"jedan","Size":25}},"Age":150,"List1":[{"a":10},{"a":20},{"a":30}],"List2":[1,2,3,4,5]}}}},{"Property":"a","Level":3,"Type":1,"Value":30,"Parent":{"Index":2,"Property":"2","Level":2,"Type":2,"Value":{"a":30},"Parent":{"Property":"List1","Level":1,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}],"Parent":{"Property":"@","Level":0,"Type":2,"Value":{"Ime":"janko","Prezime":"bobetko","Sub1":{"Name":"sub1","Sub2":{"Name":"sub2","One":"jedan","Size":25}},"Age":150,"List1":[{"a":10},{"a":20},{"a":30}],"List2":[1,2,3,4,5]}}}}}]`, JSON.stringify(chain2), "#reference chain2");
    //let list1 = chain.AsEnumerable().Last().Ancestors(true).Skip(2).Take(1).ToArray();
    //Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{\"Property\":\"Size\",\"Level\":3,\"Type\":1,\"Value\":25,\"Parent\":{\"Property\":\"Sub2\",\"Level\":2,\"Type\":2,\"Value\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25},\"Parent\":{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}}}}]`, JSON.stringify(list1), "#reference list1");
    //let list11 = chain.AsEnumerable().Last().Ancestors(true).Skip(2).ToArray();
    //Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{\"Property\":\"Size\",\"Level\":3,\"Type\":1,\"Value\":25,\"Parent\":{\"Property\":\"Sub2\",\"Level\":2,\"Type\":2,\"Value\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25},\"Parent\":{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}}}},{\"Property\":\"Sub2\",\"Level\":2,\"Type\":2,\"Value\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25},\"Parent\":{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}}},{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}]`, JSON.stringify(list11), "#reference list11");
    let anc1 = d2a.Ancestors(true).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{\"Property\":\"Name\",\"Level\":2,\"Type\":1,\"Value\":\"sub1\",\"Parent\":{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}}},{\"Property\":\"Sub1\",\"Level\":1,\"Type\":2,\"Value\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Parent\":{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}},{\"Property\":\"@\",\"Level\":0,\"Type\":2,\"Value\":{\"Ime\":\"janko\",\"Prezime\":\"bobetko\",\"Sub1\":{\"Name\":\"sub1\",\"Sub2\":{\"Name\":\"sub2\",\"One\":\"jedan\",\"Size\":25}},\"Age\":150,\"List1\":[{\"a\":10},{\"a\":20},{\"a\":30}],\"List2\":[1,2,3,4,5]}}]`, JSON.stringify(anc1), "#reference anc1");
    let anc2 = d2a.Ancestors(true).Reverse().Select(o => o.Property).ToStringJoined(".");
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`@.Sub1.Name`, anc2, "#reference anc2");
    let tree2 = new Calysto.Json.JsonNode(data1.List1);
    var m1 = tree2.Descendants(true).ToArray();
    Calysto.TestTools.UnitTesting.Assert.AreEqual(`[{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]},{"Index":0,"Property":"0","Level":1,"Type":2,"Value":{"a":10},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}},{"Property":"a","Level":2,"Type":1,"Value":10,"Parent":{"Index":0,"Property":"0","Level":1,"Type":2,"Value":{"a":10},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}}},{"Index":1,"Property":"1","Level":1,"Type":2,"Value":{"a":20},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}},{"Property":"a","Level":2,"Type":1,"Value":20,"Parent":{"Index":1,"Property":"1","Level":1,"Type":2,"Value":{"a":20},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}}},{"Index":2,"Property":"2","Level":1,"Type":2,"Value":{"a":30},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}},{"Property":"a","Level":2,"Type":1,"Value":30,"Parent":{"Index":2,"Property":"2","Level":1,"Type":2,"Value":{"a":30},"Parent":{"Property":"@","Level":0,"Type":3,"Value":[{"a":10},{"a":20},{"a":30}]}}}]`, JSON.stringify(m1), "#reference m1");
    console.log("JsonNode2 test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    // warning: it should not loop loading the same page over and over
    //if (!location.href.Contains("test=done"))
    //{
    //	var cc = new Calysto.Net.WebClient(location.pathname + "?test=done").OnLoad((sender, ev) =>
    //	{
    //		console.log(sender.GetResponseText());
    //	}).Start();
    //}
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    function UsingCulture(culture, func) {
        // we need US culture for number formating to string
        var original = Calysto.Globalization.CultureInfo.CurrentCulture;
        Calysto.Globalization.CultureInfo.CurrentCulture = culture || Calysto.Globalization.CultureInfo.USCulture; // set US culture as default
        func();
        Calysto.Globalization.CultureInfo.CurrentCulture = original; // restore culture
    }
    UsingCulture(Calysto.Globalization.CultureInfo.USCulture, function () {
        var isOldMsie = Calysto.Features.GetBrowser().KindName == "MSIE" && Calysto.Features.GetBrowser().Version <= 8;
        if (isOldMsie)
            return;
        var html1 = '<div id="divForm1" style="background:whitesmoke;padding:10px;margin-top:10px;border:solid 5px red;;">\
		<input type="text" calysto-id="Game.Name" name="GameName" value="the name of the game" />\
		<input type="text" calysto-id="Store.Name" name="StoreName" value="store name" />\
		<input type="text" calysto-id="Realization.IncomeSum1" calysto-getter="()=>Calysto.Type.NumberConverter.ToDecimal(this.value, -5)" name="ctl00$clientNavigation1$IncomeSum1">\
		<input type="text" calysto-id="Realization.IncomeSum2" calysto-setter="(a1)=>this.value=a1.ToStringFormated(\'n2\')" name="ctl00$clientNavigation1$IncomeSum2">\
		<input type="text" calysto-id="Realization.IncomeSum3" name="ctl00$clientNavigation1$IncomeSum3" calysto-format="N3">\
		<input type="text" calysto-id="Realization.IncomeSum4" calysto-setter="(a1)=>this.value=a1.ToStringFormated(\'n2\')" calysto-getter="()=>Calysto.Type.NumberConverter.ToDecimal(this.value, -1)" name="ctl00$clientNavigation1$IncomeSum4">\
		<div class="right" calysto-id="Realization.IncomeSum5" calysto-setter="(a1)=>this.innerHTML=a1.ToStringFormated(\'n2\')"></div>\
		<select calysto-id="Realization.Color" name="TheColor">\
			<option value="red">Red color</option>\
			<option value="blue">Blue color</option>\
			<option selected="selected">No color</option>\
		</select>\
\
		<select calysto-id="Realization.Height" name="TheHeight" multiple="multiple">\
			<option value="1">One inch</option>\
			<option value="2" selected="selected">Two inch</option>\
			<option value="3" selected="selected">Three inch</option>\
			<option value="4">Four inch</option>\
			<option selected="selected" value="">No height</option>\
		</select>\
\
		<input type="radio" calysto-id="Income.Salary" name="ctl00$clientNavigation1$Salary1" value="1000" />\
		<input type="radio" calysto-id="Income.Salary" name="ctl00$clientNavigation1$Salary1" value="2000" />\
		<input type="radio" calysto-id="Income.Salary" name="ctl00$clientNavigation1$Salary1" value="3000" />\
		<input type="radio" calysto-id="Income.Salary" name="ctl00$clientNavigation1$Salary1" value="4000" checked="checked" calysto-type="Decimal" />\
		<input type="radio" calysto-id="Income.Salary" name="ctl00$clientNavigation1$Salary1" value="5000" />\
\
		<input type="checkbox" calysto-id="Addition.Bonus1" name="ctl00$clientNavigation1$Addition1" value="5000" />\
		<input type="checkbox" calysto-id="Addition.Bonus2" name="ctl00$clientNavigation1$Addition2" value="6000" checked="checked" />\
		<input type="checkbox" calysto-id="Addition.Bonus3" name="ctl00$clientNavigation1$Addition3" value="7000" checked="checked" />\
		<input type="checkbox" calysto-id="Addition.Bonus4" name="ctl00$clientNavigation1$Addition4" value="8000" />\
</div>\
';
        var divEl = Calysto.Utility.Dom.ConvertToElementsArray(html1);
        // initial values from html
        var json1 = '{"Game":{"Name":"the name of the game"},"Store":{"Name":"store name"},"Realization":{"IncomeSum1":-5,"IncomeSum2":"","IncomeSum3":"","IncomeSum4":-1,"Color":"No color","Height":["2","3",""]},"Income":{"Salary":4000},"Addition":{"Bonus2":"6000","Bonus3":"7000"}}';
        var el3 = $$calysto(divEl).CloneNodes().First();
        var res1 = Calysto.Json.Serialize(Calysto.Forms.CalystoSerialize(el3));
        Calysto.TestTools.UnitTesting.Assert.AreEqual(json1, res1);
        var res11 = Calysto.Json.Serialize(Calysto.Forms.MvcSerialize(el3));
        var exp11 = '{"GameName":"the name of the game","StoreName":"store name","ctl00$clientNavigation1$Addition2":"6000","ctl00$clientNavigation1$Addition3":"7000","TheColor":"No color","TheHeight":["2","3",""]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp11, res11);
        var res12 = Calysto.Json.Serialize(Calysto.Forms.FormSerialize(el3));
        var exp12 = '{"GameName":"the name of the game","StoreName":"store name","ctl00$clientNavigation1$Addition2":"6000","ctl00$clientNavigation1$Addition3":"7000","TheColor":"No color","TheHeight":["2","3",""]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp12, res12);
        //*******************************************************************************************************************
        // modified values without type
        var json2 = '{"Game":{"Name":"game1"},"Store":{"Name":"store1"},"Realization":{"IncomeSum1":2,"IncomeSum2":-34.556,"IncomeSum3":"-23.63423","IncomeSum4":4,"Color":"blue","Height":["1","2","4"]},"Income":{"Salary":"2000"},"Addition":{"Bonus3":"7000","Bonus4":"8000"}}';
        var el3 = $$calysto(divEl).CloneNodes().First();
        ////$$calysto(document.body).AddChildren(el3); // dodaje u dom
        Calysto.Forms.CalystoDeserialize(Calysto.Json.Deserialize(json2), el3);
        var res2 = Calysto.Json.Serialize(Calysto.Forms.CalystoSerialize(el3));
        var exp2 = '{"Game":{"Name":"game1"},"Store":{"Name":"store1"},"Realization":{"IncomeSum1":2,"IncomeSum2":-34.56,"IncomeSum3":"-23.63423","IncomeSum4":4,"Color":"blue","Height":["1","2","4"]},"Income":{"Salary":"2000"},"Addition":{"Bonus2":"6000","Bonus3":"7000","Bonus4":"8000"}}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp2, res2);
        var res21 = Calysto.Json.Serialize(Calysto.Forms.MvcSerialize(el3));
        var exp21 = '{"GameName":"game1","StoreName":"store1","ctl00$clientNavigation1$IncomeSum3":"-23.63423","ctl00$clientNavigation1$Salary1":"2000","ctl00$clientNavigation1$Addition2":"6000","ctl00$clientNavigation1$Addition3":"7000","ctl00$clientNavigation1$Addition4":"8000","TheColor":"blue","TheHeight":["1","2","4"]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp21, res21);
        var res22 = Calysto.Json.Serialize(Calysto.Forms.FormSerialize(el3));
        var exp22 = '{"GameName":"game1","StoreName":"store1","ctl00$clientNavigation1$IncomeSum3":"-23.63423","ctl00$clientNavigation1$Salary1":"2000","ctl00$clientNavigation1$Addition2":"6000","ctl00$clientNavigation1$Addition3":"7000","ctl00$clientNavigation1$Addition4":"8000","TheColor":"blue","TheHeight":["1","2","4"]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp22, res22);
        //*******************************************************************************************************************
        // modified values with type
        var json3 = '{"Game":{"Name":"game1"},"Store":{"Name":"store1"},"Realization":{"IncomeSum1":2,"IncomeSum2":-34.556,"IncomeSum3":-23.63463,"IncomeSum4":4,"Color":"blue","Height":[1,2,4]},"Income":{"Salary":20.0034},"Addition":{"Bonus3":70.00643,"Bonus4":-8.000435}}';
        var el3 = $$calysto(divEl).CloneNodes().First();
        Calysto.Forms.CalystoDeserialize(Calysto.Json.Deserialize(json3), el3);
        var res3 = Calysto.Json.Serialize(Calysto.Forms.CalystoSerialize(el3));
        var exp3 = '{"Game":{"Name":"game1"},"Store":{"Name":"store1"},"Realization":{"IncomeSum1":2,"IncomeSum2":-34.56,"IncomeSum3":-23.635,"IncomeSum4":4,"Color":"blue","Height":["1","2","4"]},"Addition":{"Bonus2":"6000"}}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp3, res3);
        var res31 = Calysto.Json.Serialize(Calysto.Forms.MvcSerialize(el3));
        var exp31 = '{"GameName":"game1","StoreName":"store1","ctl00$clientNavigation1$Addition2":"6000","TheColor":"blue","TheHeight":["1","2","4"]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp31, res31);
        var res32 = Calysto.Json.Serialize(Calysto.Forms.FormSerialize(el3));
        var exp32 = '{"GameName":"game1","StoreName":"store1","ctl00$clientNavigation1$Addition2":"6000","TheColor":"blue","TheHeight":["1","2","4"]}';
        Calysto.TestTools.UnitTesting.Assert.AreEqual(exp32, res32);
        //*******************************************************************************************************************
        console.log("Forms test succesful");
    });
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    //$$calysto("input").Where(o => o.innerHTML); o.checked)
    //$$calysto<HTMLInputElement>("Input").Where(o => o.checked)
    //$$calysto<HTMLInputElement>("input").Where(o => o.checked)
    var test1 = new Calysto.List(["one", "aa", "nemza", "two", "temza", "bb", "cc"])
        .GroupBy("o=>o.length") // returns [].Key objects
        .SelectMany(function (group) { return group.ToArray(); })
        .Select("o=>o.length + ': ' + o")
        .ToStringJoined(", ");
    if (test1 != "3: one, 3: two, 2: aa, 2: bb, 2: cc, 5: nemza, 5: temza") {
        throw new Error("Self test failed in Calysto.List GroupBy test 1! Result: " + test1);
    }
    var test11 = new Calysto.List(["one", "two", "nemza", "temza", "aa", "bb", "cc"])
        .OrderBy("o => o.length", true)
        .ThenBy("o=>o", true) // then order by, automatic recognition
        .GroupBy("o=>o.length") // then order by, automatic recognition
        .Select("o=> o.Key + ', items: ' + o.ToArray().join('|')")
        .ToStringJoined(", ");
    if (test11 != "5, items: temza|nemza, 3, items: two|one, 2, items: cc|bb|aa") {
        throw new Error("Self test failed in Calysto.List test 1! Result: " + test11);
    }
    //********************************************
    // test 2
    //********************************************
    var test2 = new Calysto.List([1, 2, 3, 4, 5])
        .Where("o=>o > 2")
        .Select("(o, n) => new {item: o, index: n}")
        .OrderBy("o=>o.index", true)
        .Select("(o, n) => 'index: ' + n + ', value: ' + o.item")
        .ToStringJoined("; ");
    if (test2 != "index: 0, value: 5; index: 1, value: 4; index: 2, value: 3") {
        throw new Error("Self test failed in Calysto.List test 2! Result: " + test2);
    }
});
Calysto.TestTools.TestRunner.AddTest(() => {
    var obj1 = [{ "DataUrl": function () { }, "BlobIndex": 1, "FileName": "img_2.gif", "MimeType": "image/gif", "Size": 70622, "__calystotype": "Calysto22_Blob" },
        { "DataUrl": function () { }, "BlobIndex": 2, "FileName": "img_2.gif", "MimeType": "image/gif", "Size": 50622, "__calystotype": "Calysto11_Blob" },
        { "DataUrl": function () { return 3; }, "BlobIndex": 3, "FileName": "img_3.gif", "MimeType": "image/gif", "Size": 50622, "__calystotype": "Calysto33_Blob" },
        { "DataUrl": "", "BlobIndex": 4, "FileName": "img_3.gif", "MimeType": "image/gif", "Size": 70622, "__calystotype": "Calysto222222_Blob" },
        { "DataUrl": "", "BlobIndex": 5, "FileName": "img_2.gif", "MimeType": "image/gif", "Size": 70622, "__calystotype": "Calysto222222_Blob" }];
    var m1 = obj1.AsEnumerable().Cycle(20).ToArray();
    var m2 = obj1.AsEnumerable().Distinct(o => o.DataUrl).ToArray();
    // warning: although we set o.Numbe = n, actually we use the same 5 objects, and there will be 5 distinct objects at the end
    var arr1 = obj1.AsEnumerable().Cycle(100).Distinct(function (o) { return o.DataUrl; }).ToArray();
    if (arr1.length != 4) {
        throw new Error("Self test failed in Distinct test 01, result: " + arr1.length);
    }
    var arr2 = obj1.AsEnumerable()
        .Cycle(100)
        .Distinct(function (o) { return o; })
        .ToArray();
    if (arr2.length != 5) {
        throw new Error("Self test failed in Distinct test 02, result: " + arr2.length);
    }
    var res1 = [2, 3, 4, 5, 6, null, -1, -6].AsEnumerable().Min();
    if (res1 != -6) {
        throw new Error("Self test failed in Min test 01, result: " + res1);
    }
    var res2 = [2, 3, 4, 5, null, -1, -6].AsEnumerable().Max();
    if (res2 != 5) {
        throw new Error("Self test failed in Max test 01, result: " + res1);
    }
    var res3 = [2, 3, 4, 5, 6, null, null, null, null, null, null, -1, -6].AsEnumerable().Average();
    if (res3 != 1.8571428571428572) {
        throw new Error("Self test failed in Average test 01, result: " + res1);
    }
    var res4 = [2, 3, 4, 5, 6, null, null, null, null, null, null, -1, -6].AsEnumerable().Sum();
    if (res4 != 13) {
        throw new Error("Self test failed in Sum test 01, result: " + res1);
    }
});
Calysto.TestTools.TestRunner.AddTest(() => {
    var js1 = '{"msg":"hasdfs","files":[{"DataUrl":"","BlobIndex":0,"FileName":"img_1.gif","MimeType":"image/gif","Size":56591,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":1,"FileName":"img_2.gif","MimeType":"image/gif","Size":70622,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":2,"FileName":"img_3.gif","MimeType":"image/gif","Size":68342,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":3,"FileName":"img_4.gif","MimeType":"image/gif","Size":95296,"__calystotype":"Calysto222222_Blob"},{"DataUrl":"","BlobIndex":4,"FileName":"img_5.gif","MimeType":"image/gif","Size":87117,"__calystotype":"Calysto222222_Blob"}]}';
    if (window.JSON) // IE <= 8 doesn't have JSON
     {
        var res1 = JSON.stringify(Calysto.Json.Deserialize(js1));
        if (res1 != js1) {
            throw new Error("Self test failed in Calysto.JSON test 01! Result: " + res1);
        }
        var item1 = JSON.parse(js1);
        var res1 = Calysto.Json.Serialize(item1);
        if (res1 != js1) {
            throw new Error("Self test failed in Calysto.JSON test 02! Result: " + res1);
        }
    }
});
Calysto.TestTools.TestRunner.AddTest(() => {
    var kewsrc = [{ name: "one", age: 22, sub: { dva: 22, tri: 33, coll: [{ nn: 22 }, { nn: 33 }, { nn: 44 }] } }]
        .AsEnumerable()
        .Select(o => o)
        .Select("o => o.sub")
        .Where("o => !!o")
        .Where("o => !!o")
        .SelectMany("o => o.coll")
        .Where("o => o.nn > 1")
        .Intersect([{ kk: 22 }, { kk: 23 }, { kk: 44 }], "(o1, o2) => o1.nn == o2.kk")
        .Where("o => !!o.nn")
        .ForEach('(o, n) => o.addedProperty = "ter-" + n');
    var kew = kewsrc.ToArray();
    var res1 = Calysto.Json.Serialize(kew);
    if (res1 != '[{"nn":22,"addedProperty":"ter-0"},{"nn":44,"addedProperty":"ter-1"}]') {
        throw new Error("Self test failed in Calysto.List test 03! Result: " + res1);
    }
});
Calysto.TestTools.TestRunner.AddTest(() => {
    var kewsrc = [{ name: "one", age: 22, sub: { dva: 22, tri: 33, coll: [{ nn: 22 }, { nn: 33 }, { nn: 44 }] } }]
        .AsEnumerable()
        .Select(o => o.sub)
        .Where(o => !!o)
        .Where(o => !!o)
        .SelectMany(o => o.coll)
        .Where(o => o.nn > 1)
        .Intersect([{ kk: 22 }, { kk: 23 }, { kk: 44 }], (o1, o2) => o1.nn == o2.kk)
        .Where(o => !!o.nn)
        .ForEach((o, n) => o.addedProperty = "ter-" + n);
    var kew = kewsrc.ToArray();
    var res1 = Calysto.Json.Serialize(kew);
    if (res1 != '[{"nn":22,"addedProperty":"ter-0"},{"nn":44,"addedProperty":"ter-1"}]') {
        throw new Error("Self test failed in Calysto.List test 03! Result: " + res1);
    }
    // {"_items":{"_num_22":{"Key":22,"Value":{"nn":22,"addedProperty":"ter-0"}},"_num_44":{"Key":44,"Value":{"nn":44,"addedProperty":"ter-1"}}}}
    //var dic33 = kew.AsEnumerable().ToDictionary(key => key.nn, o => o);
    //var res1 = Calysto.Json.Serialize(dic33);
    //if (res1 != '{"22":{"nn":22,"addedProperty":"ter-0"},"44":{"nn":44,"addedProperty":"ter-1"}}')
    //{
    //	throw new Error("Self test failed in Calysto.List test 04! Result: " + res1);
    //}
    // dictionary object has changed, so we have to use different approach:
    var dic33 = kew.AsEnumerable().ToDictionary(key => key.nn, o => o).ToRawObject();
    var res1 = Calysto.Json.Serialize(dic33);
    if (res1 != '{"22":{"nn":22,"addedProperty":"ter-0"},"44":{"nn":44,"addedProperty":"ter-1"}}') {
        throw new Error("Self test failed in Calysto.List test 04! Result: " + res1);
    }
    // test select many if collection is null
    var res33 = [
        [1, 2, 3, 4],
        null,
        [8, 7, 5]
    ].AsEnumerable().SelectMany(o => o).ToArray().join(";");
    if (res33 != "1;2;3;4;8;7;5") {
        throw new Error("Self test failed in SelectMay when collection is null, result: " + res33);
    }
    var testconcat = [1].AsEnumerable().Skip(1).Concat([3, 4, 5]).Concat([5, 6]).ToArray();
    if (testconcat.length != 5) {
        throw new Error("Self test failed in Calysto.List test Concat 1! Result: " + testconcat.length);
    }
    var test8 = ["one", "aa", "nemza", "two", "temza", "bb", "cc"]
        .AsEnumerable()
        .GroupBy(o => o.length) // returns [].Key objects
        .SelectMany(function (group) { return group.ToArray(); })
        .Select(o => o.length + ": " + o)
        .ToStringJoined(", ");
    if (test8 != "3: one, 3: two, 2: aa, 2: bb, 2: cc, 5: nemza, 5: temza") {
        throw new Error("Self test failed in Calysto.List GroupBy test 1! Result: " + test8);
    }
    var test9 = ["one", "two", "nemza", "temza", "aa", "bb", "cc"]
        .AsEnumerable()
        .OrderBy(o => o.length, true)
        .ThenBy(o => o, true) // then order by, automatic recognition
        .GroupBy(o => o.length) // then order by, automatic recognition
        .Select(o => o.Key + ', items: ' + o.ToArray().join('|'))
        .ToStringJoined(", ");
    if (test9 != "5, items: temza|nemza, 3, items: two|one, 2, items: cc|bb|aa") {
        throw new Error("Self test failed in Calysto.List test 1! Result: " + test9);
    }
    //********************************************
    // test 2
    //********************************************
    var test2b = [1, 2, 3, 4, 5].AsEnumerable()
        .Where(o => o > 2)
        .Select((o, n) => ({ item: o, index: n }))
        .OrderBy(o => o.index, true)
        .Select((o, n) => 'index: ' + n + ', value: ' + o.item)
        .ToStringJoined("; ");
    if (test2b != "index: 0, value: 5; index: 1, value: 4; index: 2, value: 3") {
        throw new Error("Self test failed in Calysto.List test 2b! Result: " + test2b);
    }
    var aaa = [
        { Ordinal: 11, ParentCategoryID: 5, Name: "111" },
        { Ordinal: 11, ParentCategoryID: 5, Name: "222" },
        { Ordinal: 11, ParentCategoryID: 5, Name: "333" },
        { Ordinal: 11, ParentCategoryID: 5, Name: "" },
        { Ordinal: 11, ParentCategoryID: 5, Name: undefined },
        { Ordinal: 11, ParentCategoryID: 5, Name: undefined },
        { Ordinal: 24, ParentCategoryID: 22, Name: "SomeName" },
        { Ordinal: 24, ParentCategoryID: 22, Name: "555" },
        { Ordinal: 24, ParentCategoryID: 55, Name: "666" },
        { Ordinal: 88, ParentCategoryID: 33, Name: "Mark" },
        { Ordinal: 88, ParentCategoryID: 55, Name: undefined },
        { Ordinal: 11, ParentCategoryID: 22, Name: undefined },
        { Ordinal: 11, ParentCategoryID: 33, Name: undefined },
        { Ordinal: 11, ParentCategoryID: 55, Name: "Anthon" },
        { Ordinal: 24, ParentCategoryID: 22, Name: undefined },
        { Ordinal: 24, ParentCategoryID: 33, Name: undefined },
        { Ordinal: 24, ParentCategoryID: 55, Name: "Clara" },
        { Ordinal: 11, ParentCategoryID: 55, Name: "Runna" },
        { Ordinal: 11, ParentCategoryID: 55, Name: "Inta" },
        { Ordinal: 11, ParentCategoryID: 55, Name: "333" },
        { Ordinal: 11, ParentCategoryID: 55, Name: "333" },
        { Ordinal: 88, ParentCategoryID: 22, Name: undefined },
        { Ordinal: 88, ParentCategoryID: 33, Name: undefined },
        { Ordinal: 88, ParentCategoryID: 55, Name: undefined }
    ];
    //********************************************
    // test 3
    //********************************************
    var bb = aaa.AsEnumerable()
        .OrderBy(o => o.Ordinal, false)
        .ThenBy(o => o.ParentCategoryID, true)
        .ThenBy(o => o.Name, false)
        .Skip(2)
        //.Where(o => o.Ordinal > -11)
        .OrderBy(o => 1) ////o.ParentCategoryID, true)
        .ThenBy(o => o.ParentCategoryID, true)
        .ThenBy(o => o.Ordinal);
    var cc = bb.Select(o => o.Ordinal + ', ' + o.ParentCategoryID + ', ' + o.Name).ToStringJoined("|");
    if (cc != "11, 55, Anthon|11, 55, Inta|11, 55, Runna|24, 55, 666|24, 55, Clara|88, 55, undefined|88, 55, undefined|11, 33, undefined|24, 33, undefined|88, 33, undefined|88, 33, Mark|11, 22, undefined|24, 22, undefined|24, 22, 555|24, 22, SomeName|88, 22, undefined|11, 5, undefined|11, 5, undefined|11, 5, |11, 5, 111|11, 5, 222|11, 5, 333") {
        throw new Error("Self test failed in Calysto.List test 3. Result: " + cc);
    }
    var kk = bb.Count();
    if (kk != 22) {
        throw new Error("Self test failed in Calysto.List test 5. Result: " + kk);
    }
    var res1 = ["auto", "autoo", "aut", "buton", "1", "2"].AsEnumerable().OrderBy(o => o).ToArray().join(", ");
    var res2 = ["auto", "autoo", "aut", "buton", "1", "2", "3"].AsEnumerable().OrderBy(o => o).ToArray().join(", ");
    var res3 = ["auao", "autoo", "aut", "buton", "1", "2", "3"].AsEnumerable().OrderBy(o => o).ToArray().join(", ");
    // 
    var res4 = [undefined, 1, NaN, null, "auto", "autoo", "aut", "buton", "1", "2", 3, NaN, undefined].AsEnumerable().OrderBy(o => o).ToArray().join(", ");
    if (res1 != "1, 2, aut, auto, autoo, buton")
        throw new Error("Self test failed in OrderBy test 1, result: " + res1);
    if (res2 != "1, 2, 3, aut, auto, autoo, buton")
        throw new Error("Self test failed in OrderBy test 2, result: " + res2);
    if (res3 != "1, 2, 3, auao, aut, autoo, buton")
        throw new Error("Self test failed in OrderBy test 3, result: " + res3);
    if (res4 != ", , , NaN, NaN, 1, 3, 1, 2, aut, auto, autoo, buton")
        throw new Error("Self test failed in OrderBy test 4, result: " + res4);
    //********************************************
    // test 4
    // full test for GroupBy, OrderBy, ThenBy
    //********************************************
    var list1 = "987654321".ToCharArray().AsEnumerable().Cycle(600).Select((ch, fromByte) => ({
        ch: ch.charCodeAt(0),
        fromByte: fromByte % 4
    }))
        .Take(100)
        .OrderByDescending(function (o) { return o.ch; })
        .Select(function (o, toByte) {
        return { ch: o.ch, fromByte: o.fromByte, toByte: toByte };
    }).ToList();
    var res11 = list1.Select(function (o) { return o.ch + "_" + o.fromByte + "_" + o.toByte; }).ToArray();
    var res21 = list1.OrderBy(o => o.ch).ThenBy(o => o.fromByte).Select(function (o) { return o.ch + "_" + o.fromByte + "_" + o.toByte; }).ToArray();
    var res31 = list1.OrderBy(o => o.ch).ThenByDescending(o => o.fromByte).ThenByDescending(o => o.toByte).Select(function (o) { return o.ch + "_" + o.fromByte + "_" + o.toByte; }).ToArray();
    var res41 = list1.OrderBy(o => o.ch).ThenBy(o => o.fromByte).ThenByDescending(o => o.toByte).Select(function (o) { return o.ch + "_" + o.fromByte + "_" + o.toByte; }).ToArray();
    var res51 = list1.OrderByDescending(o => o.ch).ThenByDescending(o => o.fromByte).ThenBy(o => o.toByte).Select(function (o) { return o.ch + "_" + o.fromByte + "_" + o.toByte; }).ToArray();
    if (res11.join(", ") != "57_0_0, 57_1_1, 57_2_2, 57_3_3, 57_0_4, 57_1_5, 57_2_6, 57_3_7, 57_0_8, 57_1_9, 57_2_10, 57_3_11, 56_1_12, 56_2_13, 56_3_14, 56_0_15, 56_1_16, 56_2_17, 56_3_18, 56_0_19, 56_1_20, 56_2_21, 56_3_22, 55_2_23, 55_3_24, 55_0_25, 55_1_26, 55_2_27, 55_3_28, 55_0_29, 55_1_30, 55_2_31, 55_3_32, 55_0_33, 54_3_34, 54_0_35, 54_1_36, 54_2_37, 54_3_38, 54_0_39, 54_1_40, 54_2_41, 54_3_42, 54_0_43, 54_1_44, 53_0_45, 53_1_46, 53_2_47, 53_3_48, 53_0_49, 53_1_50, 53_2_51, 53_3_52, 53_0_53, 53_1_54, 53_2_55, 52_1_56, 52_2_57, 52_3_58, 52_0_59, 52_1_60, 52_2_61, 52_3_62, 52_0_63, 52_1_64, 52_2_65, 52_3_66, 51_2_67, 51_3_68, 51_0_69, 51_1_70, 51_2_71, 51_3_72, 51_0_73, 51_1_74, 51_2_75, 51_3_76, 51_0_77, 50_3_78, 50_0_79, 50_1_80, 50_2_81, 50_3_82, 50_0_83, 50_1_84, 50_2_85, 50_3_86, 50_0_87, 50_1_88, 49_0_89, 49_1_90, 49_2_91, 49_3_92, 49_0_93, 49_1_94, 49_2_95, 49_3_96, 49_0_97, 49_1_98, 49_2_99") {
        throw new Error("Self test failed in Calysto.OrderBy test 4. res1: " + res11.join(", "));
    }
    if (res21.join(", ") != "49_0_89, 49_0_93, 49_0_97, 49_1_90, 49_1_94, 49_1_98, 49_2_91, 49_2_95, 49_2_99, 49_3_92, 49_3_96, 50_0_79, 50_0_83, 50_0_87, 50_1_80, 50_1_84, 50_1_88, 50_2_81, 50_2_85, 50_3_78, 50_3_82, 50_3_86, 51_0_69, 51_0_73, 51_0_77, 51_1_70, 51_1_74, 51_2_67, 51_2_71, 51_2_75, 51_3_68, 51_3_72, 51_3_76, 52_0_59, 52_0_63, 52_1_56, 52_1_60, 52_1_64, 52_2_57, 52_2_61, 52_2_65, 52_3_58, 52_3_62, 52_3_66, 53_0_45, 53_0_49, 53_0_53, 53_1_46, 53_1_50, 53_1_54, 53_2_47, 53_2_51, 53_2_55, 53_3_48, 53_3_52, 54_0_35, 54_0_39, 54_0_43, 54_1_36, 54_1_40, 54_1_44, 54_2_37, 54_2_41, 54_3_34, 54_3_38, 54_3_42, 55_0_25, 55_0_29, 55_0_33, 55_1_26, 55_1_30, 55_2_23, 55_2_27, 55_2_31, 55_3_24, 55_3_28, 55_3_32, 56_0_15, 56_0_19, 56_1_12, 56_1_16, 56_1_20, 56_2_13, 56_2_17, 56_2_21, 56_3_14, 56_3_18, 56_3_22, 57_0_0, 57_0_4, 57_0_8, 57_1_1, 57_1_5, 57_1_9, 57_2_2, 57_2_6, 57_2_10, 57_3_3, 57_3_7, 57_3_11") {
        throw new Error("Self test failed in Calysto.OrderBy test 4. res2: " + res21.join(", "));
    }
    if (res31.join(", ") != "49_3_96, 49_3_92, 49_2_99, 49_2_95, 49_2_91, 49_1_98, 49_1_94, 49_1_90, 49_0_97, 49_0_93, 49_0_89, 50_3_86, 50_3_82, 50_3_78, 50_2_85, 50_2_81, 50_1_88, 50_1_84, 50_1_80, 50_0_87, 50_0_83, 50_0_79, 51_3_76, 51_3_72, 51_3_68, 51_2_75, 51_2_71, 51_2_67, 51_1_74, 51_1_70, 51_0_77, 51_0_73, 51_0_69, 52_3_66, 52_3_62, 52_3_58, 52_2_65, 52_2_61, 52_2_57, 52_1_64, 52_1_60, 52_1_56, 52_0_63, 52_0_59, 53_3_52, 53_3_48, 53_2_55, 53_2_51, 53_2_47, 53_1_54, 53_1_50, 53_1_46, 53_0_53, 53_0_49, 53_0_45, 54_3_42, 54_3_38, 54_3_34, 54_2_41, 54_2_37, 54_1_44, 54_1_40, 54_1_36, 54_0_43, 54_0_39, 54_0_35, 55_3_32, 55_3_28, 55_3_24, 55_2_31, 55_2_27, 55_2_23, 55_1_30, 55_1_26, 55_0_33, 55_0_29, 55_0_25, 56_3_22, 56_3_18, 56_3_14, 56_2_21, 56_2_17, 56_2_13, 56_1_20, 56_1_16, 56_1_12, 56_0_19, 56_0_15, 57_3_11, 57_3_7, 57_3_3, 57_2_10, 57_2_6, 57_2_2, 57_1_9, 57_1_5, 57_1_1, 57_0_8, 57_0_4, 57_0_0") {
        throw new Error("Self test failed in Calysto.OrderBy test 4. res3: " + res31.join(", "));
    }
    if (res41.join(", ") != "49_0_97, 49_0_93, 49_0_89, 49_1_98, 49_1_94, 49_1_90, 49_2_99, 49_2_95, 49_2_91, 49_3_96, 49_3_92, 50_0_87, 50_0_83, 50_0_79, 50_1_88, 50_1_84, 50_1_80, 50_2_85, 50_2_81, 50_3_86, 50_3_82, 50_3_78, 51_0_77, 51_0_73, 51_0_69, 51_1_74, 51_1_70, 51_2_75, 51_2_71, 51_2_67, 51_3_76, 51_3_72, 51_3_68, 52_0_63, 52_0_59, 52_1_64, 52_1_60, 52_1_56, 52_2_65, 52_2_61, 52_2_57, 52_3_66, 52_3_62, 52_3_58, 53_0_53, 53_0_49, 53_0_45, 53_1_54, 53_1_50, 53_1_46, 53_2_55, 53_2_51, 53_2_47, 53_3_52, 53_3_48, 54_0_43, 54_0_39, 54_0_35, 54_1_44, 54_1_40, 54_1_36, 54_2_41, 54_2_37, 54_3_42, 54_3_38, 54_3_34, 55_0_33, 55_0_29, 55_0_25, 55_1_30, 55_1_26, 55_2_31, 55_2_27, 55_2_23, 55_3_32, 55_3_28, 55_3_24, 56_0_19, 56_0_15, 56_1_20, 56_1_16, 56_1_12, 56_2_21, 56_2_17, 56_2_13, 56_3_22, 56_3_18, 56_3_14, 57_0_8, 57_0_4, 57_0_0, 57_1_9, 57_1_5, 57_1_1, 57_2_10, 57_2_6, 57_2_2, 57_3_11, 57_3_7, 57_3_3") {
        throw new Error("Self test failed in Calysto.OrderBy test 4. res4: " + res41.join(", "));
    }
    if (res51.join(", ") != "57_3_3, 57_3_7, 57_3_11, 57_2_2, 57_2_6, 57_2_10, 57_1_1, 57_1_5, 57_1_9, 57_0_0, 57_0_4, 57_0_8, 56_3_14, 56_3_18, 56_3_22, 56_2_13, 56_2_17, 56_2_21, 56_1_12, 56_1_16, 56_1_20, 56_0_15, 56_0_19, 55_3_24, 55_3_28, 55_3_32, 55_2_23, 55_2_27, 55_2_31, 55_1_26, 55_1_30, 55_0_25, 55_0_29, 55_0_33, 54_3_34, 54_3_38, 54_3_42, 54_2_37, 54_2_41, 54_1_36, 54_1_40, 54_1_44, 54_0_35, 54_0_39, 54_0_43, 53_3_48, 53_3_52, 53_2_47, 53_2_51, 53_2_55, 53_1_46, 53_1_50, 53_1_54, 53_0_45, 53_0_49, 53_0_53, 52_3_58, 52_3_62, 52_3_66, 52_2_57, 52_2_61, 52_2_65, 52_1_56, 52_1_60, 52_1_64, 52_0_59, 52_0_63, 51_3_68, 51_3_72, 51_3_76, 51_2_67, 51_2_71, 51_2_75, 51_1_70, 51_1_74, 51_0_69, 51_0_73, 51_0_77, 50_3_78, 50_3_82, 50_3_86, 50_2_81, 50_2_85, 50_1_80, 50_1_84, 50_1_88, 50_0_79, 50_0_83, 50_0_87, 49_3_92, 49_3_96, 49_2_91, 49_2_95, 49_2_99, 49_1_90, 49_1_94, 49_1_98, 49_0_89, 49_0_93, 49_0_97") {
        throw new Error("Self test failed in Calysto.OrderBy test 4. res5: " + res51.join(", "));
    }
    //********************************************
    // test 5
    //********************************************
    var res = new Calysto.List(["word1 word2 word3", "this is next", "menu item three"]).Cycle(10).Select((o, n) => ({ Key: n, Value: o })).SkipWhile(o => o.Key < 2).TakeWhile(o => o.Key < 26).Select(o => o.Key + '_' + o.Value).ToStringJoined();
    Calysto.TestTools.UnitTesting.Assert.AreEqual("2_menu item three3_word1 word2 word34_this is next5_menu item three6_word1 word2 word37_this is next8_menu item three9_word1 word2 word3", res);
    //********************************************
    // DomQuery testovie
    //********************************************
    var html = '<div class="search_v2" style="margin-right: 5px;" >\
		<form id="form_search" name="search_main" onsubmit="return check_search_box_keyword()" action="/index.php" method="get">\
			<input name="ctl" type="hidden" value=" ddfe nedgd search2iio" style="display: none" calysto-num="45"/>\
			<label calysto-num="55" for="f_keywords">Upiši pojam...</label>\
			<input name="f_keywords" id="f_keywords" type="text" style="width: 263px" onfocus="javascript:reset_search_style()" />\
			<input calysto-num="25" class="mini_button" type="submit" value="Tražiiio" />\
			<img alt="Beta" style="float: left; margin-top: -3px; padding-left: 5px;" />\
		</form>\
	</div>\
	<div class="clear1" ></div>\
	<div class="clear" ></div>';
    var ddd = Calysto.DomQuery.FromHtml(html);
    //alert(ddd.Query("div:not(>input[name])").Count()); // result: 3
    //var nn = ddd.Query("//[calysto-num <= 45]").Count();
    var results = [
        ddd.Query("div:is(>>input[name='ctl'])").Count(),
        ddd.Query("div:not(>>input[name=ctl])").Count(),
        ddd.Query("//input[type=hidden]").Count(),
        ddd.Query("//input[type]").Count(),
        ddd.Query("//[type]").Count(),
        ddd.Query("//[value^=Tra]").Count(),
        ddd.Query("//[value$=io]").Count(),
        ddd.Query("//[value~=ddfe]").Count(),
        ddd.Query("//[calysto-num]").Count(),
        ddd.Query("//[calysto-num==25]").Count(),
        ddd.Query("//[calysto-num > 25]").Count(),
        ddd.Query("//[calysto-num <= 45]").Count(),
        ddd.Query("div:not(>input[name])").Count() // 3
    ];
    // 1, 2, 1, 3, 8, 1, 2, 1, 8, 1, 2, 2
    var attrTest1 = results.join(", ");
    if (attrTest1 != "1, 2, 1, 3, 3, 1, 2, 1, 3, 1, 2, 2, 3") {
        throw new Error("error in Calysto.DomQuery attribute test, result: " + attrTest1);
    }
    var test1 = ddd.Select(o => o.tagName)
        .Where(o => !!o) // don't take text nodes which doesn't have tagname
        .ToStringJoined(", ").toLowerCase();
    if (test1 != "div, div, div") {
        throw new Error("error in Calysto.DomQuery test1, result: " + test1);
    }
    var test2a = ddd.DescendantNodes()
        .Query("form>label, a, IMG, input.mini_button")
        .Select((o) => o.tagName + o.id + o.name + o.className).ToStringJoined(", ").toLowerCase();
    if (test2a != "labelundefined, img, inputmini_button") {
        throw new Error("self test failed in Calysto.DomQuery test2a, result: " + test2a);
    }
    // animation and color test in Chrome requires node to be attached to DOM
    var html2 = '<div><span id="col333" style="background-color:aliceblue">fdsa</span> <span></span>   <div id="dd1" style="overflow:hidden; border:solid 1px red; width:900px; height:65px; position:absolute; margin-top:0;; top:200px; left:200px; background:red; "> prvi</div>	<div>drugi</div>	<div hrEF="hadsfmojurlfasd">treci<p><a class="mmkk" href="http://www.dd.com/somemylink1">moj link</a></p></div>	<div hrEF="hadsfmojurlfasd">treci<p><a class="mmkk" href="http://www.dd.com/somemylink2">moj link</a></p></div>	<div hrEF="hadsfmojurlfasd">treci<p><a class="mmkk" href="http://www.dd.com/somemylink31">moj link</a><a class="mmkk" href="http://www.dd.com/somemylink32">moj link</a><a class="mmkk" href="http://www.dd.com/somemylink33">moj link</a></p></div>	<div>cetvrti</div>	<div id="hh">peti</div></div>';
    var bbb1 = Calysto.DomQuery.FromHtml(html2);
    /// html has to be attached to dom or else Chrome won't mesure runtime widht and height
    var bbb = Calysto.DomQuery.FromSelector(document.documentElement).InsertChildren(html2).ChildNodes().Take(1);
    var test3 = bbb.DescendantNodes().Query("div>>a:reverse:take(4):skip(1):reverse").SelectAttribute("hrEF").ToStringJoined(", ");
    if (test3 != "http://www.dd.com/somemylink2, http://www.dd.com/somemylink31, http://www.dd.com/somemylink32") {
        throw new Error("Self test failed in Calysto.DomQuery test3. Result: " + test3);
    }
    //throw new Error("Calysto.DomLink tests ok");
    // test4
    var bcolor = $$calysto("#col333").SelectStyle("background-color").FirstOrDefault();
    // IE < v9 returns named color, aliceblue in this case
    if (bcolor != "rgb(240, 248, 255)" && bcolor != "aliceblue") {
        // aliceblue "rgb(240, 248, 255)"
        throw new Error("Self test failed in Calysto.DomQuery test5. Result: " + bcolor + ", expected: " + "rgb(240, 248, 255)");
    }
    var item = bbb.DescendantNodes().Query("#dd1");
    var hh11 = item.SelectStyle("height").FirstOrDefault(); // before
    item.ApplyStyleMap({ width: "950px", opacity: "-=60", height: "+=500" });
    var hh1 = item.SelectStyle("height").FirstOrDefault(); // after
    var hh2 = item.SelectStyle("width").FirstOrDefault();
    var hh3 = item.SelectStyle("opacity").FirstOrDefault();
    var h5 = $$calysto([hh11, hh1, hh2, hh3]).ToStringJoined(", ");
    if (h5 != "65, 565, 950, 40") {
        throw new Error("Self test failed in Calysto.DomQuery test4. Result: " + h5);
    }
    // test5
    item.ToAnimator({ height: "+=460", opacity: "-=10" }).Easing("easeInOutExpo").OnComplete((sender) => {
        var gg11 = sender.AsDomQuery();
        var kk1 = gg11.SelectStyle("opacity").FirstOrDefault();
        var kk2 = gg11.SelectStyle("height").FirstOrDefault();
        var kk6 = $$calysto([kk1]).ToStringJoined(", ");
        if (kk6 != "30") {
            throw new Error("Self test failed in Animator element style test. Result: " + kk6);
        }
        else {
            console.log("Animator element style test successful");
        }
    })
        //.OnProgress((sender, percent) => console.log(percent))
        .Start();
    var anim1 = new Calysto.Animator().AddValue(100, 500 /*, (sender, curr) => console.log("tick: " + curr)*/).OnComplete(sender => {
        var km1 = sender.Items().Select(o => o.numCurrent).pop();
        if (km1 == 500) {
            console.log("Animator numeric value test successful");
        }
        else {
            throw new Error("Self test failed in Animator numeric value test. Result: " + km1);
        }
    })
        //.OnProgress((sender, percent) => console.log("progress: " + percent))
        .Start();
    // test6
    var cnt11 = item.PreviousSiblings().Where(o => o.nodeType != 3).Count();
    if (cnt11 != 2) // count non-text nodes, different doctypes count text node as node or ignore it
     {
        throw new Error("Self test failed in Calysto.DomQuery test6. Result: " + cnt11);
    }
    // test7
    var cnt12 = item.NextSiblings().Where(o => o.nodeType != 3).Count();
    if (cnt12 != 6) // count non-text nodes
     {
        throw new Error("Self test failed in Calysto.DomQuery test7. Result: " + cnt12);
    }
    // remove from dom
    bbb.RemoveFromDom();
    //***********************************************************************
    var kk1 = "my text is this".TakeFirst(9, "...");
    var kk2 = "my text is this".TakeLast(9, "...");
    if (kk1 != "my tex...") {
        throw new Error("Self test failed in String.TakeLast, result: " + kk1);
    }
    if (kk2 != "...s this") {
        throw new Error("Self test failed in String.TakeFirst, result: " + kk2);
    }
    var items11 = Calysto.DomQuery.CreateElement("div").ApplyStyle("border:solid 1px blue; padding:5px;position:absolute;")
        .AddAsChildrenTo(document.documentElement) // script tag must not be outside of html tag
        .AddChildren("<div style='position:absolute;border:solid 10px red;'>this is my div11</div>");
    items11.ChildNodes().ApplyStyle("border:solid 1px green; padding:5px;")
        .InsertBefore(Calysto.DomQuery.CreateElement("div").ApplyStyle("border:15px solid red;").ForEach(o => o.innerHTML = 'div 2'), Calysto.DomQuery.CreateElement("div").ApplyStyle("border:15px solid red;").ForEach(o => o.innerHTML = 'div 3'), Calysto.DomQuery.CreateElement("div").ApplyStyle("border:25px solid red;").ForEach(o => o.innerHTML = 'div 4'), "<div>prvi div</div><div class='hhret435' style='border:solid 18px blue;width:200px;padding:5px;'>drugi div</div><div>third div11</div>", "this is some text node", Calysto.DomQuery.CreateElement("div").ApplyStyle("border:5px solid red;width:auto;").ForEach(o => o.innerHTML = 'div 5') // computed width will be 236px because .hhret435 keeps parent width at 236px
    );
    var dd00 = items11.DescendantNodes("div").ToArray();
    var dd11 = items11.DescendantNodes().WhereStyle("border-top-width", o => o == 18).ToArray(); // .hhret435 // in computedStyleObject border-width is "" on FF and ID
    var dd12 = items11.DescendantNodes().WhereStyle("width", o => o == 236).ToArray(); // div with style="border:5px solid red;width:auto"
    var useBoxSizing = items11.DescendantNodes().SelectStyle("box-sizing").Where(function (o) { return o == "border-box"; }).Any();
    items11.RemoveFromDom();
    if (dd00.length != 8) {
        throw new Error("Self test dd00 failed in Calysto.DomQuery, result: " + dd00.length);
    }
    if (dd11.length != 1) {
        throw new Error("Self test dd11 failed in Calysto.DomQuery, result: " + dd11.length);
    }
    var isOldMsie = Calysto.Features.GetBrowser().KindName == "MSIE" && Calysto.Features.GetBrowser().Version <= 8;
    if (dd12.length != 1 && !isOldMsie && !useBoxSizing) // this test doesn't work in IE <= 8
     {
        throw new Error("Self test dd12 failed in Calysto.DomQuery, result: " + dd12.length);
    }
    var ddd = Calysto.DomQuery.CreateElement("div");
    ddd.ApplyStyle("border:solid 1px blue; padding:5px;")
        .AddChildren("<div style='position:absolute;border:solid 10px red;'>this is my div</div>")
        .ChildNodes().ApplyStyle("border:solid 1px green; padding:5px;")
        .InsertBefore(Calysto.DomQuery.CreateElement("div").ApplyStyle("border:5px solid red;").ForEach(o => o.innerHTML = 'div 2'), Calysto.DomQuery.CreateElement("div").ApplyStyle("border:5px solid red;").ForEach(o => o.innerHTML = 'div 3'), Calysto.DomQuery.CreateElement("div").ApplyStyle("border:5px solid red;").ForEach(o => o.innerHTML = 'div 4'), "<div>first div</div><div>second div</div><div>third div</div>", "some text node 4325", Calysto.DomQuery.CreateElement("div").ApplyStyle("border:5px solid red;").ForEach(o => o.innerHTML = 'div 5')).ParentNodes().DescendantNodes().ApplyStyle("margin:5px;").Where(o => o.childNodes && o.childNodes.length == 1);
    var html111 = ddd.Select(function (o) { return o.innerHTML.replace(/<[^>]+>/g, ""); }).FirstOrDefault(); // ie8 i ie7 prilikom kreiranja elemenata dodaju new line iza svakog elementa pa konacni html nije isti ko na chreomeu i ostalima
    var arr = ddd.DescendantNodes().Where(o => o.nodeType == 1).Select(o => o.nodeValue || o.innerHTML).ToList();
    var hhtml = arr.ToStringJoined(", ");
    if (hhtml != "div 2, div 3, div 4, first div, second div, third div, div 5, this is my div") {
        throw new Error("SelfTest failed in test #html1, result: " + hhtml);
    }
    console.log("DomQuery test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var text = '{"OriginalFilename":"20.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"120.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"20.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"120.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"20.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"120.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}{"OriginalFilename":"20.mp4","GuidFilename":"f553f4ac-0fda-486a-d501-f23afe25fb33.mp4","CreationDate":{"__calystotype":"Calysto_Date","Date":"2016-02-08 12:43:45.512"},"Size":405758,"Duration":5.534,"Description":"ywert","Items":[{"Url":"http://cms.24sata.hr/api/video-upload/get-media-id/","PostData":{"filename":"20.mp4","description":"ywert"},"ResponseXml":null,"Command":1,"FileID":null,"Extension":".mp4","Message":"The remote server returned an error: (403) Forbidden.","Path":null}],"FtpUploaders":[]}';
    var c = new Calysto.Utility.StringCompressor();
    var compr = c.Compress(text);
    if (compr == text) {
        throw new Error("StringCompressor selftest error, compressed result: " + compr);
    }
    var decompr = c.Decompress(compr);
    if (decompr != text) {
        throw new Error("StringCompressor selftest error, decompressed result: " + decompr);
    }
    console.log("StringCompressor test succesful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    // this is test for .OrderBy() which now uses grouping by Key first, then is sorted, it is how .NET works too
    var enc = new Calysto.Security.Cryptography.SimpleEncryptor("lozinka");
    var encrypted = Calysto.Utility.Encoding.RfcBase64.EncodeToBase64String(enc.Encrypt("this is my text čćžđš"));
    if (encrypted != "LNnDGAHDGAFAkAEs5E8sAZMtkxl1IZNRdX4=") {
        throw new Error("SimpleEncryptor.Encrypt() error, result: " + encrypted);
    }
    var decrypted = enc.DecryptToString(Calysto.Utility.Encoding.RfcBase64.DecodeBase64StringToArray(encrypted));
    if (decrypted != "this is my text čćžđš") {
        throw new Error("SimpleEncryptor.Decrypt() error, result: " + decrypted);
    }
    console.log("SimpleEncryptor test succesful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    var res1 = [
        Calysto.Validate.IsEmail("myname@mfsd"),
        Calysto.Validate.IsEmail("myname@mfsd.com"),
        Calysto.Validate.IsEmail("myname.me@mfsd"),
        Calysto.Validate.IsEmail("myname.me@mfsd.com"),
        "---",
        Calysto.Validate.CanConvertToNumber("gasdfg"),
        Calysto.Validate.CanConvertToNumber("gasdf432523"),
        Calysto.Validate.CanConvertToNumber("234.532"),
        Calysto.Validate.CanConvertToNumber("23,4532.63"),
        "---",
        Calysto.Validate.CanConvertToDecimal("234.532"),
        Calysto.Validate.ContainsNumber("f423gsda6234"),
        "---",
        Calysto.Validate.CanConvertToInteger("-432.652354"),
        Calysto.Validate.IsIPv4Address("4234"),
        Calysto.Validate.IsIPv4Address("234"),
        Calysto.Validate.IsIPv4Address("234.23.4.5"),
        Calysto.Validate.IsIPv4Address("234.23.4")
    ];
    if (res1.join(";") != "false;true;false;true;---;false;false;true;true;---;true;true;---;false;false;false;true;false")
        throw new Error("Validate error, result: " + res1.join(";"));
    console.log("Validate test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    function TestDiagnosticString(uri, expected) {
        let s1 = Object.getOwnPropertyNames(uri).Select(prop => prop + ":::" + uri[prop]).ToStringJoined(";;;");
        if (s1 != expected)
            throw new Error("Uri error, expected: " + expected + ", result: " + s1);
    }
    TestDiagnosticString(new Calysto.Uri("https://85.114.41.97/"), "Scheme:::https;;;Username:::;;;Password:::;;;Host:::85.114.41.97;;;Port:::;;;Path:::/;;;Query:::;;;Hash:::");
    TestDiagnosticString(new Calysto.Uri("http://domena.com:43/nesto/dva/dru.aspx?qu=3&gr=3#dd=rel"), "Scheme:::http;;;Username:::;;;Password:::;;;Host:::domena.com;;;Port:::43;;;Path:::/nesto/dva/dru.aspx;;;Query:::?qu=3&gr=3;;;Hash:::#dd=rel");
    TestDiagnosticString(new Calysto.Uri("http://domaena.com:233/../dva.aspx?a=10&b=22#dva"), "Scheme:::http;;;Username:::;;;Password:::;;;Host:::domaena.com;;;Port:::233;;;Path:::/../dva.aspx;;;Query:::?a=10&b=22;;;Hash:::#dva");
    TestDiagnosticString(new Calysto.Uri("http://domain.com/?m=10"), "Scheme:::http;;;Username:::;;;Password:::;;;Host:::domain.com;;;Port:::;;;Path:::/;;;Query:::?m=10;;;Hash:::");
    TestDiagnosticString(new Calysto.Uri("http://username:password@www.nesto.com:1233/mypath/bill.aspx?a=10&b=20#c=3&c=4"), "Scheme:::http;;;Username:::username;;;Password:::password;;;Host:::www.nesto.com;;;Port:::1233;;;Path:::/mypath/bill.aspx;;;Query:::?a=10&b=20;;;Hash:::#c=3&c=4");
    TestDiagnosticString(new Calysto.Uri("/"), "Scheme:::;;;Username:::;;;Password:::;;;Host:::;;;Port:::;;;Path:::/;;;Query:::;;;Hash:::");
    TestDiagnosticString(new Calysto.Uri("/some/path.aspx"), "Scheme:::;;;Username:::;;;Password:::;;;Host:::;;;Port:::;;;Path:::/some/path.aspx;;;Query:::;;;Hash:::");
    TestDiagnosticString(new Calysto.Uri("?q=13&b=32"), "Scheme:::;;;Username:::;;;Password:::;;;Host:::;;;Port:::;;;Path:::;;;Query:::?q=13&b=32;;;Hash:::");
    console.log("Uri test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    let results = [];
    let OnTest = new Calysto.MulticastDelegate().OnAdd((delegate) => {
        results.push("in_OnAdd");
        delegate("ante", 10, false);
    }).AsFunc({ Prop1: true, Prop2: false });
    OnTest((name, age, isWhite) => {
        results.push("Invocation");
        results.push({ name: name, age: age, isWhite: isWhite });
    });
    OnTest.Invoke(f => f("jura", 22, true));
    OnTest.Invoke(f => f("karmen", 55, false));
    OnTest.Invoke(f => f("junior", 11, true));
    // has to be invokable with 0 arguments, for compatibility with Calysto.Page.OnVersionExpired.Invoke();
    OnTest.Invoke();
    let res1 = Calysto.Json.Serialize(results);
    if (res1 != `["in_OnAdd","Invocation",{"name":"ante","age":10,"isWhite":false},"Invocation",{"name":"jura","age":22,"isWhite":true},"Invocation",{"name":"karmen","age":55,"isWhite":false},"Invocation",{"name":"junior","age":11,"isWhite":true},"Invocation",{"name":null,"age":null,"isWhite":null}]`) {
        throw new Error("Error in Calysto.MulticastDelegate, result1: " + res1);
    }
    console.log("MulticastDelegate test successful");
});
//#endif
//#if DEBUG
Calysto.TestTools.TestRunner.AddTest(() => {
    let culture1 = Calysto.Globalization.CultureInfo.CurrentCulture;
    Calysto.Globalization.CultureInfo.CurrentCulture = Calysto.Globalization.CultureInfo.USCulture;
    let pp = Calysto.Resources.CalystoLang.ResourceProvider;
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Invocation forbidden", pp.GetString("MethodInvocationFobidden"));
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Invocation forbidden", pp.GetString("MethodInvocationFobidden", ["en-US"]));
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Nemate dozvolu za ovu akciju", pp.GetString("MethodInvocationFobidden", ["hr-HR"]));
    Calysto.TestTools.UnitTesting.Assert.ThrowsException(() => pp.GetString("MethodInvocationFobidden", ["nonexisting property"]));
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Please wait, page is reloading...", pp.GetString("PageIsReloadingPleaseWait"));
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Please wait, page is reloading...", pp.GetString("PageIsReloadingPleaseWait", ["en-US"]));
    Calysto.TestTools.UnitTesting.Assert.AreEqual("Molimo pričekajte, stranica se osvježava...", pp.GetString("PageIsReloadingPleaseWait", ["hr-HR"]));
    Calysto.TestTools.UnitTesting.Assert.ThrowsException(() => pp.GetString("PageIsReloadingPleaseWait", ["nonexisting property"]));
    // restore culture
    Calysto.Globalization.CultureInfo.CurrentCulture = culture1;
});
//#endif
//#if DEBUG
var Calysto;
(function (Calysto) {
    var Tasks;
    (function (Tasks) {
        Calysto.TestTools.TestRunner.AddTest(() => __awaiter(this, void 0, void 0, function* () {
            function PromiseTest(promiseName, promiseCtor) {
                return __awaiter(this, void 0, void 0, function* () {
                    // firefox doesn't work if delay is less than 100 ms (sport je pa se eventi preklope)
                    let t1 = 200;
                    let result1 = [];
                    function GetName() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return new promiseCtor((resolve, reject) => {
                                result1.push("#1");
                                //throw new Error("greska");
                                setTimeout(() => resolve("success1"), t1);
                                //setTimeout(() => resolve("success2"), 1500);
                                //setTimeout(() => reject("success3"), 2000);
                            })
                                .then(value => {
                                result1.push("#2");
                                result1.push(value);
                                //console.log("then: " + value);
                                return value;
                            })
                                .then(value => {
                                result1.push("#3");
                                result1.push(value);
                                //console.log("then2: " + value);
                                return new promiseCtor((resolve, reject) => {
                                    setTimeout(() => {
                                        result1.push("#4");
                                        resolve("success2222");
                                    }, t1);
                                });
                            })
                                .then(value => {
                                result1.push("#5");
                                result1.push(value);
                                //console.log("then2: " + value);
                                return new promiseCtor((resolve, reject) => {
                                    setTimeout(() => {
                                        result1.push("#6");
                                        resolve("success1111");
                                    }, t1);
                                });
                            })
                                .catch(err => {
                                result1.push("#7");
                                result1.push(err);
                                //console.log("catch: " + err);
                                return "dva"; //err;
                            })
                                .finally(() => {
                                result1.push("#8");
                                //console.log("finally");
                                return "amd";
                            });
                        });
                    }
                    function ShowResult() {
                        return __awaiter(this, void 0, void 0, function* () {
                            //console.log("point1");
                            let res1 = yield GetName();
                            result1.push(res1);
                            //console.log("result: " + res1);
                        });
                    }
                    result1.push("s0");
                    ShowResult();
                    result1.push("s1");
                    setTimeout(() => {
                        let str1 = result1.ToStringJoined(", ");
                        Calysto.TestTools.UnitTesting.Assert.AreEqual("s0, #1, s1, s2, s3, #2, success1, #3, success1, #4, #5, success2222, #6, #8, success1111", str1);
                        console.log(promiseName + " test successful");
                    }, t1 * 3.5);
                    result1.push("s2");
                    setTimeout(() => {
                        let str1 = result1.ToStringJoined(", ");
                        Calysto.TestTools.UnitTesting.Assert.AreEqual("s0, #1, s1, s2, s3, #2, success1, #3, success1, #4, #5, success2222", str1);
                    }, t1 * 2.5);
                    result1.push("s3");
                    setTimeout(() => {
                        let str1 = result1.ToStringJoined(", ");
                        Calysto.TestTools.UnitTesting.Assert.AreEqual("s0, #1, s1, s2, s3", str1);
                    }, t1 * 0.5);
                    return new promiseCtor((resolve) => {
                        setTimeout(() => resolve(), t1 * 4);
                    });
                });
            }
            yield PromiseTest("CPromise", Tasks.CPromise);
            yield PromiseTest("Promise", window.Promise);
        }));
    })(Tasks = Calysto.Tasks || (Calysto.Tasks = {}));
})(Calysto || (Calysto = {}));
//#endif
//************************************************************
// type def
//************************************************************
/// <reference path="../../../Extern/facebook-js-sdk.d.ts" />
/// <reference path="../../../Extern/gapi-index.d.ts" />
/// <reference path="../../../Extern/gapi.auth-index.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.form.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.validate.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.validate.unobtrusive.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.soap.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.cycle.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.color.d.ts" />
/// <reference path="../../../Extern/jquery/jquery.pajax.d.ts" />
/// <reference path="../../../Extern/bootstrap/bootstrap.d.ts" />
//************************************************************
// Calysto engine
//************************************************************
/// <reference path="../../Src/Core/Tasks/Tasks.ts" />
/// <reference path="../../../resources/Images/Images.ts" />
/// <reference path="../../Src/Core/Constants/AppConstants.ts" />
/// <reference path="../../Src/Core/Constants/WsjsHeaderConstants.ts" />
/// <reference path="../../Src/Core/Constants/PredefinedCultures.ts" />
/// <reference path="../../Src/Core/Constants/CalystoDomAttributes.ts" />
/// <reference path="../../Src/Core/Constants/CalystoAjaxHandlerConstants.ts" />
/// <reference path="../../Src/Core/Constants/BaseXCharsTable.ts" />
/// <reference path="../../Src/Core/Globalization/ResxExcelProvider.ts" />
/// <reference path="../../../Resources/CalystoLang/CalystoLang.generated.ts" />
/// <reference path="../../Src/Core/Extension/Date.d.ts" />
/// <reference path="../../Src/Core/Extension/Location.d.ts" />
/// <reference path="../../Src/Core/Extension/Array.d.ts" />
/// <reference path="../../Src/Core/Core.ts" />
/// <reference path="../../Src/Core/AttrName.ts" />
/// <reference path="../../Src/Core/BoxValue.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Generators.ts" />
/// <reference path="../../Src/Core/Enumerable/ArraySorter.ts" />
/// <reference path="../../Src/Core/Enum.ts" />
/// <reference path="../../Src/Core/Globalization/Globalization.ts" />
/// <reference path="../../Src/Core/Extension/Array.ts" />
/// <reference path="../../Src/Core/Extension/Map.ts" />
/// <reference path="../../Src/Core/Extension/Math.ts" />
/// <reference path="../../Src/Core/Extension/Blob.ts" />
/// <reference path="../../Src/Core/Extension/Boolean.ts" />
/// <reference path="../../Src/Core/Extension/Date.ts" />
/// <reference path="../../Src/Core/Extension/Error.ts" />
/// <reference path="../../Src/Core/Extension/Function.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Expressions.ts" />
/// <reference path="../../Src/Core/Extension/Regexp.ts" />
/// <reference path="../../Src/Core/DataBinder.ts" />
/// <reference path="../../Src/Core/Utility/Utility.ts" />
/// <reference path="../../Src/Core/Type/Type.ts" />
/// <reference path="../../Src/Core/Mathm.ts" />
/// <reference path="../../Src/Core/Extension/Number.ts" />
/// <reference path="../../Src/Core/Extension/String.ts" />
/// <reference path="../../Src/Core/TimeSpan.ts" />
/// <reference path="../../Src/Core/DateTime.ts" />
/// <reference path="../../Src/Core/Dictionary.ts" />
/// <reference path="../../Src/Core/Enumerable/Collections.ts" />
/// <reference path="../../Src/Core/Enumerable/Enumerator.ts" />
/// <reference path="../../Src/Core/Enumerable/Enumerable.ts" />
/// <reference path="../../Src/Core/Features.ts" />
/// <reference path="../../Src/Core/CookieUtility.ts" />
/// <reference path="../../Src/Core/Event.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Html.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Encoding.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Dom.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Path.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Blob.ts" />
/// <reference path="../../Src/Core/Utility/Utility.Caret.ts" />
/// <reference path="../../Src/Core/Utility/Utility.FullScreen.ts" />
/// <reference path="../../Src/Core/Utility/Utility.CalystoTools.ts" />
/// <reference path="../../Src/Core/Graphics.ImageResize.ts" />
/// <reference path="../../Src/Core/QueryString.ts" />
/// <reference path="../../Src/Core/ScriptLoader.ts" />
/// <reference path="../../Src/Core/Timer.ts" />
/// <reference path="../../Src/Core/Uri.ts" />
/// <reference path="../../Src/Core/Validate.ts" />
/// <reference path="../../Src/Core/Regex.ts" />
/// <reference path="../../Src/Core/StyleSheet.ts" />
/// <reference path="../../Src/Core/JSON/JSON.ts" />
/// <reference path="../../Src/Core/JSON/JSON.JsonNode.ts" />
/// <reference path="../../Src/Core/JSON/JSON.BinaryFrame.ts" />
/// <reference path="../../Src/Core/Dialog/Dialog.ts" />
/// <reference path="../../Src/Core/Notification/Notification.ts" />
/// <reference path="../../Src/Core/Net/Net.WebClient.ts" />
/// <reference path="../../Src/Core/Net/Net.WebSocket.ts" />
/// <reference path="../../Src/Core/Net/Net.WebService.ts" />
/// <reference path="../../Src/Core/MulticastDelegate.ts" />
/// <reference path="../../Src/Core/Page/Page.ts" />
/// <reference path="../../Src/Core/Page/Social/Facebook.ts" />
/// <reference path="../../Src/Core/Page/Social/Google.ts" />
/// <reference path="../../Src/Core/Page/Page.Google.AnalyticsService.ts" />
/// <reference path="../../Src/Core/Page/Page.Preloader.ts" />
/// <reference path="../../Src/Core/Page/Page.Diagnostic.ts" />
/// <reference path="../../Src/Core/AjaxHistory.ts" />
/// <reference path="../../Src/Core/PostMessage.ts" />
/// <reference path="../../Src/Core/Forms/Forms.ts" />
/// <reference path="../../Src/Core/Enumerable/JsObjectReader.ts" />
/// <reference path="../../Src/Core/Enumerable/SelectorReader.ts" />
/// <reference path="../../Src/Core/Enumerable/DomQuery.ts" />
/// <reference path="../../Src/Core/Colorspace.ts" />
/// <reference path="../../Src/Core/Animator.ts" />
/// <reference path="../../Src/Core/Preloaders.ts" />
/// <reference path="../../Src/Core/DataTable.ts" />
/// <reference path="../../Src/Core/Enumerable/List.ts" />
/// <reference path="../../Src/Core/Utility/Utility.StringCompressor.ts" />
/// <reference path="../../Src/Core/Security/SimpleEncryptor.ts" />
/// <reference path="../../Src/Core/UnitTesting/TestTools.UnitTesting.ts" />
/// <reference path="../../Src/Core/UnitTesting/TestTools.TestsRunner.ts" />
/// <reference path="../../Src/Core/Console.ts" />
/// <reference path="../../Src/Core/CacheProvider.ts" />
/// <reference path="../../Src/Core/Mvc/Mvc.ts" />
/// <reference path="../../src/core/Binding/Binding.d.ts" />
/// <reference path="../../Src/Core/Binding/BindingEnums.ts" />
/// <reference path="../../Src/Core/Binding/BindingSetup.ts" />
/// <reference path="../../Src/Core/Binding/BindingAttributes.ts" />
/// <reference path="../../Src/Core/Binding/BindingCache.ts" />
/// <reference path="../../Src/Core/Binding/BindingDataSource.ts" />
/// <reference path="../../Src/Core/Binding/BindingDictionaryTree.ts" />
/// <reference path="../../Src/Core/Binding/BindingElementPathResolver.ts" />
/// <reference path="../../Src/Core/Binding/BindingObservable.ts" />
/// <reference path="../../Src/Core/Web/CalystoVirtualPathHelper.ts" />
/// <reference path="../../Src/Core/DataAnnotations/CalystoValidationService.ts" />
/// <reference path="../../Src/Core/WebControls/Table/Table.ts" />
/// <reference path="../../Src/Core/Web/Direct/UI/CalystoMvcModelState.ts" />
//************************************************************
// Calysto web controls
//************************************************************
/// <reference path="../../Src/Core/WebControls/Scroller/Scroller.ts" />
//************************************************************
// TESTS
//************************************************************
/// <reference path="../../Src/Core/Enumerable/Collections.TEST.ts" />
/// <reference path="../../Src/Core/Enumerable/Enumerable.TEST.ts" />
/// <reference path="../../Src/Core/DateTime.TEST.ts" />
/// <reference path="../../Src/Core/Dictionary.TEST.ts" />
/// <reference path="../../Src/Core/Enum.TEST.ts" />
/// <reference path="../../Src/Core/Type/Type.TEST.ts" />
/// <reference path="../../Src/Core/Utility/Utility.TEST.ts" />
/// <reference path="../../Src/Core/extension/String.TEST.ts" />
/// <reference path="../../Src/Core/extension/Number.TEST.ts" />
/// <reference path="../../Src/Core/QueryString.TEST.ts" />
/// <reference path="../../Src/Core/Regex.TEST.ts" />
/// <reference path="../../Src/Core/json/JSON.JsonNode.TEST.ts" />
/// <reference path="../../Src/Core/net/Net.WebClient.TEST.ts" />
/// <reference path="../../Src/Core/Forms/Forms.TEST.ts" />
/// <reference path="../../Src/Core/Enumerable/DomQuery.TEST.ts" />
/// <reference path="../../Src/Core/Utility/Utility.StringCompressor.TEST.ts" />
/// <reference path="../../Src/Core/security/SimpleEncryptor.TEST.ts" />
/// <reference path="../../Src/Core/Validate.TEST.ts" />
/// <reference path="../../Src/Core/Uri.TEST.ts" />
/// <reference path="../../Src/Core/MulticastDelegate.TEST.ts" />
/// <reference path="../../Src/Core/Globalization/ResxExcelProvider.TEST.ts" />
/// <reference path="../../Src/Core/Tasks/CPromise.TEST.ts" />
//# sourceMappingURL=Engine.complete.js.map